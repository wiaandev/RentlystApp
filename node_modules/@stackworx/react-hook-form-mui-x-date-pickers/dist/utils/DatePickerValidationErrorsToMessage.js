function mapDateTimePickerValidationErrorMessage(error, props) {
  const maxDate = (props == null ? void 0 : props.maxDate) || (props == null ? void 0 : props.maxDateTime);
  const minDate = (props == null ? void 0 : props.minDate) || (props == null ? void 0 : props.minDateTime);
  const maxTime = (props == null ? void 0 : props.maxTime) || (props == null ? void 0 : props.maxDateTime);
  const minTime = (props == null ? void 0 : props.minTime) || (props == null ? void 0 : props.minDateTime);
  switch (error) {
    case "invalidDate":
      return "Invalid date/time value provided";
    case "disablePast":
      return "Values in the past are not allowed";
    case "disableFuture":
      return "Values in the future are not allowed";
    case "maxDate":
      return maxDate ? `Date should not be after ${maxDate}` : "Date should not be after the specified limit";
    case "minDate":
      return minDate ? `Date should not be before ${minDate}` : "Date should not be before the specified limit";
    case "maxTime":
      return maxTime ? `Time should not be after ${maxTime}` : "Time should not be after the specified limit";
    case "minTime":
      return minTime ? `Time should not be before ${minTime}` : "Time should not be before the specified limit";
    case "minutesStep":
      return `Invalid minutes step, can only step in increments of ${(props == null ? void 0 : props.minutesStep) || "Invalid minutes step"}`;
    case "shouldDisableMonth":
      return "Month is not allowed";
    case "shouldDisableYear":
      return "Year is not allowed";
    case "shouldDisableDate":
      return "Date is not allowed";
    case "shouldDisableTime-hours":
      return "Specified hour is disabled";
    case "shouldDisableTime-minutes":
      return "Specified minute is disabled";
    case "shouldDisableTime-seconds":
      return "Specified second is disabled";
    default:
      return null;
  }
}
function mapDatePickerValidationErrorMessage(error, props) {
  const { maxDate, minDate } = props;
  switch (error) {
    case "invalidDate":
      return "Invalid date value provided";
    case "disablePast":
      return "Values in the past are not allowed";
    case "disableFuture":
      return "Values in the future are not allowed";
    case "maxDate":
      return maxDate ? `Date should not be after ${maxDate}` : "Date should not be after the specified limit";
    case "minDate":
      return minDate ? `Date should not be before ${minDate}` : "Date should not be before the specified limit";
    case "shouldDisableMonth":
      return "Month is not allowed";
    case "shouldDisableYear":
      return "Year is not allowed";
    case "shouldDisableDate":
      return "Date is not allowed";
    default:
      return null;
  }
}
function mapTimePickerValidationErrorMessage(error, props) {
  const { minTime, maxTime } = props;
  switch (error) {
    case "invalidDate":
      return "Invalid date/time value provided";
    case "disablePast":
      return "Values in the past are not allowed";
    case "disableFuture":
      return "Values in the future are not allowed";
    case "maxTime":
      return maxTime ? `Time should not be after ${maxTime}` : "Time should not be after the specified limit";
    case "minTime":
      return minTime ? `Time should not be before ${minTime}` : "Time should not be before the specified limit";
    case "minutesStep":
      return `Invalid minutes step, can only step in increments of ${(props == null ? void 0 : props.minutesStep) || "Invalid minutes step"}`;
    case "shouldDisableTime-hours":
      return "Specified hour is disabled";
    case "shouldDisableTime-minutes":
      return "Specified minute is disabled";
    case "shouldDisableTime-seconds":
      return "Specified second is disabled";
    default:
      return null;
  }
}
export {
  mapDatePickerValidationErrorMessage,
  mapDateTimePickerValidationErrorMessage,
  mapTimePickerValidationErrorMessage
};
//# sourceMappingURL=DatePickerValidationErrorsToMessage.js.map
