import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/relay-runtime/lib/util/RelayConcreteNode.js
var require_RelayConcreteNode = __commonJS({
  "node_modules/relay-runtime/lib/util/RelayConcreteNode.js"(exports, module) {
    "use strict";
    var RelayConcreteNode = {
      ACTOR_CHANGE: "ActorChange",
      CATCH_FIELD: "CatchField",
      CONDITION: "Condition",
      CLIENT_COMPONENT: "ClientComponent",
      CLIENT_EDGE_TO_SERVER_OBJECT: "ClientEdgeToServerObject",
      CLIENT_EDGE_TO_CLIENT_OBJECT: "ClientEdgeToClientObject",
      CLIENT_EXTENSION: "ClientExtension",
      DEFER: "Defer",
      CONNECTION: "Connection",
      FRAGMENT: "Fragment",
      FRAGMENT_SPREAD: "FragmentSpread",
      INLINE_DATA_FRAGMENT_SPREAD: "InlineDataFragmentSpread",
      INLINE_DATA_FRAGMENT: "InlineDataFragment",
      INLINE_FRAGMENT: "InlineFragment",
      LINKED_FIELD: "LinkedField",
      LINKED_HANDLE: "LinkedHandle",
      LITERAL: "Literal",
      LIST_VALUE: "ListValue",
      LOCAL_ARGUMENT: "LocalArgument",
      MODULE_IMPORT: "ModuleImport",
      ALIASED_FRAGMENT_SPREAD: "AliasedFragmentSpread",
      ALIASED_INLINE_FRAGMENT_SPREAD: "AliasedInlineFragmentSpread",
      RELAY_RESOLVER: "RelayResolver",
      RELAY_LIVE_RESOLVER: "RelayLiveResolver",
      REQUIRED_FIELD: "RequiredField",
      OBJECT_VALUE: "ObjectValue",
      OPERATION: "Operation",
      REQUEST: "Request",
      ROOT_ARGUMENT: "RootArgument",
      SCALAR_FIELD: "ScalarField",
      SCALAR_HANDLE: "ScalarHandle",
      SPLIT_OPERATION: "SplitOperation",
      STREAM: "Stream",
      TYPE_DISCRIMINATOR: "TypeDiscriminator",
      UPDATABLE_QUERY: "UpdatableQuery",
      VARIABLE: "Variable"
    };
    module.exports = RelayConcreteNode;
  }
});

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  }
});

// node_modules/fbjs/lib/emptyFunction.js
var require_emptyFunction = __commonJS({
  "node_modules/fbjs/lib/emptyFunction.js"(exports, module) {
    "use strict";
    function makeEmptyFunction(arg) {
      return function() {
        return arg;
      };
    }
    var emptyFunction = function emptyFunction2() {
    };
    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function() {
      return this;
    };
    emptyFunction.thatReturnsArgument = function(arg) {
      return arg;
    };
    module.exports = emptyFunction;
  }
});

// node_modules/fbjs/lib/warning.js
var require_warning = __commonJS({
  "node_modules/fbjs/lib/warning.js"(exports, module) {
    "use strict";
    var emptyFunction = require_emptyFunction();
    function printWarning(format) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var argIndex = 0;
      var message = "Warning: " + format.replace(/%s/g, function() {
        return args[argIndex++];
      });
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    }
    var warning = true ? function(condition, format) {
      if (format === void 0) {
        throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
      }
      if (!condition) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }
        printWarning.apply(void 0, [format].concat(args));
      }
    } : emptyFunction;
    module.exports = warning;
  }
});

// node_modules/relay-runtime/lib/query/GraphQLTag.js
var require_GraphQLTag = __commonJS({
  "node_modules/relay-runtime/lib/query/GraphQLTag.js"(exports, module) {
    "use strict";
    var RelayConcreteNode = require_RelayConcreteNode();
    var invariant = require_browser();
    var warning = require_warning();
    function graphql(strings) {
      true ? true ? invariant(false, "graphql: Unexpected invocation at runtime. Either the Babel transform was not set up, or it failed to identify this call site. Make sure it is being used verbatim as `graphql`. Note also that there cannot be a space between graphql and the backtick that follows.") : invariant(false) : void 0;
    }
    function getNode(taggedNode) {
      var node = taggedNode;
      if (typeof node === "function") {
        node = node();
        true ? warning(false, "RelayGraphQLTag: node `%s` unexpectedly wrapped in a function.", node.kind === "Fragment" ? node.name : node.operation.name) : void 0;
      } else if (node["default"]) {
        node = node["default"];
      }
      return node;
    }
    function isFragment(node) {
      var fragment = getNode(node);
      return typeof fragment === "object" && fragment !== null && fragment.kind === RelayConcreteNode.FRAGMENT;
    }
    function isRequest(node) {
      var request = getNode(node);
      return typeof request === "object" && request !== null && request.kind === RelayConcreteNode.REQUEST;
    }
    function isUpdatableQuery(node) {
      var updatableQuery = getNode(node);
      return typeof updatableQuery === "object" && updatableQuery !== null && updatableQuery.kind === RelayConcreteNode.UPDATABLE_QUERY;
    }
    function isInlineDataFragment(node) {
      var fragment = getNode(node);
      return typeof fragment === "object" && fragment !== null && fragment.kind === RelayConcreteNode.INLINE_DATA_FRAGMENT;
    }
    function getFragment(taggedNode) {
      var fragment = getNode(taggedNode);
      !isFragment(fragment) ? true ? invariant(false, "GraphQLTag: Expected a fragment, got `%s`.", JSON.stringify(fragment)) : invariant(false) : void 0;
      return fragment;
    }
    function getPaginationFragment(taggedNode) {
      var _fragment$metadata;
      var fragment = getFragment(taggedNode);
      var refetch = (_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.refetch;
      var connection = refetch === null || refetch === void 0 ? void 0 : refetch.connection;
      if (refetch === null || typeof refetch !== "object" || connection === null || typeof connection !== "object") {
        return null;
      }
      return fragment;
    }
    function getRefetchableFragment(taggedNode) {
      var _fragment$metadata2;
      var fragment = getFragment(taggedNode);
      var refetch = (_fragment$metadata2 = fragment.metadata) === null || _fragment$metadata2 === void 0 ? void 0 : _fragment$metadata2.refetch;
      if (refetch === null || typeof refetch !== "object") {
        return null;
      }
      return fragment;
    }
    function getRequest(taggedNode) {
      var request = getNode(taggedNode);
      !isRequest(request) ? true ? invariant(false, "GraphQLTag: Expected a request, got `%s`.", JSON.stringify(request)) : invariant(false) : void 0;
      return request;
    }
    function getUpdatableQuery(taggedNode) {
      var updatableQuery = getNode(taggedNode);
      !isUpdatableQuery(updatableQuery) ? true ? invariant(false, "GraphQLTag: Expected a request, got `%s`.", JSON.stringify(updatableQuery)) : invariant(false) : void 0;
      return updatableQuery;
    }
    function getInlineDataFragment(taggedNode) {
      var fragment = getNode(taggedNode);
      !isInlineDataFragment(fragment) ? true ? invariant(false, "GraphQLTag: Expected an inline data fragment, got `%s`.", JSON.stringify(fragment)) : invariant(false) : void 0;
      return fragment;
    }
    module.exports = {
      getFragment,
      getNode,
      getPaginationFragment,
      getRefetchableFragment,
      getRequest,
      getUpdatableQuery,
      getInlineDataFragment,
      graphql,
      isFragment,
      isRequest,
      isUpdatableQuery,
      isInlineDataFragment
    };
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(e, r, t) {
      return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/objectSpread2.js
var require_objectSpread2 = __commonJS({
  "node_modules/@babel/runtime/helpers/objectSpread2.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return arrayLikeToArray(r);
    }
    module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
      }
    }
    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(r) {
      return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
    }
    module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js
var require_RelayDefaultHandleKey = __commonJS({
  "node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js"(exports, module) {
    "use strict";
    module.exports = {
      DEFAULT_HANDLE_KEY: ""
    };
  }
});

// node_modules/relay-runtime/lib/util/getRelayHandleKey.js
var require_getRelayHandleKey = __commonJS({
  "node_modules/relay-runtime/lib/util/getRelayHandleKey.js"(exports, module) {
    "use strict";
    var _require = require_RelayDefaultHandleKey();
    var DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;
    var invariant = require_browser();
    function getRelayHandleKey(handleName, key, fieldName) {
      if (key && key !== DEFAULT_HANDLE_KEY) {
        return "__".concat(key, "_").concat(handleName);
      }
      !(fieldName != null) ? true ? invariant(false, "getRelayHandleKey: Expected either `fieldName` or `key` in `handle` to be provided") : invariant(false) : void 0;
      return "__".concat(fieldName, "_").concat(handleName);
    }
    module.exports = getRelayHandleKey;
  }
});

// node_modules/relay-runtime/lib/util/stableCopy.js
var require_stableCopy = __commonJS({
  "node_modules/relay-runtime/lib/util/stableCopy.js"(exports, module) {
    "use strict";
    function stableCopy(value) {
      if (!value || typeof value !== "object") {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map(stableCopy);
      }
      var keys = Object.keys(value).sort();
      var stable = {};
      for (var i = 0; i < keys.length; i++) {
        stable[keys[i]] = stableCopy(value[keys[i]]);
      }
      return stable;
    }
    function hasCycle(value) {
      var parents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
      if (!value || typeof value !== "object") {
        return false;
      }
      if (parents.has(value)) {
        return true;
      }
      var newParents = new Set(parents);
      newParents.add(value);
      var children = Array.isArray(value) ? value : Object.values(value);
      return children.some(function(v) {
        return hasCycle(v, newParents);
      });
    }
    module.exports = {
      stableCopy,
      hasCycle
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayStoreUtils.js
var require_RelayStoreUtils = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayStoreUtils.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var getRelayHandleKey = require_getRelayHandleKey();
    var RelayConcreteNode = require_RelayConcreteNode();
    var _require = require_stableCopy();
    var stableCopy = _require.stableCopy;
    var invariant = require_browser();
    var VARIABLE = RelayConcreteNode.VARIABLE;
    var LITERAL = RelayConcreteNode.LITERAL;
    var OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE;
    var LIST_VALUE = RelayConcreteNode.LIST_VALUE;
    var ERRORS_KEY = "__errors";
    var MODULE_COMPONENT_KEY_PREFIX = "__module_component_";
    var MODULE_OPERATION_KEY_PREFIX = "__module_operation_";
    function getArgumentValue(arg, variables) {
      if (arg.kind === VARIABLE) {
        return getStableVariableValue(arg.variableName, variables);
      } else if (arg.kind === LITERAL) {
        return arg.value;
      } else if (arg.kind === OBJECT_VALUE) {
        var value = {};
        arg.fields.forEach(function(field) {
          value[field.name] = getArgumentValue(field, variables);
        });
        return value;
      } else if (arg.kind === LIST_VALUE) {
        var _value = [];
        arg.items.forEach(function(item) {
          item != null ? _value.push(getArgumentValue(item, variables)) : null;
        });
        return _value;
      }
    }
    function getArgumentValues(args, variables, isWithinUnmatchedTypeRefinement) {
      var values = {};
      if (isWithinUnmatchedTypeRefinement) {
        values[RelayStoreUtils.FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = true;
      }
      if (args) {
        args.forEach(function(arg) {
          values[arg.name] = getArgumentValue(arg, variables);
        });
      }
      return values;
    }
    function getHandleStorageKey(handleField, variables) {
      var dynamicKey = handleField.dynamicKey, handle = handleField.handle, key = handleField.key, name = handleField.name, args = handleField.args, filters = handleField.filters;
      var handleName = getRelayHandleKey(handle, key, name);
      var filterArgs = null;
      if (args && filters && args.length !== 0 && filters.length !== 0) {
        filterArgs = args.filter(function(arg) {
          return filters.indexOf(arg.name) > -1;
        });
      }
      if (dynamicKey) {
        filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2["default"])(filterArgs)) : [dynamicKey];
      }
      if (filterArgs === null) {
        return handleName;
      } else {
        return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));
      }
    }
    function getStorageKey(field, variables) {
      if (field.storageKey) {
        return field.storageKey;
      }
      var args = getArguments(field);
      var name = field.name;
      return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;
    }
    function getArguments(field) {
      if (field.kind === "RelayResolver" || field.kind === "RelayLiveResolver") {
        var _field$fragment2;
        if (field.args == null) {
          var _field$fragment;
          return (_field$fragment = field.fragment) === null || _field$fragment === void 0 ? void 0 : _field$fragment.args;
        }
        if (((_field$fragment2 = field.fragment) === null || _field$fragment2 === void 0 ? void 0 : _field$fragment2.args) == null) {
          return field.args;
        }
        return field.args.concat(field.fragment.args);
      }
      var args = typeof field.args === "undefined" ? void 0 : field.args;
      return args;
    }
    function getStableStorageKey(name, args) {
      return formatStorageKey(name, stableCopy(args));
    }
    function formatStorageKey(name, argValues) {
      if (!argValues) {
        return name;
      }
      var values = [];
      for (var argName in argValues) {
        if (argValues.hasOwnProperty(argName)) {
          var value = argValues[argName];
          if (value != null) {
            var _JSON$stringify;
            values.push(argName + ":" + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "undefined"));
          }
        }
      }
      return values.length === 0 ? name : name + "(".concat(values.join(","), ")");
    }
    function getStableVariableValue(name, variables) {
      !variables.hasOwnProperty(name) ? true ? invariant(false, "getVariableValue(): Undefined variable `%s`.", name) : invariant(false) : void 0;
      return stableCopy(variables[name]);
    }
    function getModuleComponentKey(documentName) {
      return "".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);
    }
    function getModuleOperationKey(documentName) {
      return "".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);
    }
    var RelayStoreUtils = {
      ACTOR_IDENTIFIER_KEY: "__actorIdentifier",
      CLIENT_EDGE_TRAVERSAL_PATH: "__clientEdgeTraversalPath",
      FRAGMENTS_KEY: "__fragments",
      FRAGMENT_OWNER_KEY: "__fragmentOwner",
      FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: "$isWithinUnmatchedTypeRefinement",
      FRAGMENT_PROP_NAME_KEY: "__fragmentPropName",
      MODULE_COMPONENT_KEY: "__module_component",
      ERRORS_KEY,
      ID_KEY: "__id",
      REF_KEY: "__ref",
      REFS_KEY: "__refs",
      ROOT_ID: "client:root",
      ROOT_TYPE: "__Root",
      TYPENAME_KEY: "__typename",
      INVALIDATED_AT_KEY: "__invalidated_at",
      RELAY_RESOLVER_VALUE_KEY: "__resolverValue",
      RELAY_RESOLVER_INVALIDATION_KEY: "__resolverValueMayBeInvalid",
      RELAY_RESOLVER_SNAPSHOT_KEY: "__resolverSnapshot",
      RELAY_RESOLVER_ERROR_KEY: "__resolverError",
      RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS: "__resolverOutputTypeRecordIDs",
      formatStorageKey,
      getArgumentValue,
      getArgumentValues,
      getHandleStorageKey,
      getStorageKey,
      getStableStorageKey,
      getModuleComponentKey,
      getModuleOperationKey
    };
    module.exports = RelayStoreUtils;
  }
});

// node_modules/relay-runtime/lib/store/RelayConcreteVariables.js
var require_RelayConcreteVariables = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayConcreteVariables.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _require = require_RelayStoreUtils();
    var getArgumentValues = _require.getArgumentValues;
    var invariant = require_browser();
    function getFragmentVariables(fragment, rootVariables, argumentVariables) {
      if (fragment.argumentDefinitions == null) {
        return argumentVariables;
      }
      var variables;
      fragment.argumentDefinitions.forEach(function(definition) {
        if (argumentVariables.hasOwnProperty(definition.name)) {
          return;
        }
        variables = variables || (0, _objectSpread2["default"])({}, argumentVariables);
        switch (definition.kind) {
          case "LocalArgument":
            variables[definition.name] = definition.defaultValue;
            break;
          case "RootArgument":
            if (!rootVariables.hasOwnProperty(definition.name)) {
              variables[definition.name] = void 0;
              break;
            }
            variables[definition.name] = rootVariables[definition.name];
            break;
          default:
            definition;
            true ? true ? invariant(false, "RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.", definition.kind, fragment.name) : invariant(false) : void 0;
        }
      });
      return variables || argumentVariables;
    }
    function getOperationVariables(operation, providedVariables, variables) {
      var operationVariables = {};
      operation.argumentDefinitions.forEach(function(def) {
        var value = def.defaultValue;
        if (variables[def.name] != null) {
          value = variables[def.name];
        }
        operationVariables[def.name] = value;
      });
      if (providedVariables != null) {
        Object.keys(providedVariables).forEach(function(varName) {
          operationVariables[varName] = providedVariables[varName].get();
        });
      }
      return operationVariables;
    }
    function getLocalVariables(currentVariables, argumentDefinitions, args) {
      if (argumentDefinitions == null) {
        return currentVariables;
      }
      var nextVariables = (0, _objectSpread2["default"])({}, currentVariables);
      var nextArgs = args ? getArgumentValues(args, currentVariables) : {};
      argumentDefinitions.forEach(function(def) {
        var _nextArgs$def$name;
        var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;
        nextVariables[def.name] = value;
      });
      return nextVariables;
    }
    module.exports = {
      getLocalVariables,
      getFragmentVariables,
      getOperationVariables
    };
  }
});

// node_modules/fbjs/lib/areEqual.js
var require_areEqual = __commonJS({
  "node_modules/fbjs/lib/areEqual.js"(exports, module) {
    "use strict";
    var aStackPool = [];
    var bStackPool = [];
    function areEqual(a, b) {
      var aStack = aStackPool.length ? aStackPool.pop() : [];
      var bStack = bStackPool.length ? bStackPool.pop() : [];
      var result = eq(a, b, aStack, bStack);
      aStack.length = 0;
      bStack.length = 0;
      aStackPool.push(aStack);
      bStackPool.push(bStack);
      return result;
    }
    function eq(a, b, aStack, bStack) {
      if (a === b) {
        return a !== 0 || 1 / a == 1 / b;
      }
      if (a == null || b == null) {
        return false;
      }
      if (typeof a != "object" || typeof b != "object") {
        return false;
      }
      var objToStr = Object.prototype.toString;
      var className = objToStr.call(a);
      if (className != objToStr.call(b)) {
        return false;
      }
      switch (className) {
        case "[object String]":
          return a == String(b);
        case "[object Number]":
          return isNaN(a) || isNaN(b) ? false : a == Number(b);
        case "[object Date]":
        case "[object Boolean]":
          return +a == +b;
        case "[object RegExp]":
          return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
      }
      var length = aStack.length;
      while (length--) {
        if (aStack[length] == a) {
          return bStack[length] == b;
        }
      }
      aStack.push(a);
      bStack.push(b);
      var size = 0;
      if (className === "[object Array]") {
        size = a.length;
        if (size !== b.length) {
          return false;
        }
        while (size--) {
          if (!eq(a[size], b[size], aStack, bStack)) {
            return false;
          }
        }
      } else {
        if (a.constructor !== b.constructor) {
          return false;
        }
        if (a.hasOwnProperty("valueOf") && b.hasOwnProperty("valueOf")) {
          return a.valueOf() == b.valueOf();
        }
        var keys = Object.keys(a);
        if (keys.length != Object.keys(b).length) {
          return false;
        }
        for (var i = 0; i < keys.length; i++) {
          if (!eq(a[keys[i]], b[keys[i]], aStack, bStack)) {
            return false;
          }
        }
      }
      aStack.pop();
      bStack.pop();
      return true;
    }
    module.exports = areEqual;
  }
});

// node_modules/relay-runtime/lib/store/RelayModernSelector.js
var require_RelayModernSelector = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayModernSelector.js"(exports, module) {
    "use strict";
    var _require = require_RelayConcreteVariables();
    var getFragmentVariables = _require.getFragmentVariables;
    var _require2 = require_RelayStoreUtils();
    var CLIENT_EDGE_TRAVERSAL_PATH = _require2.CLIENT_EDGE_TRAVERSAL_PATH;
    var FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY;
    var FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require2.FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT;
    var FRAGMENTS_KEY = _require2.FRAGMENTS_KEY;
    var ID_KEY = _require2.ID_KEY;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    var warning = require_warning();
    function getSingularSelector(fragment, item) {
      !(typeof item === "object" && item !== null && !Array.isArray(item)) ? true ? invariant(false, "RelayModernSelector: Expected value for fragment `%s` to be an object, got `%s`.", fragment.name, JSON.stringify(item)) : invariant(false) : void 0;
      var dataID = item[ID_KEY];
      var fragments = item[FRAGMENTS_KEY];
      var mixedOwner = item[FRAGMENT_OWNER_KEY];
      var mixedClientEdgeTraversalPath = item[CLIENT_EDGE_TRAVERSAL_PATH];
      if (typeof dataID === "string" && typeof fragments === "object" && fragments !== null && typeof fragments[fragment.name] === "object" && fragments[fragment.name] !== null && typeof mixedOwner === "object" && mixedOwner !== null && (mixedClientEdgeTraversalPath == null || Array.isArray(mixedClientEdgeTraversalPath))) {
        var owner = mixedOwner;
        var clientEdgeTraversalPath = mixedClientEdgeTraversalPath;
        var argumentVariables = fragments[fragment.name];
        var fragmentVariables = getFragmentVariables(fragment, owner.variables, argumentVariables);
        var isWithinUnmatchedTypeRefinement = argumentVariables[FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] === true;
        return createReaderSelector(fragment, dataID, fragmentVariables, owner, isWithinUnmatchedTypeRefinement, clientEdgeTraversalPath);
      }
      if (true) {
        var stringifiedItem = JSON.stringify(item);
        if (stringifiedItem.length > 499) {
          stringifiedItem = stringifiedItem.substr(0, 498) + "â€¦";
        }
        true ? warning(false, "RelayModernSelector: Expected object to contain data for fragment `%s`, got `%s`. Make sure that the parent operation/fragment included fragment `...%s` without `@relay(mask: false)`.", fragment.name, stringifiedItem, fragment.name) : void 0;
      }
      return null;
    }
    function getPluralSelector(fragment, items) {
      var selectors = null;
      items.forEach(function(item, ii) {
        var selector = item != null ? getSingularSelector(fragment, item) : null;
        if (selector != null) {
          selectors = selectors || [];
          selectors.push(selector);
        }
      });
      if (selectors == null) {
        return null;
      } else {
        return {
          kind: "PluralReaderSelector",
          selectors
        };
      }
    }
    function getSelector(fragment, item) {
      if (item == null) {
        return item;
      } else if (fragment.metadata && fragment.metadata.plural === true) {
        !Array.isArray(item) ? true ? invariant(false, "RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.", fragment.name, JSON.stringify(item), fragment.name) : invariant(false) : void 0;
        return getPluralSelector(fragment, item);
      } else {
        !!Array.isArray(item) ? true ? invariant(false, "RelayModernSelector: Expected value for fragment `%s` to be an object, got `%s`. Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.", fragment.name, JSON.stringify(item), fragment.name) : invariant(false) : void 0;
        return getSingularSelector(fragment, item);
      }
    }
    function getSelectorsFromObject(fragments, object) {
      var selectors = {};
      for (var key in fragments) {
        if (fragments.hasOwnProperty(key)) {
          var fragment = fragments[key];
          var item = object[key];
          selectors[key] = getSelector(fragment, item);
        }
      }
      return selectors;
    }
    function getDataIDsFromObject(fragments, object) {
      var ids = {};
      for (var key in fragments) {
        if (fragments.hasOwnProperty(key)) {
          var fragment = fragments[key];
          var item = object[key];
          ids[key] = getDataIDsFromFragment(fragment, item);
        }
      }
      return ids;
    }
    function getDataIDsFromFragment(fragment, item) {
      if (item == null) {
        return item;
      } else if (fragment.metadata && fragment.metadata.plural === true) {
        !Array.isArray(item) ? true ? invariant(false, "RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.", fragment.name, JSON.stringify(item), fragment.name) : invariant(false) : void 0;
        return getDataIDs(fragment, item);
      } else {
        !!Array.isArray(item) ? true ? invariant(false, "RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.", fragment.name, JSON.stringify(item), fragment.name) : invariant(false) : void 0;
        return getDataID(fragment, item);
      }
    }
    function getDataIDs(fragment, items) {
      var ids = null;
      items.forEach(function(item) {
        var id = item != null ? getDataID(fragment, item) : null;
        if (id != null) {
          ids = ids || [];
          ids.push(id);
        }
      });
      return ids;
    }
    function getDataID(fragment, item) {
      !(typeof item === "object" && item !== null && !Array.isArray(item)) ? true ? invariant(false, "RelayModernSelector: Expected value for fragment `%s` to be an object, got `%s`.", fragment.name, JSON.stringify(item)) : invariant(false) : void 0;
      var dataID = item[ID_KEY];
      if (typeof dataID === "string") {
        return dataID;
      }
      true ? warning(false, "RelayModernSelector: Expected object to contain data for fragment `%s`, got `%s`. Make sure that the parent operation/fragment included fragment `...%s` without `@relay(mask: false)`, or `null` is passed as the fragment reference for `%s` if it's conditonally included and the condition isn't met.", fragment.name, JSON.stringify(item), fragment.name, fragment.name) : void 0;
      return null;
    }
    function getVariablesFromObject(fragments, object) {
      var variables = {};
      for (var key in fragments) {
        if (fragments.hasOwnProperty(key)) {
          var fragment = fragments[key];
          var item = object[key];
          var itemVariables = getVariablesFromFragment(fragment, item);
          Object.assign(variables, itemVariables);
        }
      }
      return variables;
    }
    function getVariablesFromFragment(fragment, item) {
      var _fragment$metadata;
      if (item == null) {
        return {};
      } else if (((_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.plural) === true) {
        !Array.isArray(item) ? true ? invariant(false, "RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.", fragment.name, JSON.stringify(item), fragment.name) : invariant(false) : void 0;
        return getVariablesFromPluralFragment(fragment, item);
      } else {
        !!Array.isArray(item) ? true ? invariant(false, "RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.", fragment.name, JSON.stringify(item), fragment.name) : invariant(false) : void 0;
        return getVariablesFromSingularFragment(fragment, item) || {};
      }
    }
    function getVariablesFromSingularFragment(fragment, item) {
      var selector = getSingularSelector(fragment, item);
      if (!selector) {
        return null;
      }
      return selector.variables;
    }
    function getVariablesFromPluralFragment(fragment, items) {
      var variables = {};
      items.forEach(function(value, ii) {
        if (value != null) {
          var itemVariables = getVariablesFromSingularFragment(fragment, value);
          if (itemVariables != null) {
            Object.assign(variables, itemVariables);
          }
        }
      });
      return variables;
    }
    function areEqualSingularSelectors(thisSelector, thatSelector) {
      return thisSelector.dataID === thatSelector.dataID && thisSelector.node === thatSelector.node && areEqual(thisSelector.variables, thatSelector.variables) && areEqualOwners(thisSelector.owner, thatSelector.owner) && thisSelector.isWithinUnmatchedTypeRefinement === thatSelector.isWithinUnmatchedTypeRefinement && areEqualClientEdgeTraversalPaths(thisSelector.clientEdgeTraversalPath, thatSelector.clientEdgeTraversalPath);
    }
    function areEqualOwners(thisOwner, thatOwner) {
      if (thisOwner === thatOwner) {
        return true;
      } else {
        return thisOwner.identifier === thatOwner.identifier && areEqual(thisOwner.cacheConfig, thatOwner.cacheConfig);
      }
    }
    function areEqualClientEdgeTraversalPaths(thisPath, thatPath) {
      if (thisPath === thatPath) {
        return true;
      }
      if (thisPath == null || thatPath == null || thisPath.length !== thatPath.length) {
        return false;
      }
      var idx = thisPath.length;
      while (idx--) {
        var a = thisPath[idx];
        var b = thatPath[idx];
        if (a === b) {
          continue;
        }
        if (a == null || b == null || a.clientEdgeDestinationID !== b.clientEdgeDestinationID || a.readerClientEdge !== b.readerClientEdge) {
          return false;
        }
      }
      return true;
    }
    function areEqualSelectors(a, b) {
      if (a === b) {
        return true;
      } else if (a == null) {
        return b == null;
      } else if (b == null) {
        return a == null;
      } else if (a.kind === "SingularReaderSelector" && b.kind === "SingularReaderSelector") {
        return areEqualSingularSelectors(a, b);
      } else if (a.kind === "PluralReaderSelector" && b.kind === "PluralReaderSelector") {
        return a.selectors.length === b.selectors.length && a.selectors.every(function(s, i) {
          return areEqualSingularSelectors(s, b.selectors[i]);
        });
      } else {
        return false;
      }
    }
    function createReaderSelector(fragment, dataID, variables, request) {
      var isWithinUnmatchedTypeRefinement = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var clientEdgeTraversalPath = arguments.length > 5 ? arguments[5] : void 0;
      return {
        kind: "SingularReaderSelector",
        dataID,
        isWithinUnmatchedTypeRefinement,
        clientEdgeTraversalPath: clientEdgeTraversalPath !== null && clientEdgeTraversalPath !== void 0 ? clientEdgeTraversalPath : null,
        node: fragment,
        variables,
        owner: request
      };
    }
    function createNormalizationSelector(node, dataID, variables) {
      return {
        dataID,
        node,
        variables
      };
    }
    module.exports = {
      areEqualSelectors,
      createReaderSelector,
      createNormalizationSelector,
      getDataIDsFromFragment,
      getDataIDsFromObject,
      getSingularSelector,
      getPluralSelector,
      getSelector,
      getSelectorsFromObject,
      getVariablesFromSingularFragment,
      getVariablesFromPluralFragment,
      getVariablesFromFragment,
      getVariablesFromObject
    };
  }
});

// node_modules/relay-runtime/lib/store/ResolverFragments.js
var require_ResolverFragments = __commonJS({
  "node_modules/relay-runtime/lib/store/ResolverFragments.js"(exports, module) {
    "use strict";
    var _require = require_GraphQLTag();
    var getFragment = _require.getFragment;
    var _require2 = require_RelayModernSelector();
    var getSelector = _require2.getSelector;
    var invariant = require_browser();
    var contextStack = [];
    function withResolverContext(context, cb) {
      contextStack.push(context);
      try {
        return cb();
      } finally {
        contextStack.pop();
      }
    }
    function readFragment(fragmentInput, fragmentKey) {
      if (!contextStack.length) {
        throw new Error("readFragment should be called only from within a Relay Resolver function.");
      }
      var context = contextStack[contextStack.length - 1];
      var fragmentNode = getFragment(fragmentInput);
      var fragmentSelector = getSelector(fragmentNode, fragmentKey);
      !(fragmentSelector != null) ? true ? invariant(false, "Expected a selector for the fragment of the resolver ".concat(fragmentNode.name, ", but got null.")) : invariant(false) : void 0;
      !(fragmentSelector.kind === "SingularReaderSelector") ? true ? invariant(false, "Expected a singular reader selector for the fragment of the resolver ".concat(fragmentNode.name, ", but it was plural.")) : invariant(false) : void 0;
      var _context$getDataForRe = context.getDataForResolverFragment(fragmentSelector, fragmentKey), data = _context$getDataForRe.data, isMissingData = _context$getDataForRe.isMissingData;
      if (isMissingData) {
        throw RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL;
      }
      return data;
    }
    var RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL = {};
    module.exports = {
      readFragment,
      withResolverContext,
      RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL
    };
  }
});

// node_modules/relay-runtime/lib/store/experimental-live-resolvers/resolverDataInjector.js
var require_resolverDataInjector = __commonJS({
  "node_modules/relay-runtime/lib/store/experimental-live-resolvers/resolverDataInjector.js"(exports, module) {
    "use strict";
    var _require = require_ResolverFragments();
    var readFragment = _require.readFragment;
    var invariant = require_browser();
    function resolverDataInjector(fragment, _resolverFn, fieldName, isRequiredField) {
      var resolverFn = _resolverFn;
      return function(fragmentKey, args) {
        var data = readFragment(fragment, fragmentKey);
        if (fieldName != null) {
          if (data == null) {
            if (isRequiredField === true) {
              true ? true ? invariant(false, "Expected required resolver field `%s` in fragment `%s` to be present. But resolvers fragment data is null/undefined.", fieldName, fragment.name) : invariant(false) : void 0;
            } else {
              return resolverFn(null, args);
            }
          }
          if (fieldName in data) {
            if (isRequiredField === true) {
              !(data[fieldName] != null) ? true ? invariant(false, "Expected required resolver field `%s` in fragment `%s` to be non-null.", fieldName, fragment.name) : invariant(false) : void 0;
            }
            return resolverFn(data[fieldName], args);
          } else {
            true ? true ? invariant(false, "Missing field `%s` in fragment `%s` in resolver response.", fieldName, fragment.name) : invariant(false) : void 0;
          }
        } else {
          return resolverFn(data, args);
        }
      };
    }
    module.exports = resolverDataInjector;
  }
});

// node_modules/relay-runtime/lib/experimental.js
var require_experimental = __commonJS({
  "node_modules/relay-runtime/lib/experimental.js"(exports, module) {
    "use strict";
    var resolverDataInjector = require_resolverDataInjector();
    function isValueResult(input) {
      return input.ok === true;
    }
    function isErrorResult(input) {
      return input.ok === false;
    }
    module.exports = {
      resolverDataInjector,
      isValueResult,
      isErrorResult
    };
  }
});

// node_modules/relay-runtime/lib/util/RelayFeatureFlags.js
var require_RelayFeatureFlags = __commonJS({
  "node_modules/relay-runtime/lib/util/RelayFeatureFlags.js"(exports, module) {
    "use strict";
    var RelayFeatureFlags = {
      ENABLE_VARIABLE_CONNECTION_KEY: false,
      ENABLE_RELAY_RESOLVERS: false,
      ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION: false,
      ENABLE_FRIENDLY_QUERY_NAME_GQL_URL: false,
      ENABLE_LOAD_QUERY_REQUEST_DEDUPING: true,
      ENABLE_DO_NOT_WRAP_LIVE_QUERY: false,
      ENABLE_NOTIFY_SUBSCRIPTION: false,
      BATCH_ASYNC_MODULE_UPDATES_FN: null,
      ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT: false,
      MAX_DATA_ID_LENGTH: null,
      STRING_INTERN_LEVEL: 0,
      LOG_MISSING_RECORDS_IN_PROD: false,
      ENABLE_LOOSE_SUBSCRIPTION_ATTRIBUTION: false,
      ENABLE_OPERATION_TRACKER_OPTIMISTIC_UPDATES: false,
      ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE: false,
      ENABLE_FIELD_ERROR_HANDLING_THROW_BY_DEFAULT: false,
      PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION: false,
      MARK_RESOLVER_VALUES_AS_CLEAN_AFTER_FRAGMENT_REREAD: false,
      ENABLE_CYLE_DETECTION_IN_VARIABLES: false,
      ENABLE_USE_FRAGMENT_EXPERIMENTAL: false
    };
    module.exports = RelayFeatureFlags;
  }
});

// node_modules/relay-runtime/lib/util/StringInterner.js
var require_StringInterner = __commonJS({
  "node_modules/relay-runtime/lib/util/StringInterner.js"(exports, module) {
    "use strict";
    var internTable = /* @__PURE__ */ new Map();
    var nextIndex = 1;
    var digits = initDigitTable();
    var INTERN_PREFIX = "	";
    var ESCAPE_PREFIX = "\v";
    function initDigitTable() {
      var digits2 = /* @__PURE__ */ new Set();
      for (var i = 0; i < 10; ++i) {
        digits2.add(i.toString());
      }
      return digits2;
    }
    function escape(str) {
      if (str[0] === INTERN_PREFIX && digits.has(str[1]) || str[0] === ESCAPE_PREFIX) {
        return ESCAPE_PREFIX + str;
      }
      return str;
    }
    function intern(str, limit) {
      if (limit == null || str.length < limit) {
        return escape(str);
      }
      var internedString = internTable.get(str);
      if (internedString != null) {
        return internedString;
      }
      internedString = INTERN_PREFIX + nextIndex++;
      internTable.set(str, internedString);
      return internedString;
    }
    module.exports = {
      intern
    };
  }
});

// node_modules/relay-runtime/lib/store/ClientID.js
var require_ClientID = __commonJS({
  "node_modules/relay-runtime/lib/store/ClientID.js"(exports, module) {
    "use strict";
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var _require = require_StringInterner();
    var intern = _require.intern;
    var PREFIX = "client:";
    function generateClientID(id, storageKey, index) {
      var internedId = RelayFeatureFlags.STRING_INTERN_LEVEL <= 0 ? id : intern(id, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
      var key = internedId + ":" + storageKey;
      if (index != null) {
        key += ":" + index;
      }
      if (key.indexOf(PREFIX) !== 0) {
        key = PREFIX + key;
      }
      return key;
    }
    function isClientID(id) {
      return id.indexOf(PREFIX) === 0;
    }
    var localID = 0;
    function generateUniqueClientID() {
      return "".concat(PREFIX, "local:").concat(localID++);
    }
    function generateClientObjectClientID(typename, localId, index) {
      var key = "".concat(PREFIX).concat(typename, ":").concat(localId);
      if (index != null) {
        key += ":" + index;
      }
      return key;
    }
    module.exports = {
      generateClientID,
      generateClientObjectClientID,
      generateUniqueClientID,
      isClientID
    };
  }
});

// node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js
var require_ConnectionInterface = __commonJS({
  "node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js"(exports, module) {
    "use strict";
    var CONNECTION_CALLS = {
      after: true,
      before: true,
      find: true,
      first: true,
      last: true,
      surrounds: true
    };
    var config = {
      CURSOR: "cursor",
      EDGES: "edges",
      END_CURSOR: "endCursor",
      HAS_NEXT_PAGE: "hasNextPage",
      HAS_PREV_PAGE: "hasPreviousPage",
      NODE: "node",
      PAGE_INFO_TYPE: "PageInfo",
      PAGE_INFO: "pageInfo",
      START_CURSOR: "startCursor"
    };
    var ConnectionInterface = {
      inject: function inject(newConfig) {
        config = newConfig;
      },
      get: function get() {
        return config;
      },
      isConnectionCall: function isConnectionCall(call) {
        return CONNECTION_CALLS.hasOwnProperty(call.name);
      }
    };
    module.exports = ConnectionInterface;
  }
});

// node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js
var require_ConnectionHandler = __commonJS({
  "node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js"(exports, module) {
    "use strict";
    var _require = require_ClientID();
    var generateClientID = _require.generateClientID;
    var _require2 = require_RelayStoreUtils();
    var getStableStorageKey = _require2.getStableStorageKey;
    var getRelayHandleKey = require_getRelayHandleKey();
    var ConnectionInterface = require_ConnectionInterface();
    var invariant = require_browser();
    var warning = require_warning();
    var CONNECTION = "connection";
    var NEXT_EDGE_INDEX = "__connection_next_edge_index";
    function update(store, payload) {
      var record = store.get(payload.dataID);
      if (!record) {
        return;
      }
      var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES, END_CURSOR = _ConnectionInterface$.END_CURSOR, HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE, PAGE_INFO = _ConnectionInterface$.PAGE_INFO, PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE, START_CURSOR = _ConnectionInterface$.START_CURSOR;
      var serverConnection = record.getLinkedRecord(payload.fieldKey);
      var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);
      if (!serverConnection) {
        record.setValue(null, payload.handleKey);
        return;
      }
      var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);
      var clientConnectionField = record.getLinkedRecord(payload.handleKey);
      var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);
      var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);
      if (!clientConnection) {
        var connection = store.create(clientConnectionID, serverConnection.getType());
        connection.setValue(0, NEXT_EDGE_INDEX);
        connection.copyFieldsFrom(serverConnection);
        var serverEdges = serverConnection.getLinkedRecords(EDGES);
        if (serverEdges) {
          serverEdges = serverEdges.map(function(edge) {
            return buildConnectionEdge(store, connection, edge);
          });
          connection.setLinkedRecords(serverEdges, EDGES);
        }
        record.setLinkedRecord(connection, payload.handleKey);
        clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);
        clientPageInfo.setValue(false, HAS_NEXT_PAGE);
        clientPageInfo.setValue(false, HAS_PREV_PAGE);
        clientPageInfo.setValue(null, END_CURSOR);
        clientPageInfo.setValue(null, START_CURSOR);
        if (serverPageInfo) {
          clientPageInfo.copyFieldsFrom(serverPageInfo);
        }
        connection.setLinkedRecord(clientPageInfo, PAGE_INFO);
      } else {
        if (clientConnectionField == null) {
          record.setLinkedRecord(clientConnection, payload.handleKey);
        }
        var _connection = clientConnection;
        var _serverEdges = serverConnection.getLinkedRecords(EDGES);
        if (_serverEdges) {
          _serverEdges = _serverEdges.map(function(edge) {
            return buildConnectionEdge(store, _connection, edge);
          });
        }
        var prevEdges = _connection.getLinkedRecords(EDGES);
        var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);
        _connection.copyFieldsFrom(serverConnection);
        if (prevEdges) {
          _connection.setLinkedRecords(prevEdges, EDGES);
        }
        if (prevPageInfo) {
          _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);
        }
        var nextEdges = [];
        var args = payload.args;
        if (prevEdges && _serverEdges) {
          if (args.after != null) {
            var _clientPageInfo;
            var clientEndCursor = (_clientPageInfo = clientPageInfo) === null || _clientPageInfo === void 0 ? void 0 : _clientPageInfo.getValue(END_CURSOR);
            var serverEndCursor = serverPageInfo === null || serverPageInfo === void 0 ? void 0 : serverPageInfo.getValue(END_CURSOR);
            var isAddingEdgesAfterCurrentPage = clientPageInfo && args.after === clientEndCursor;
            var isFillingOutCurrentPage = clientPageInfo && clientEndCursor === serverEndCursor;
            if (isAddingEdgesAfterCurrentPage || isFillingOutCurrentPage) {
              var nodeIDs = /* @__PURE__ */ new Set();
              mergeEdges(prevEdges, nextEdges, nodeIDs);
              mergeEdges(_serverEdges, nextEdges, nodeIDs);
            } else {
              true ? warning(false, "Relay: Unexpected after cursor `%s`, edges must be fetched from the end of the list (`%s`).", args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;
              return;
            }
          } else if (args.before != null) {
            if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {
              var _nodeIDs = /* @__PURE__ */ new Set();
              mergeEdges(_serverEdges, nextEdges, _nodeIDs);
              mergeEdges(prevEdges, nextEdges, _nodeIDs);
            } else {
              true ? warning(false, "Relay: Unexpected before cursor `%s`, edges must be fetched from the beginning of the list (`%s`).", args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;
              return;
            }
          } else {
            nextEdges = _serverEdges;
          }
        } else if (_serverEdges) {
          nextEdges = _serverEdges;
        } else {
          nextEdges = prevEdges;
        }
        if (nextEdges != null && nextEdges !== prevEdges) {
          _connection.setLinkedRecords(nextEdges, EDGES);
        }
        if (clientPageInfo && serverPageInfo) {
          if (args.after == null && args.before == null) {
            clientPageInfo.copyFieldsFrom(serverPageInfo);
          } else if (args.before != null || args.after == null && args.last) {
            clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);
            var startCursor = serverPageInfo.getValue(START_CURSOR);
            if (typeof startCursor === "string") {
              clientPageInfo.setValue(startCursor, START_CURSOR);
            }
          } else if (args.after != null || args.before == null && args.first) {
            clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);
            var endCursor = serverPageInfo.getValue(END_CURSOR);
            if (typeof endCursor === "string") {
              clientPageInfo.setValue(endCursor, END_CURSOR);
            }
          }
        }
      }
    }
    function getConnection(record, key, filters) {
      var handleKey = getRelayHandleKey(CONNECTION, key, null);
      return record.getLinkedRecord(handleKey, filters);
    }
    function getConnectionID(recordID, key, filters) {
      var handleKey = getRelayHandleKey(CONNECTION, key, null);
      var storageKey = getStableStorageKey(handleKey, filters);
      return generateClientID(recordID, storageKey);
    }
    function insertEdgeAfter(record, newEdge, cursor) {
      var _ConnectionInterface$2 = ConnectionInterface.get(), CURSOR = _ConnectionInterface$2.CURSOR, EDGES = _ConnectionInterface$2.EDGES;
      var edges = record.getLinkedRecords(EDGES);
      if (!edges) {
        record.setLinkedRecords([newEdge], EDGES);
        return;
      }
      var nextEdges;
      if (cursor == null) {
        nextEdges = edges.concat(newEdge);
      } else {
        nextEdges = [];
        var foundCursor = false;
        for (var ii = 0; ii < edges.length; ii++) {
          var edge = edges[ii];
          nextEdges.push(edge);
          if (edge == null) {
            continue;
          }
          var edgeCursor = edge.getValue(CURSOR);
          if (cursor === edgeCursor) {
            nextEdges.push(newEdge);
            foundCursor = true;
          }
        }
        if (!foundCursor) {
          nextEdges.push(newEdge);
        }
      }
      record.setLinkedRecords(nextEdges, EDGES);
    }
    function createEdge(store, record, node, edgeType) {
      var _ConnectionInterface$3 = ConnectionInterface.get(), NODE = _ConnectionInterface$3.NODE;
      var edgeID = generateClientID(record.getDataID(), node.getDataID());
      var edge = store.get(edgeID);
      if (!edge) {
        edge = store.create(edgeID, edgeType);
      }
      edge.setLinkedRecord(node, NODE);
      if (edge.getValue("cursor") == null) {
        edge.setValue(null, "cursor");
      }
      return edge;
    }
    function insertEdgeBefore(record, newEdge, cursor) {
      var _ConnectionInterface$4 = ConnectionInterface.get(), CURSOR = _ConnectionInterface$4.CURSOR, EDGES = _ConnectionInterface$4.EDGES;
      var edges = record.getLinkedRecords(EDGES);
      if (!edges) {
        record.setLinkedRecords([newEdge], EDGES);
        return;
      }
      var nextEdges;
      if (cursor == null) {
        nextEdges = [newEdge].concat(edges);
      } else {
        nextEdges = [];
        var foundCursor = false;
        for (var ii = 0; ii < edges.length; ii++) {
          var edge = edges[ii];
          if (edge != null) {
            var edgeCursor = edge.getValue(CURSOR);
            if (cursor === edgeCursor) {
              nextEdges.push(newEdge);
              foundCursor = true;
            }
          }
          nextEdges.push(edge);
        }
        if (!foundCursor) {
          nextEdges.unshift(newEdge);
        }
      }
      record.setLinkedRecords(nextEdges, EDGES);
    }
    function deleteNode(record, nodeID) {
      var _ConnectionInterface$5 = ConnectionInterface.get(), EDGES = _ConnectionInterface$5.EDGES, NODE = _ConnectionInterface$5.NODE;
      var edges = record.getLinkedRecords(EDGES);
      if (!edges) {
        return;
      }
      var nextEdges;
      for (var ii = 0; ii < edges.length; ii++) {
        var edge = edges[ii];
        var node = edge && edge.getLinkedRecord(NODE);
        if (node != null && node.getDataID() === nodeID) {
          if (nextEdges === void 0) {
            nextEdges = edges.slice(0, ii);
          }
        } else if (nextEdges !== void 0) {
          nextEdges.push(edge);
        }
      }
      if (nextEdges !== void 0) {
        record.setLinkedRecords(nextEdges, EDGES);
      }
    }
    function buildConnectionEdge(store, connection, edge) {
      if (edge == null) {
        return edge;
      }
      var _ConnectionInterface$6 = ConnectionInterface.get(), EDGES = _ConnectionInterface$6.EDGES;
      var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);
      !(typeof edgeIndex === "number") ? true ? invariant(false, "ConnectionHandler: Expected %s to be a number, got `%s`.", NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;
      var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);
      var connectionEdge = store.create(edgeID, edge.getType());
      connectionEdge.copyFieldsFrom(edge);
      if (connectionEdge.getValue("cursor") == null) {
        connectionEdge.setValue(null, "cursor");
      }
      connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);
      return connectionEdge;
    }
    function mergeEdges(sourceEdges, targetEdges, nodeIDs) {
      var _ConnectionInterface$7 = ConnectionInterface.get(), NODE = _ConnectionInterface$7.NODE;
      for (var ii = 0; ii < sourceEdges.length; ii++) {
        var edge = sourceEdges[ii];
        if (!edge) {
          continue;
        }
        var node = edge.getLinkedRecord(NODE);
        var nodeID = node && node.getDataID();
        if (nodeID) {
          if (nodeIDs.has(nodeID)) {
            continue;
          }
          nodeIDs.add(nodeID);
        }
        targetEdges.push(edge);
      }
    }
    module.exports = {
      buildConnectionEdge,
      createEdge,
      deleteNode,
      getConnection,
      getConnectionID,
      insertEdgeAfter,
      insertEdgeBefore,
      update
    };
  }
});

// node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js
var require_createForOfIteratorHelper = __commonJS({
  "node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js"(exports, module) {
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return {
            s: F,
            n: function n() {
              return _n >= r.length ? {
                done: true
              } : {
                done: false,
                value: r[_n++]
              };
            },
            e: function e2(r2) {
              throw r2;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return {
        s: function s() {
          t = t.call(r);
        },
        n: function n() {
          var r2 = t.next();
          return a = r2.done, r2;
        },
        e: function e2(r2) {
          u = true, o = r2;
        },
        f: function f() {
          try {
            a || null == t["return"] || t["return"]();
          } finally {
            if (u) throw o;
          }
        }
      };
    }
    module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js
var require_MutationHandlers = __commonJS({
  "node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var ConnectionHandler = require_ConnectionHandler();
    var ConnectionInterface = require_ConnectionInterface();
    var invariant = require_browser();
    var warning = require_warning();
    var DeleteRecordHandler = {
      update: function update(store, payload) {
        var record = store.get(payload.dataID);
        if (record != null) {
          var idOrIds = record.getValue(payload.fieldKey);
          if (typeof idOrIds === "string") {
            store["delete"](idOrIds);
          } else if (Array.isArray(idOrIds)) {
            idOrIds.forEach(function(id) {
              if (typeof id === "string") {
                store["delete"](id);
              }
            });
          }
        }
      }
    };
    var DeleteEdgeHandler = {
      update: function update(store, payload) {
        var record = store.get(payload.dataID);
        if (record == null) {
          return;
        }
        var connections = payload.handleArgs.connections;
        !(connections != null) ? true ? invariant(false, "MutationHandlers: Expected connection IDs to be specified.") : invariant(false) : void 0;
        var idOrIds = record.getValue(payload.fieldKey);
        var idList = Array.isArray(idOrIds) ? idOrIds : [idOrIds];
        idList.forEach(function(id) {
          if (typeof id === "string") {
            var _iterator = (0, _createForOfIteratorHelper2["default"])(connections), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var connectionID = _step.value;
                var connection = store.get(connectionID);
                if (connection == null) {
                  true ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : void 0;
                  continue;
                }
                ConnectionHandler.deleteNode(connection, id);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        });
      }
    };
    var AppendEdgeHandler = {
      update: edgeUpdater(ConnectionHandler.insertEdgeAfter)
    };
    var PrependEdgeHandler = {
      update: edgeUpdater(ConnectionHandler.insertEdgeBefore)
    };
    var AppendNodeHandler = {
      update: nodeUpdater(ConnectionHandler.insertEdgeAfter)
    };
    var PrependNodeHandler = {
      update: nodeUpdater(ConnectionHandler.insertEdgeBefore)
    };
    function edgeUpdater(insertFn) {
      return function(store, payload) {
        var _serverEdges;
        var record = store.get(payload.dataID);
        if (record == null) {
          return;
        }
        var connections = payload.handleArgs.connections;
        !(connections != null) ? true ? invariant(false, "MutationHandlers: Expected connection IDs to be specified.") : invariant(false) : void 0;
        var singleServerEdge, serverEdges;
        try {
          singleServerEdge = record.getLinkedRecord(payload.fieldKey);
        } catch (_unused) {
        }
        if (!singleServerEdge) {
          try {
            serverEdges = record.getLinkedRecords(payload.fieldKey);
          } catch (_unused2) {
          }
        }
        if (singleServerEdge == null && serverEdges == null) {
          true ? warning(false, "MutationHandlers: Expected the server edge to be non-null.") : void 0;
          return;
        }
        var _ConnectionInterface$ = ConnectionInterface.get(), NODE = _ConnectionInterface$.NODE, EDGES = _ConnectionInterface$.EDGES;
        var serverEdgeList = (_serverEdges = serverEdges) !== null && _serverEdges !== void 0 ? _serverEdges : [singleServerEdge];
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(serverEdgeList), _step2;
        try {
          var _loop = function _loop2() {
            var serverEdge = _step2.value;
            if (serverEdge == null) {
              return "continue";
            }
            var serverNode = serverEdge.getLinkedRecord("node");
            if (!serverNode) {
              return "continue";
            }
            var serverNodeId = serverNode.getDataID();
            var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connections), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var connectionID = _step3.value;
                var connection = store.get(connectionID);
                if (connection == null) {
                  true ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : void 0;
                  continue;
                }
                var nodeAlreadyExistsInConnection = (_connection$getLinked = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked === void 0 ? void 0 : _connection$getLinked.some(function(edge) {
                  var _edge$getLinkedRecord;
                  return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord === void 0 ? void 0 : _edge$getLinkedRecord.getDataID()) === serverNodeId;
                });
                if (nodeAlreadyExistsInConnection) {
                  continue;
                }
                var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
                !(clientEdge != null) ? true ? invariant(false, "MutationHandlers: Failed to build the edge.") : invariant(false) : void 0;
                insertFn(connection, clientEdge);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          };
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _connection$getLinked;
            var _ret = _loop();
            if (_ret === "continue") continue;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      };
    }
    function nodeUpdater(insertFn) {
      return function(store, payload) {
        var _serverNodes;
        var record = store.get(payload.dataID);
        if (record == null) {
          return;
        }
        var _payload$handleArgs = payload.handleArgs, connections = _payload$handleArgs.connections, edgeTypeName = _payload$handleArgs.edgeTypeName;
        !(connections != null) ? true ? invariant(false, "MutationHandlers: Expected connection IDs to be specified.") : invariant(false) : void 0;
        !(edgeTypeName != null) ? true ? invariant(false, "MutationHandlers: Expected edge typename to be specified.") : invariant(false) : void 0;
        var singleServerNode;
        var serverNodes;
        try {
          singleServerNode = record.getLinkedRecord(payload.fieldKey);
        } catch (_unused3) {
        }
        if (!singleServerNode) {
          try {
            serverNodes = record.getLinkedRecords(payload.fieldKey);
          } catch (_unused4) {
          }
        }
        if (singleServerNode == null && serverNodes == null) {
          true ? warning(false, "MutationHandlers: Expected target node to exist.") : void 0;
          return;
        }
        var _ConnectionInterface$2 = ConnectionInterface.get(), NODE = _ConnectionInterface$2.NODE, EDGES = _ConnectionInterface$2.EDGES;
        var serverNodeList = (_serverNodes = serverNodes) !== null && _serverNodes !== void 0 ? _serverNodes : [singleServerNode];
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(serverNodeList), _step4;
        try {
          var _loop2 = function _loop22() {
            var serverNode = _step4.value;
            if (serverNode == null) {
              return "continue";
            }
            var serverNodeId = serverNode.getDataID();
            var _iterator5 = (0, _createForOfIteratorHelper2["default"])(connections), _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var connectionID = _step5.value;
                var connection = store.get(connectionID);
                if (connection == null) {
                  true ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : void 0;
                  continue;
                }
                var nodeAlreadyExistsInConnection = (_connection$getLinked2 = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked2 === void 0 ? void 0 : _connection$getLinked2.some(function(edge) {
                  var _edge$getLinkedRecord2;
                  return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord2 = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord2 === void 0 ? void 0 : _edge$getLinkedRecord2.getDataID()) === serverNodeId;
                });
                if (nodeAlreadyExistsInConnection) {
                  continue;
                }
                var clientEdge = ConnectionHandler.createEdge(store, connection, serverNode, edgeTypeName);
                !(clientEdge != null) ? true ? invariant(false, "MutationHandlers: Failed to build the edge.") : invariant(false) : void 0;
                insertFn(connection, clientEdge);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          };
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _connection$getLinked2;
            var _ret2 = _loop2();
            if (_ret2 === "continue") continue;
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      };
    }
    module.exports = {
      AppendEdgeHandler,
      DeleteRecordHandler,
      PrependEdgeHandler,
      AppendNodeHandler,
      PrependNodeHandler,
      DeleteEdgeHandler
    };
  }
});

// node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js
var require_RelayDefaultHandlerProvider = __commonJS({
  "node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js"(exports, module) {
    "use strict";
    var ConnectionHandler = require_ConnectionHandler();
    var MutationHandlers = require_MutationHandlers();
    var invariant = require_browser();
    function RelayDefaultHandlerProvider(handle) {
      switch (handle) {
        case "connection":
          return ConnectionHandler;
        case "deleteRecord":
          return MutationHandlers.DeleteRecordHandler;
        case "deleteEdge":
          return MutationHandlers.DeleteEdgeHandler;
        case "appendEdge":
          return MutationHandlers.AppendEdgeHandler;
        case "prependEdge":
          return MutationHandlers.PrependEdgeHandler;
        case "appendNode":
          return MutationHandlers.AppendNodeHandler;
        case "prependNode":
          return MutationHandlers.PrependNodeHandler;
      }
      true ? true ? invariant(false, "RelayDefaultHandlerProvider: No handler provided for `%s`.", handle) : invariant(false) : void 0;
    }
    module.exports = RelayDefaultHandlerProvider;
  }
});

// node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js
var require_isRelayModernEnvironment = __commonJS({
  "node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js"(exports, module) {
    "use strict";
    function isRelayModernEnvironment(environment) {
      return Boolean(environment && environment["@@RelayModernEnvironment"]);
    }
    module.exports = isRelayModernEnvironment;
  }
});

// node_modules/relay-runtime/lib/util/deepFreeze.js
var require_deepFreeze = __commonJS({
  "node_modules/relay-runtime/lib/util/deepFreeze.js"(exports, module) {
    "use strict";
    function deepFreeze(object) {
      if (!shouldBeFrozen(object)) {
        return object;
      }
      Object.freeze(object);
      Object.getOwnPropertyNames(object).forEach(function(name) {
        var property = object[name];
        if (property && typeof property === "object" && !Object.isFrozen(property)) {
          deepFreeze(property);
        }
      });
      return object;
    }
    function shouldBeFrozen(value) {
      return value != null && (Array.isArray(value) || typeof value === "object" && value.constructor === Object);
    }
    module.exports = deepFreeze;
  }
});

// node_modules/relay-runtime/lib/util/getRequestIdentifier.js
var require_getRequestIdentifier = __commonJS({
  "node_modules/relay-runtime/lib/util/getRequestIdentifier.js"(exports, module) {
    "use strict";
    var _require = require_stableCopy();
    var stableCopy = _require.stableCopy;
    var invariant = require_browser();
    function getRequestIdentifier(parameters, variables) {
      var requestID = parameters.cacheID != null ? parameters.cacheID : parameters.id;
      !(requestID != null) ? true ? invariant(false, "getRequestIdentifier: Expected request `%s` to have either a valid `id` or `cacheID` property", parameters.name) : invariant(false) : void 0;
      return requestID + JSON.stringify(stableCopy(variables));
    }
    module.exports = getRequestIdentifier;
  }
});

// node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js
var require_RelayModernOperationDescriptor = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js"(exports, module) {
    "use strict";
    var deepFreeze = require_deepFreeze();
    var getRequestIdentifier = require_getRequestIdentifier();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var _require = require_stableCopy();
    var hasCycle = _require.hasCycle;
    var _require2 = require_RelayConcreteVariables();
    var getOperationVariables = _require2.getOperationVariables;
    var _require3 = require_RelayModernSelector();
    var createNormalizationSelector = _require3.createNormalizationSelector;
    var createReaderSelector = _require3.createReaderSelector;
    var _require4 = require_RelayStoreUtils();
    var ROOT_ID = _require4.ROOT_ID;
    var invariant = require_browser();
    function createOperationDescriptor(request, variables, cacheConfig) {
      var dataID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ROOT_ID;
      var operation = request.operation;
      var operationVariables = getOperationVariables(operation, request.params.providedVariables, variables);
      if (RelayFeatureFlags.ENABLE_CYLE_DETECTION_IN_VARIABLES) {
        !!hasCycle(operationVariables) ? true ? invariant(false, "Cycle detected in variables passed to operation `%s`.", request.operation.name) : invariant(false) : void 0;
      }
      var requestDescriptor = createRequestDescriptor(request, operationVariables, cacheConfig);
      var operationDescriptor = {
        fragment: createReaderSelector(request.fragment, dataID, operationVariables, requestDescriptor),
        request: requestDescriptor,
        root: createNormalizationSelector(operation, dataID, operationVariables)
      };
      if (true) {
        Object.freeze(operationDescriptor.fragment);
        Object.freeze(operationDescriptor.root);
        Object.freeze(operationDescriptor);
      }
      return operationDescriptor;
    }
    function createRequestDescriptor(request, variables, cacheConfig) {
      var requestDescriptor = {
        identifier: getRequestIdentifier(request.params, variables),
        node: request,
        variables,
        cacheConfig
      };
      if (true) {
        deepFreeze(variables);
        Object.freeze(request);
        Object.freeze(requestDescriptor);
      }
      return requestDescriptor;
    }
    module.exports = {
      createOperationDescriptor,
      createRequestDescriptor
    };
  }
});

// node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js
var require_RelayDeclarativeMutationConfig = __commonJS({
  "node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var ConnectionHandler = require_ConnectionHandler();
    var warning = require_warning();
    var MutationTypes = Object.freeze({
      RANGE_ADD: "RANGE_ADD",
      RANGE_DELETE: "RANGE_DELETE",
      NODE_DELETE: "NODE_DELETE"
    });
    var RangeOperations = Object.freeze({
      APPEND: "append",
      PREPEND: "prepend"
    });
    function convert(configs, request, optimisticUpdater, updater) {
      var configOptimisticUpdates = optimisticUpdater ? [optimisticUpdater] : [];
      var configUpdates = updater ? [updater] : [];
      configs.forEach(function(config) {
        switch (config.type) {
          case "NODE_DELETE":
            var nodeDeleteResult = nodeDelete(config, request);
            if (nodeDeleteResult) {
              configOptimisticUpdates.push(nodeDeleteResult);
              configUpdates.push(nodeDeleteResult);
            }
            break;
          case "RANGE_ADD":
            var rangeAddResult = rangeAdd(config, request);
            if (rangeAddResult) {
              configOptimisticUpdates.push(rangeAddResult);
              configUpdates.push(rangeAddResult);
            }
            break;
          case "RANGE_DELETE":
            var rangeDeleteResult = rangeDelete(config, request);
            if (rangeDeleteResult) {
              configOptimisticUpdates.push(rangeDeleteResult);
              configUpdates.push(rangeDeleteResult);
            }
            break;
        }
      });
      return {
        optimisticUpdater: function optimisticUpdater2(store, data) {
          configOptimisticUpdates.forEach(function(eachOptimisticUpdater) {
            eachOptimisticUpdater(store, data);
          });
        },
        updater: function updater2(store, data) {
          configUpdates.forEach(function(eachUpdater) {
            eachUpdater(store, data);
          });
        }
      };
    }
    function nodeDelete(config, request) {
      var deletedIDFieldName = config.deletedIDFieldName;
      var rootField = getRootField(request);
      if (!rootField) {
        return null;
      }
      return function(store, data) {
        var payload = store.getRootField(rootField);
        if (!payload) {
          return;
        }
        var deleteID = payload.getValue(deletedIDFieldName);
        var deleteIDs = Array.isArray(deleteID) ? deleteID : [deleteID];
        deleteIDs.forEach(function(id) {
          if (id && typeof id === "string") {
            store["delete"](id);
          }
        });
      };
    }
    function rangeAdd(config, request) {
      var parentID = config.parentID, connectionInfo = config.connectionInfo, edgeName = config.edgeName;
      if (!parentID) {
        true ? warning(false, "RelayDeclarativeMutationConfig: For mutation config RANGE_ADD to work you must include a parentID") : void 0;
        return null;
      }
      var rootField = getRootField(request);
      if (!connectionInfo || !rootField) {
        return null;
      }
      return function(store, data) {
        var parent = store.get(parentID);
        if (!parent) {
          return;
        }
        var payload = store.getRootField(rootField);
        if (!payload) {
          return;
        }
        var serverEdge = payload.getLinkedRecord(edgeName);
        var _iterator = (0, _createForOfIteratorHelper2["default"])(connectionInfo), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var info = _step.value;
            if (!serverEdge) {
              continue;
            }
            var connection = ConnectionHandler.getConnection(parent, info.key, info.filters);
            if (!connection) {
              continue;
            }
            var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
            if (!clientEdge) {
              continue;
            }
            switch (info.rangeBehavior) {
              case "append":
                ConnectionHandler.insertEdgeAfter(connection, clientEdge);
                break;
              case "prepend":
                ConnectionHandler.insertEdgeBefore(connection, clientEdge);
                break;
              default:
                true ? warning(false, "RelayDeclarativeMutationConfig: RANGE_ADD range behavior `%s` will not work as expected in RelayModern, supported range behaviors are 'append', 'prepend'.", info.rangeBehavior) : void 0;
                break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };
    }
    function rangeDelete(config, request) {
      var parentID = config.parentID, connectionKeys = config.connectionKeys, pathToConnection = config.pathToConnection, deletedIDFieldName = config.deletedIDFieldName;
      if (!parentID) {
        true ? warning(false, "RelayDeclarativeMutationConfig: For mutation config RANGE_DELETE to work you must include a parentID") : void 0;
        return null;
      }
      var rootField = getRootField(request);
      if (!rootField) {
        return null;
      }
      return function(store, data) {
        if (!data) {
          return;
        }
        var deleteIDs = [];
        var deletedIDField = data[rootField];
        if (deletedIDField && Array.isArray(deletedIDFieldName)) {
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(deletedIDFieldName), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var eachField = _step2.value;
              if (deletedIDField && typeof deletedIDField === "object") {
                deletedIDField = deletedIDField[eachField];
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (Array.isArray(deletedIDField)) {
            deletedIDField.forEach(function(idObject) {
              if (idObject && idObject.id && typeof idObject === "object" && typeof idObject.id === "string") {
                deleteIDs.push(idObject.id);
              }
            });
          } else if (deletedIDField && deletedIDField.id && typeof deletedIDField.id === "string") {
            deleteIDs.push(deletedIDField.id);
          }
        } else if (deletedIDField && typeof deletedIDFieldName === "string" && typeof deletedIDField === "object") {
          deletedIDField = deletedIDField[deletedIDFieldName];
          if (typeof deletedIDField === "string") {
            deleteIDs.push(deletedIDField);
          } else if (Array.isArray(deletedIDField)) {
            deletedIDField.forEach(function(id) {
              if (typeof id === "string") {
                deleteIDs.push(id);
              }
            });
          }
        }
        deleteNode(parentID, connectionKeys, pathToConnection, store, deleteIDs);
      };
    }
    function deleteNode(parentID, connectionKeys, pathToConnection, store, deleteIDs) {
      true ? warning(connectionKeys != null, "RelayDeclarativeMutationConfig: RANGE_DELETE must provide a connectionKeys") : void 0;
      var parent = store.get(parentID);
      if (!parent) {
        return;
      }
      if (pathToConnection.length < 2) {
        true ? warning(false, "RelayDeclarativeMutationConfig: RANGE_DELETE pathToConnection must include at least parent and connection") : void 0;
        return;
      }
      var recordProxy = parent;
      for (var i = 1; i < pathToConnection.length - 1; i++) {
        if (recordProxy) {
          recordProxy = recordProxy.getLinkedRecord(pathToConnection[i]);
        }
      }
      if (!connectionKeys || !recordProxy) {
        true ? warning(false, "RelayDeclarativeMutationConfig: RANGE_DELETE pathToConnection is incorrect. Unable to find connection with parentID: %s and path: %s", parentID, pathToConnection.toString()) : void 0;
        return;
      }
      var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connectionKeys), _step3;
      try {
        var _loop = function _loop2() {
          var key = _step3.value;
          var connection = ConnectionHandler.getConnection(recordProxy, key.key, key.filters);
          if (connection) {
            deleteIDs.forEach(function(deleteID) {
              ConnectionHandler.deleteNode(connection, deleteID);
            });
          }
        };
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          _loop();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    function getRootField(request) {
      if (request.fragment.selections && request.fragment.selections.length > 0 && request.fragment.selections[0].kind === "LinkedField") {
        return request.fragment.selections[0].name;
      }
      return null;
    }
    module.exports = {
      MutationTypes,
      RangeOperations,
      convert
    };
  }
});

// node_modules/relay-runtime/lib/mutations/applyOptimisticMutation.js
var require_applyOptimisticMutation = __commonJS({
  "node_modules/relay-runtime/lib/mutations/applyOptimisticMutation.js"(exports, module) {
    "use strict";
    var _require = require_GraphQLTag();
    var getRequest = _require.getRequest;
    var isRelayModernEnvironment = require_isRelayModernEnvironment();
    var _require2 = require_RelayModernOperationDescriptor();
    var createOperationDescriptor = _require2.createOperationDescriptor;
    var RelayDeclarativeMutationConfig = require_RelayDeclarativeMutationConfig();
    var invariant = require_browser();
    function applyOptimisticMutation(environment, config) {
      !isRelayModernEnvironment(environment) ? true ? invariant(false, "commitMutation: expected `environment` to be an instance of `RelayModernEnvironment`.") : invariant(false) : void 0;
      var mutation = getRequest(config.mutation);
      if (mutation.params.operationKind !== "mutation") {
        throw new Error("commitMutation: Expected mutation operation");
      }
      var optimisticUpdater = config.optimisticUpdater;
      var configs = config.configs, optimisticResponse = config.optimisticResponse, variables = config.variables;
      var operation = createOperationDescriptor(mutation, variables);
      if (configs) {
        var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater);
        optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
      }
      return environment.applyMutation({
        operation,
        response: optimisticResponse,
        updater: optimisticUpdater
      });
    }
    module.exports = applyOptimisticMutation;
  }
});

// node_modules/relay-runtime/lib/mutations/commitLocalUpdate.js
var require_commitLocalUpdate = __commonJS({
  "node_modules/relay-runtime/lib/mutations/commitLocalUpdate.js"(exports, module) {
    "use strict";
    function commitLocalUpdate(environment, updater) {
      environment.commitUpdate(updater);
    }
    module.exports = commitLocalUpdate;
  }
});

// node_modules/relay-runtime/lib/mutations/validateMutation.js
var require_validateMutation = __commonJS({
  "node_modules/relay-runtime/lib/mutations/validateMutation.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var warning = require_warning();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var validateMutation = function validateMutation2() {
    };
    if (true) {
      addFieldToDiff = function addFieldToDiff2(path, diff, isScalar) {
        var deepLoc = diff;
        path.split(".").forEach(function(key, index, arr) {
          if (deepLoc[key] == null) {
            deepLoc[key] = {};
          }
          if (isScalar && index === arr.length - 1) {
            deepLoc[key] = "<scalar>";
          }
          deepLoc = deepLoc[key];
        });
      };
      validateMutation = function validateMutation2(optimisticResponse, mutation, variables) {
        var operationName = mutation.operation.name;
        var context = {
          path: "ROOT",
          visitedPaths: /* @__PURE__ */ new Set(),
          variables: variables || {},
          missingDiff: {},
          extraDiff: {},
          moduleImportPaths: /* @__PURE__ */ new Set()
        };
        validateSelections(optimisticResponse, mutation.operation.selections, context);
        validateOptimisticResponse(optimisticResponse, context);
        true ? warning(context.missingDiff.ROOT == null, "Expected `optimisticResponse` to match structure of server response for mutation `%s`, please define fields for all of\n%s", operationName, JSON.stringify(context.missingDiff.ROOT, null, 2)) : void 0;
        true ? warning(context.extraDiff.ROOT == null, "Expected `optimisticResponse` to match structure of server response for mutation `%s`, please remove all fields of\n%s", operationName, JSON.stringify(context.extraDiff.ROOT, null, 2)) : void 0;
      };
      validateSelections = function validateSelections2(optimisticResponse, selections, context) {
        selections.forEach(function(selection) {
          return validateSelection(optimisticResponse, selection, context);
        });
      };
      validateSelection = function validateSelection2(optimisticResponse, selection, context) {
        switch (selection.kind) {
          case "Condition":
            validateSelections(optimisticResponse, selection.selections, context);
            return;
          case "ClientComponent":
          case "FragmentSpread":
            validateSelections(optimisticResponse, selection.fragment.selections, context);
            return;
          case "ScalarField":
          case "LinkedField":
            return validateField(optimisticResponse, selection, context);
          case "ActorChange":
            return validateField(optimisticResponse, selection.linkedField, context);
          case "InlineFragment":
            var type = selection.type;
            var isConcreteType = selection.abstractKey == null;
            validateAbstractKey(context, selection.abstractKey);
            selection.selections.forEach(function(subselection) {
              if (isConcreteType && optimisticResponse.__typename !== type) {
                return;
              }
              validateSelection2(optimisticResponse, subselection, context);
            });
            return;
          case "ClientExtension":
            selection.selections.forEach(function(subselection) {
              validateSelection2(optimisticResponse, subselection, context);
            });
            return;
          case "ModuleImport":
            return validateModuleImport(context);
          case "TypeDiscriminator":
            return validateAbstractKey(context, selection.abstractKey);
          case "RelayResolver":
          case "RelayLiveResolver":
          case "ClientEdgeToClientObject":
          case "LinkedHandle":
          case "ScalarHandle":
          case "Defer":
          case "Stream": {
            return;
          }
          default:
            selection;
            return;
        }
      };
      validateModuleImport = function validateModuleImport2(context) {
        context.moduleImportPaths.add(context.path);
      };
      validateAbstractKey = function validateAbstractKey2(context, abstractKey) {
        if (abstractKey != null) {
          var path = "".concat(context.path, ".").concat(abstractKey);
          context.visitedPaths.add(path);
        }
      };
      validateField = function validateField2(optimisticResponse, field, context) {
        var fieldName = field.alias || field.name;
        var path = "".concat(context.path, ".").concat(fieldName);
        context.visitedPaths.add(path);
        switch (field.kind) {
          case "ScalarField":
            if (hasOwnProperty.call(optimisticResponse, fieldName) === false) {
              addFieldToDiff(path, context.missingDiff, true);
            }
            return;
          case "LinkedField":
            var selections = field.selections;
            if (optimisticResponse[fieldName] === null || hasOwnProperty.call(optimisticResponse, fieldName) && optimisticResponse[fieldName] === void 0) {
              return;
            }
            if (field.plural) {
              if (Array.isArray(optimisticResponse[fieldName])) {
                optimisticResponse[fieldName].forEach(function(r) {
                  if (r !== null) {
                    validateSelections(r, selections, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                      path
                    }));
                  }
                });
                return;
              } else {
                addFieldToDiff(path, context.missingDiff);
                return;
              }
            } else {
              if (optimisticResponse[fieldName] instanceof Object) {
                validateSelections(optimisticResponse[fieldName], selections, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                  path
                }));
                return;
              } else {
                addFieldToDiff(path, context.missingDiff);
                return;
              }
            }
        }
      };
      validateOptimisticResponse = function validateOptimisticResponse2(optimisticResponse, context) {
        if (Array.isArray(optimisticResponse)) {
          optimisticResponse.forEach(function(r) {
            if (r instanceof Object) {
              validateOptimisticResponse2(r, context);
            }
          });
          return;
        }
        Object.keys(optimisticResponse).forEach(function(key) {
          var value = optimisticResponse[key];
          var path = "".concat(context.path, ".").concat(key);
          if (context.moduleImportPaths.has(path)) {
            return;
          }
          if (!context.visitedPaths.has(path)) {
            addFieldToDiff(path, context.extraDiff);
            return;
          }
          if (value instanceof Object) {
            validateOptimisticResponse2(value, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
              path
            }));
          }
        });
      };
    }
    var addFieldToDiff;
    var validateSelections;
    var validateSelection;
    var validateModuleImport;
    var validateAbstractKey;
    var validateField;
    var validateOptimisticResponse;
    module.exports = validateMutation;
  }
});

// node_modules/relay-runtime/lib/mutations/commitMutation.js
var require_commitMutation = __commonJS({
  "node_modules/relay-runtime/lib/mutations/commitMutation.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _require = require_GraphQLTag();
    var getRequest = _require.getRequest;
    var _require2 = require_ClientID();
    var generateUniqueClientID = _require2.generateUniqueClientID;
    var isRelayModernEnvironment = require_isRelayModernEnvironment();
    var _require3 = require_RelayModernOperationDescriptor();
    var createOperationDescriptor = _require3.createOperationDescriptor;
    var RelayDeclarativeMutationConfig = require_RelayDeclarativeMutationConfig();
    var validateMutation = require_validateMutation();
    var invariant = require_browser();
    var warning = require_warning();
    function commitMutation(environment, config) {
      !isRelayModernEnvironment(environment) ? true ? invariant(false, "commitMutation: expected `environment` to be an instance of `RelayModernEnvironment`.") : invariant(false) : void 0;
      var mutation = getRequest(config.mutation);
      if (mutation.params.operationKind !== "mutation") {
        throw new Error("commitMutation: Expected mutation operation");
      }
      if (mutation.kind !== "Request") {
        throw new Error("commitMutation: Expected mutation to be of type request");
      }
      var optimisticResponse = config.optimisticResponse, optimisticUpdater = config.optimisticUpdater, updater = config.updater;
      var configs = config.configs, cacheConfig = config.cacheConfig, onError = config.onError, onUnsubscribe = config.onUnsubscribe, variables = config.variables, uploadables = config.uploadables;
      var operation = createOperationDescriptor(mutation, variables, cacheConfig, generateUniqueClientID());
      if (typeof optimisticResponse === "function") {
        optimisticResponse = optimisticResponse();
        true ? warning(false, "commitMutation: Expected `optimisticResponse` to be an object, received a function.") : void 0;
      }
      if (true) {
        if (optimisticResponse instanceof Object) {
          validateMutation(optimisticResponse, mutation, variables);
        }
      }
      if (configs) {
        var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater, updater);
        optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
        updater = _RelayDeclarativeMuta.updater;
      }
      var errors = [];
      var subscription = environment.executeMutation({
        operation,
        optimisticResponse,
        optimisticUpdater,
        updater,
        uploadables
      }).subscribe({
        next: function next(payload) {
          var _config$onNext;
          if (Array.isArray(payload)) {
            payload.forEach(function(item) {
              if (item.errors) {
                errors.push.apply(errors, (0, _toConsumableArray2["default"])(item.errors));
              }
            });
          } else {
            if (payload.errors) {
              errors.push.apply(errors, (0, _toConsumableArray2["default"])(payload.errors));
            }
          }
          (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);
        },
        complete: function complete() {
          var onCompleted = config.onCompleted;
          if (onCompleted) {
            var snapshot = environment.lookup(operation.fragment);
            onCompleted(snapshot.data, errors.length !== 0 ? errors : null);
          }
        },
        error: onError,
        unsubscribe: onUnsubscribe
      });
      return {
        dispose: subscription.unsubscribe
      };
    }
    module.exports = commitMutation;
  }
});

// node_modules/relay-runtime/lib/util/withProvidedVariables.js
var require_withProvidedVariables = __commonJS({
  "node_modules/relay-runtime/lib/util/withProvidedVariables.js"(exports, module) {
    "use strict";
    var areEqual = require_areEqual();
    var warning = require_warning();
    var WEAKMAP_SUPPORTED = typeof WeakMap === "function";
    var debugCache = WEAKMAP_SUPPORTED ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map();
    function withProvidedVariables(userSuppliedVariables, providedVariables) {
      if (providedVariables != null) {
        var operationVariables = {};
        Object.assign(operationVariables, userSuppliedVariables);
        Object.keys(providedVariables).forEach(function(varName) {
          var providerFunction = providedVariables[varName].get;
          var providerResult = providerFunction();
          if (!debugCache.has(providerFunction)) {
            debugCache.set(providerFunction, providerResult);
            operationVariables[varName] = providerResult;
          } else {
            var cachedResult = debugCache.get(providerFunction);
            if (true) {
              true ? warning(areEqual(providerResult, cachedResult), "Relay: Expected function `%s` for provider `%s` to be a pure function, but got conflicting return values `%s` and `%s`", providerFunction.name, varName, providerResult, cachedResult) : void 0;
            }
            operationVariables[varName] = cachedResult;
          }
        });
        return operationVariables;
      } else {
        return userSuppliedVariables;
      }
    }
    withProvidedVariables.tests_only_resetDebugCache = true ? function() {
      debugCache = WEAKMAP_SUPPORTED ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map();
    } : void 0;
    module.exports = withProvidedVariables;
  }
});

// node_modules/relay-runtime/lib/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/relay-runtime/lib/util/isPromise.js"(exports, module) {
    "use strict";
    function isPromise(p) {
      return p != null && typeof p === "object" && typeof p.then === "function";
    }
    module.exports = isPromise;
  }
});

// node_modules/relay-runtime/lib/network/RelayObservable.js
var require_RelayObservable = __commonJS({
  "node_modules/relay-runtime/lib/network/RelayObservable.js"(exports, module) {
    "use strict";
    var isPromise = require_isPromise();
    var hostReportError = swallowError;
    var RelayObservable = function() {
      RelayObservable2.create = function create(source) {
        return new RelayObservable2(source);
      };
      function RelayObservable2(source) {
        if (true) {
          if (!source || typeof source !== "function") {
            throw new Error("Source must be a Function: " + String(source));
          }
        }
        this._source = source;
      }
      RelayObservable2.onUnhandledError = function onUnhandledError(callback) {
        hostReportError = callback;
      };
      RelayObservable2.from = function from(obj) {
        return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);
      };
      var _proto = RelayObservable2.prototype;
      _proto["catch"] = function _catch(fn) {
        var _this = this;
        return RelayObservable2.create(function(sink) {
          var subscription;
          _this.subscribe({
            start: function start(sub) {
              subscription = sub;
            },
            next: sink.next,
            complete: sink.complete,
            error: function error(_error2) {
              try {
                fn(_error2).subscribe({
                  start: function start(sub) {
                    subscription = sub;
                  },
                  next: sink.next,
                  complete: sink.complete,
                  error: sink.error
                });
              } catch (error2) {
                sink.error(error2, true);
              }
            }
          });
          return function() {
            return subscription.unsubscribe();
          };
        });
      };
      _proto.concat = function concat(next) {
        var _this2 = this;
        return RelayObservable2.create(function(sink) {
          var current;
          _this2.subscribe({
            start: function start(subscription) {
              current = subscription;
            },
            next: sink.next,
            error: sink.error,
            complete: function complete() {
              current = next.subscribe(sink);
            }
          });
          return function() {
            current && current.unsubscribe();
          };
        });
      };
      _proto["do"] = function _do(observer) {
        var _this3 = this;
        return RelayObservable2.create(function(sink) {
          var both = function both2(action) {
            return function() {
              try {
                observer[action] && observer[action].apply(observer, arguments);
              } catch (error) {
                hostReportError(error, true);
              }
              sink[action] && sink[action].apply(sink, arguments);
            };
          };
          return _this3.subscribe({
            start: both("start"),
            next: both("next"),
            error: both("error"),
            complete: both("complete"),
            unsubscribe: both("unsubscribe")
          });
        });
      };
      _proto["finally"] = function _finally(fn) {
        var _this4 = this;
        return RelayObservable2.create(function(sink) {
          var subscription = _this4.subscribe(sink);
          return function() {
            subscription.unsubscribe();
            fn();
          };
        });
      };
      _proto.ifEmpty = function ifEmpty(alternate) {
        var _this5 = this;
        return RelayObservable2.create(function(sink) {
          var hasValue = false;
          var current;
          current = _this5.subscribe({
            next: function next(value) {
              hasValue = true;
              sink.next(value);
            },
            error: sink.error,
            complete: function complete() {
              if (hasValue) {
                sink.complete();
              } else {
                current = alternate.subscribe(sink);
              }
            }
          });
          return function() {
            current && current.unsubscribe();
          };
        });
      };
      _proto.subscribe = function subscribe(observer) {
        if (true) {
          if (!observer || typeof observer !== "object") {
            throw new Error("Observer must be an Object with callbacks: " + String(observer));
          }
        }
        return _subscribe(this._source, observer);
      };
      _proto.map = function map(fn) {
        var _this6 = this;
        return RelayObservable2.create(function(sink) {
          var subscription = _this6.subscribe({
            complete: sink.complete,
            error: sink.error,
            next: function next(value) {
              try {
                var mapValue = fn(value);
                sink.next(mapValue);
              } catch (error) {
                sink.error(error, true);
              }
            }
          });
          return function() {
            subscription.unsubscribe();
          };
        });
      };
      _proto.mergeMap = function mergeMap(fn) {
        var _this7 = this;
        return RelayObservable2.create(function(sink) {
          var subscriptions = [];
          function start(subscription) {
            this._sub = subscription;
            subscriptions.push(subscription);
          }
          function complete() {
            subscriptions.splice(subscriptions.indexOf(this._sub), 1);
            if (subscriptions.length === 0) {
              sink.complete();
            }
          }
          _this7.subscribe({
            start,
            next: function next(value) {
              try {
                if (!sink.closed) {
                  RelayObservable2.from(fn(value)).subscribe({
                    start,
                    next: sink.next,
                    error: sink.error,
                    complete
                  });
                }
              } catch (error) {
                sink.error(error, true);
              }
            },
            error: sink.error,
            complete
          });
          return function() {
            subscriptions.forEach(function(sub) {
              return sub.unsubscribe();
            });
            subscriptions.length = 0;
          };
        });
      };
      _proto.poll = function poll(pollInterval) {
        var _this8 = this;
        if (true) {
          if (typeof pollInterval !== "number" || pollInterval <= 0) {
            throw new Error("RelayObservable: Expected pollInterval to be positive, got: " + pollInterval);
          }
        }
        return RelayObservable2.create(function(sink) {
          var subscription;
          var timeout;
          var poll2 = function poll3() {
            subscription = _this8.subscribe({
              next: sink.next,
              error: sink.error,
              complete: function complete() {
                timeout = setTimeout(poll3, pollInterval);
              }
            });
          };
          poll2();
          return function() {
            clearTimeout(timeout);
            subscription.unsubscribe();
          };
        });
      };
      _proto.toPromise = function toPromise() {
        var _this9 = this;
        return new Promise(function(resolve, reject) {
          var resolved = false;
          _this9.subscribe({
            next: function next(val) {
              if (!resolved) {
                resolved = true;
                resolve(val);
              }
            },
            error: reject,
            complete: resolve
          });
        });
      };
      return RelayObservable2;
    }();
    function isObservable(obj) {
      return typeof obj === "object" && obj !== null && typeof obj.subscribe === "function";
    }
    function fromObservable(obj) {
      return obj instanceof RelayObservable ? obj : RelayObservable.create(function(sink) {
        return obj.subscribe(sink);
      });
    }
    function fromPromise(promise) {
      return RelayObservable.create(function(sink) {
        promise.then(function(value) {
          sink.next(value);
          sink.complete();
        }, sink.error);
      });
    }
    function fromValue(value) {
      return RelayObservable.create(function(sink) {
        sink.next(value);
        sink.complete();
      });
    }
    function _subscribe(source, observer) {
      var closed = false;
      var cleanup;
      var withClosed = function withClosed2(obj) {
        return Object.defineProperty(obj, "closed", {
          get: function get() {
            return closed;
          }
        });
      };
      function doCleanup() {
        if (cleanup) {
          if (cleanup.unsubscribe) {
            cleanup.unsubscribe();
          } else {
            try {
              cleanup();
            } catch (error) {
              hostReportError(error, true);
            }
          }
          cleanup = void 0;
        }
      }
      var subscription = withClosed({
        unsubscribe: function unsubscribe() {
          if (!closed) {
            closed = true;
            try {
              observer.unsubscribe && observer.unsubscribe(subscription);
            } catch (error) {
              hostReportError(error, true);
            } finally {
              doCleanup();
            }
          }
        }
      });
      try {
        observer.start && observer.start(subscription);
      } catch (error) {
        hostReportError(error, true);
      }
      if (closed) {
        return subscription;
      }
      var sink = withClosed({
        next: function next(value) {
          if (!closed && observer.next) {
            try {
              observer.next(value);
            } catch (error) {
              hostReportError(error, true);
            }
          }
        },
        error: function error(_error3, isUncaughtThrownError) {
          if (closed || !observer.error) {
            closed = true;
            hostReportError(_error3, isUncaughtThrownError || false);
            doCleanup();
          } else {
            closed = true;
            try {
              observer.error(_error3);
            } catch (error2) {
              hostReportError(error2, true);
            } finally {
              doCleanup();
            }
          }
        },
        complete: function complete() {
          if (!closed) {
            closed = true;
            try {
              observer.complete && observer.complete();
            } catch (error) {
              hostReportError(error, true);
            } finally {
              doCleanup();
            }
          }
        }
      });
      try {
        cleanup = source(sink);
      } catch (error) {
        sink.error(error, true);
      }
      if (true) {
        if (cleanup !== void 0 && typeof cleanup !== "function" && (!cleanup || typeof cleanup.unsubscribe !== "function")) {
          throw new Error("Returned cleanup function which cannot be called: " + String(cleanup));
        }
      }
      if (closed) {
        doCleanup();
      }
      return subscription;
    }
    function swallowError(_error, _isUncaughtThrownError) {
    }
    if (true) {
      RelayObservable.onUnhandledError(function(error, isUncaughtThrownError) {
        if (typeof fail === "function") {
          fail(String(error));
        } else if (isUncaughtThrownError) {
          setTimeout(function() {
            throw error;
          });
        } else if (typeof console !== "undefined") {
          console.error("RelayObservable: Unhandled Error", error);
        }
      });
    }
    module.exports = RelayObservable;
  }
});

// node_modules/relay-runtime/lib/network/ConvertToExecuteFunction.js
var require_ConvertToExecuteFunction = __commonJS({
  "node_modules/relay-runtime/lib/network/ConvertToExecuteFunction.js"(exports, module) {
    "use strict";
    var RelayObservable = require_RelayObservable();
    function convertFetch(fn) {
      return function fetch(request, variables, cacheConfig, uploadables, logRequestInfo) {
        var result = fn(request, variables, cacheConfig, uploadables, logRequestInfo);
        if (result instanceof Error) {
          return RelayObservable.create(function(sink) {
            return sink.error(result);
          });
        }
        return RelayObservable.from(result);
      };
    }
    module.exports = {
      convertFetch
    };
  }
});

// node_modules/relay-runtime/lib/network/RelayNetwork.js
var require_RelayNetwork = __commonJS({
  "node_modules/relay-runtime/lib/network/RelayNetwork.js"(exports, module) {
    "use strict";
    var withProvidedVariables = require_withProvidedVariables();
    var _require = require_ConvertToExecuteFunction();
    var convertFetch = _require.convertFetch;
    var invariant = require_browser();
    function create(fetchFn, subscribe) {
      var observeFetch = convertFetch(fetchFn);
      function execute(request, variables, cacheConfig, uploadables, logRequestInfo) {
        var operationVariables = withProvidedVariables(variables, request.providedVariables);
        if (request.operationKind === "subscription") {
          !subscribe ? true ? invariant(false, "RelayNetwork: This network layer does not support Subscriptions. To use Subscriptions, provide a custom network layer.") : invariant(false) : void 0;
          !!uploadables ? true ? invariant(false, "RelayNetwork: Cannot provide uploadables while subscribing.") : invariant(false) : void 0;
          return subscribe(request, operationVariables, cacheConfig);
        }
        var pollInterval = cacheConfig.poll;
        if (pollInterval != null) {
          !!uploadables ? true ? invariant(false, "RelayNetwork: Cannot provide uploadables while polling.") : invariant(false) : void 0;
          return observeFetch(request, operationVariables, {
            force: true
          }).poll(pollInterval);
        }
        return observeFetch(request, operationVariables, cacheConfig, uploadables, logRequestInfo);
      }
      return {
        execute
      };
    }
    module.exports = {
      create
    };
  }
});

// node_modules/relay-runtime/lib/network/RelayQueryResponseCache.js
var require_RelayQueryResponseCache = __commonJS({
  "node_modules/relay-runtime/lib/network/RelayQueryResponseCache.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _require = require_stableCopy();
    var stableCopy = _require.stableCopy;
    var invariant = require_browser();
    var RelayQueryResponseCache = function() {
      function RelayQueryResponseCache2(_ref) {
        var size = _ref.size, ttl = _ref.ttl;
        !(size > 0) ? true ? invariant(false, "RelayQueryResponseCache: Expected the max cache size to be > 0, got `%s`.", size) : invariant(false) : void 0;
        !(ttl > 0) ? true ? invariant(false, "RelayQueryResponseCache: Expected the max ttl to be > 0, got `%s`.", ttl) : invariant(false) : void 0;
        this._responses = /* @__PURE__ */ new Map();
        this._size = size;
        this._ttl = ttl;
      }
      var _proto = RelayQueryResponseCache2.prototype;
      _proto.clear = function clear() {
        this._responses.clear();
      };
      _proto.get = function get(queryID, variables) {
        var _this = this;
        var cacheKey = getCacheKey(queryID, variables);
        this._responses.forEach(function(response2, key) {
          if (!isCurrent(response2.fetchTime, _this._ttl)) {
            _this._responses["delete"](key);
          }
        });
        var response = this._responses.get(cacheKey);
        if (response == null) {
          return null;
        }
        if (Array.isArray(response.payload)) {
          return response.payload.map(function(payload) {
            return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, payload), {}, {
              extensions: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, payload.extensions), {}, {
                cacheTimestamp: response.fetchTime
              })
            });
          });
        }
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, response.payload), {}, {
          extensions: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, response.payload.extensions), {}, {
            cacheTimestamp: response.fetchTime
          })
        });
      };
      _proto.set = function set(queryID, variables, payload) {
        var fetchTime = Date.now();
        var cacheKey = getCacheKey(queryID, variables);
        this._responses["delete"](cacheKey);
        this._responses.set(cacheKey, {
          fetchTime,
          payload
        });
        if (this._responses.size > this._size) {
          var firstKey = this._responses.keys().next();
          if (!firstKey.done) {
            this._responses["delete"](firstKey.value);
          }
        }
      };
      return RelayQueryResponseCache2;
    }();
    function getCacheKey(queryID, variables) {
      return JSON.stringify(stableCopy({
        queryID,
        variables
      }));
    }
    function isCurrent(fetchTime, ttl) {
      return fetchTime + ttl >= Date.now();
    }
    module.exports = RelayQueryResponseCache;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(t, e) {
      return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inheritsLoose.js
var require_inheritsLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/inheritsLoose.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inheritsLoose(t, o) {
      t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);
    }
    module.exports = _inheritsLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(t) {
      return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeFunction.js
var require_isNativeFunction = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeFunction.js"(exports, module) {
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module) {
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS({
  "node_modules/@babel/runtime/helpers/construct.js"(exports, module) {
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    var setPrototypeOf = require_setPrototypeOf();
    function _construct(t, e, r) {
      if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && setPrototypeOf(p, r.prototype), p;
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var require_wrapNativeSuper = __commonJS({
  "node_modules/@babel/runtime/helpers/wrapNativeSuper.js"(exports, module) {
    var getPrototypeOf = require_getPrototypeOf();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeFunction = require_isNativeFunction();
    var construct = require_construct();
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return module.exports = _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return construct(t2, arguments, getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        }), setPrototypeOf(Wrapper, t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/relay-runtime/lib/store/RelayErrorTrie.js
var require_RelayErrorTrie = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayErrorTrie.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require_objectWithoutPropertiesLoose());
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _wrapNativeSuper2 = _interopRequireDefault(require_wrapNativeSuper());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _excluded = ["path", "locations"];
    var SELF = Symbol("$SELF");
    var RelayFieldError = function(_Error) {
      (0, _inheritsLoose2["default"])(RelayFieldError2, _Error);
      function RelayFieldError2(message) {
        var _this;
        var errors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _this = _Error.call(this, message) || this;
        _this.name = "RelayFieldError";
        _this.message = message;
        _this.errors = errors;
        return _this;
      }
      return RelayFieldError2;
    }((0, _wrapNativeSuper2["default"])(Error));
    function buildErrorTrie(errors) {
      if (errors == null) {
        return null;
      }
      var trie = /* @__PURE__ */ new Map();
      var _iterator = (0, _createForOfIteratorHelper2["default"])(errors), _step;
      try {
        ERRORS: for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _step.value, path = _step$value.path, _ = _step$value.locations, error = (0, _objectWithoutPropertiesLoose2["default"])(_step$value, _excluded);
          if (path == null) {
            continue;
          }
          var length = path.length;
          if (length === 0) {
            continue;
          }
          var lastIndex = length - 1;
          var currentTrie = trie;
          for (var index = 0; index < lastIndex; index++) {
            var key = path[index];
            var existingValue = currentTrie.get(key);
            if (existingValue instanceof Map) {
              currentTrie = existingValue;
              continue;
            }
            var newValue = /* @__PURE__ */ new Map();
            if (Array.isArray(existingValue)) {
              newValue.set(SELF, existingValue);
            }
            currentTrie.set(key, newValue);
            currentTrie = newValue;
          }
          var lastKey = path[lastIndex];
          var container = currentTrie.get(lastKey);
          if (container instanceof Map) {
            currentTrie = container;
            container = currentTrie.get(lastKey);
            lastKey = SELF;
          }
          if (Array.isArray(container)) {
            container.push(error);
          } else {
            currentTrie.set(lastKey, [error]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return trie;
    }
    function getErrorsByKey(trie, key) {
      var value = trie.get(key);
      if (value == null) {
        return null;
      }
      if (Array.isArray(value)) {
        return value;
      }
      var errors = [];
      recursivelyCopyErrorsIntoArray(value, errors);
      return errors;
    }
    function recursivelyCopyErrorsIntoArray(trieOrSet, errors) {
      var _iterator2 = (0, _createForOfIteratorHelper2["default"])(trieOrSet), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = _step2.value, childKey = _step2$value[0], value = _step2$value[1];
          var oldLength = errors.length;
          if (Array.isArray(value)) {
            errors.push.apply(errors, (0, _toConsumableArray2["default"])(value));
          } else {
            recursivelyCopyErrorsIntoArray(value, errors);
          }
          if (childKey === SELF) {
            continue;
          }
          var newLength = errors.length;
          for (var index = oldLength; index < newLength; index++) {
            var error = errors[index];
            if (error.path == null) {
              errors[index] = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, error), {}, {
                path: [childKey]
              });
            } else {
              error.path.unshift(childKey);
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    function getNestedErrorTrieByKey(trie, key) {
      var value = trie.get(key);
      if (value instanceof Map) {
        return value;
      }
      return null;
    }
    module.exports = {
      SELF,
      buildErrorTrie,
      getNestedErrorTrieByKey,
      getErrorsByKey,
      RelayFieldError
    };
  }
});

// node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js
var require_handlePotentialSnapshotErrors = __commonJS({
  "node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _require = require_RelayErrorTrie();
    var RelayFieldError = _require.RelayFieldError;
    var RelayFeatureFlags = require_RelayFeatureFlags();
    function handleResolverErrors(environment, relayResolverErrors, throwOnFieldError) {
      var _iterator = (0, _createForOfIteratorHelper2["default"])(relayResolverErrors), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var resolverError = _step.value;
          environment.relayFieldLogger({
            kind: "relay_resolver.error",
            owner: resolverError.field.owner,
            fieldPath: resolverError.field.path,
            error: resolverError.error
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (RelayFeatureFlags.ENABLE_FIELD_ERROR_HANDLING_THROW_BY_DEFAULT || throwOnFieldError) {
        throw new RelayFieldError("Relay: Unexpected resolver exception", relayResolverErrors.map(function(e) {
          return {
            message: e.error.message
          };
        }));
      }
    }
    function handleFieldErrors(environment, errorResponseFields, shouldThrow) {
      var _iterator2 = (0, _createForOfIteratorHelper2["default"])(errorResponseFields), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var fieldError = _step2.value;
          var path = fieldError.path, owner = fieldError.owner, error = fieldError.error;
          if (fieldError.type === "MISSING_DATA") {
            logMissingData(environment, shouldThrow);
          } else {
            environment.relayFieldLogger({
              kind: "relay_field_payload.error",
              owner,
              fieldPath: path,
              error
            });
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (shouldThrow) {
        throw new RelayFieldError("Relay: Unexpected response payload - this object includes an errors property in which you can access the underlying errors", errorResponseFields.map(function(_ref) {
          var error2 = _ref.error;
          return error2;
        }));
      }
    }
    function logMissingData(environment, throwing) {
      if (!throwing) {
        environment.relayFieldLogger({
          kind: "missing_expected_data.log",
          owner: "",
          fieldPath: ""
        });
        return;
      }
      environment.relayFieldLogger({
        kind: "missing_expected_data.throw",
        owner: "",
        fieldPath: ""
      });
    }
    function handleMissingRequiredFields(environment, missingRequiredFields) {
      switch (missingRequiredFields.action) {
        case "THROW": {
          var _missingRequiredField = missingRequiredFields.field, path = _missingRequiredField.path, owner = _missingRequiredField.owner;
          environment.relayFieldLogger({
            kind: "missing_field.throw",
            owner,
            fieldPath: path
          });
          throw new Error("Relay: Missing @required value at path '".concat(path, "' in '").concat(owner, "'."));
        }
        case "LOG":
          missingRequiredFields.fields.forEach(function(_ref2) {
            var path2 = _ref2.path, owner2 = _ref2.owner;
            environment.relayFieldLogger({
              kind: "missing_field.log",
              owner: owner2,
              fieldPath: path2
            });
          });
          break;
        default: {
          missingRequiredFields.action;
        }
      }
    }
    function handleMissingDataError(environment, throwOnFieldErrorDirective) {
      logMissingData(environment, throwOnFieldErrorDirective);
      if (throwOnFieldErrorDirective) {
        throw new RelayFieldError("Relay: Missing data for one or more fields");
      }
    }
    function handlePotentialSnapshotErrors(environment, missingRequiredFields, relayResolverErrors, errorResponseFields, throwOnFieldError) {
      var onlyHasMissingDataErrors = Boolean(errorResponseFields === null || errorResponseFields === void 0 ? void 0 : errorResponseFields.every(function(field) {
        return field.type === "MISSING_DATA";
      }));
      if (onlyHasMissingDataErrors) {
        handleMissingDataError(environment, throwOnFieldError);
      }
      if (relayResolverErrors.length > 0) {
        handleResolverErrors(environment, relayResolverErrors, throwOnFieldError);
      }
      if (missingRequiredFields != null) {
        handleMissingRequiredFields(environment, missingRequiredFields);
      }
      if (errorResponseFields != null && !onlyHasMissingDataErrors) {
        handleFieldErrors(environment, errorResponseFields, throwOnFieldError);
      }
    }
    module.exports = handlePotentialSnapshotErrors;
  }
});

// node_modules/relay-runtime/lib/util/RelayReplaySubject.js
var require_RelayReplaySubject = __commonJS({
  "node_modules/relay-runtime/lib/util/RelayReplaySubject.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var RelayObservable = require_RelayObservable();
    var invariant = require_browser();
    var RelayReplaySubject = function() {
      function RelayReplaySubject2() {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_complete", false);
        (0, _defineProperty2["default"])(this, "_events", []);
        (0, _defineProperty2["default"])(this, "_sinks", /* @__PURE__ */ new Set());
        (0, _defineProperty2["default"])(this, "_subscription", []);
        this._observable = RelayObservable.create(function(sink) {
          _this._sinks.add(sink);
          var events = _this._events;
          for (var i = 0; i < events.length; i++) {
            if (sink.closed) {
              break;
            }
            var event = events[i];
            switch (event.kind) {
              case "complete":
                sink.complete();
                break;
              case "error":
                sink.error(event.error);
                break;
              case "next":
                sink.next(event.data);
                break;
              default:
                event.kind;
                true ? true ? invariant(false, "RelayReplaySubject: Unknown event kind `%s`.", event.kind) : invariant(false) : void 0;
            }
          }
          return function() {
            _this._sinks["delete"](sink);
          };
        });
      }
      var _proto = RelayReplaySubject2.prototype;
      _proto.complete = function complete() {
        if (this._complete === true) {
          return;
        }
        this._complete = true;
        this._events.push({
          kind: "complete"
        });
        this._sinks.forEach(function(sink) {
          return sink.complete();
        });
      };
      _proto.error = function error(_error) {
        if (this._complete === true) {
          return;
        }
        this._complete = true;
        this._events.push({
          kind: "error",
          error: _error
        });
        this._sinks.forEach(function(sink) {
          return sink.error(_error);
        });
      };
      _proto.next = function next(data) {
        if (this._complete === true) {
          return;
        }
        this._events.push({
          kind: "next",
          data
        });
        this._sinks.forEach(function(sink) {
          return sink.next(data);
        });
      };
      _proto.subscribe = function subscribe(observer) {
        var subscription = this._observable.subscribe(observer);
        this._subscription.push(subscription);
        return subscription;
      };
      _proto.unsubscribe = function unsubscribe() {
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._subscription), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var subscription = _step.value;
            subscription.unsubscribe();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this._subscription = [];
      };
      _proto.getObserverCount = function getObserverCount() {
        return this._sinks.size;
      };
      return RelayReplaySubject2;
    }();
    module.exports = RelayReplaySubject;
  }
});

// node_modules/relay-runtime/lib/query/fetchQueryInternal.js
var require_fetchQueryInternal = __commonJS({
  "node_modules/relay-runtime/lib/query/fetchQueryInternal.js"(exports, module) {
    "use strict";
    var Observable = require_RelayObservable();
    var RelayReplaySubject = require_RelayReplaySubject();
    var invariant = require_browser();
    var WEAKMAP_SUPPORTED = typeof WeakMap === "function";
    var requestCachesByEnvironment = WEAKMAP_SUPPORTED ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map();
    function fetchQuery(environment, operation) {
      return fetchQueryDeduped(environment, operation.request.identifier, function() {
        return environment.execute({
          operation
        });
      });
    }
    function fetchQueryDeduped(environment, identifier, fetchFn) {
      return Observable.create(function(sink) {
        var requestCache = getRequestCache(environment);
        var cachedRequest = requestCache.get(identifier);
        if (!cachedRequest) {
          fetchFn()["finally"](function() {
            return requestCache["delete"](identifier);
          }).subscribe({
            start: function start(subscription) {
              cachedRequest = {
                identifier,
                subject: new RelayReplaySubject(),
                subjectForInFlightStatus: new RelayReplaySubject(),
                subscription,
                promise: null
              };
              requestCache.set(identifier, cachedRequest);
            },
            next: function next(response) {
              var cachedReq = getCachedRequest(requestCache, identifier);
              cachedReq.subject.next(response);
              cachedReq.subjectForInFlightStatus.next(response);
            },
            error: function error(_error) {
              var cachedReq = getCachedRequest(requestCache, identifier);
              cachedReq.subject.error(_error);
              cachedReq.subjectForInFlightStatus.error(_error);
            },
            complete: function complete() {
              var cachedReq = getCachedRequest(requestCache, identifier);
              cachedReq.subject.complete();
              cachedReq.subjectForInFlightStatus.complete();
            },
            unsubscribe: function unsubscribe(subscription) {
              var cachedReq = getCachedRequest(requestCache, identifier);
              cachedReq.subject.unsubscribe();
              cachedReq.subjectForInFlightStatus.unsubscribe();
            }
          });
        }
        !(cachedRequest != null) ? true ? invariant(false, "[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be called synchronously") : invariant(false) : void 0;
        return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);
      });
    }
    function getObservableForCachedRequest(requestCache, cachedRequest) {
      return Observable.create(function(sink) {
        var subscription = cachedRequest.subject.subscribe(sink);
        return function() {
          subscription.unsubscribe();
          var cachedRequestInstance = requestCache.get(cachedRequest.identifier);
          if (cachedRequestInstance) {
            var requestSubscription = cachedRequestInstance.subscription;
            if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {
              requestSubscription.unsubscribe();
              requestCache["delete"](cachedRequest.identifier);
            }
          }
        };
      });
    }
    function getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {
      return Observable.create(function(sink) {
        var subscription = cachedRequest.subjectForInFlightStatus.subscribe({
          error: sink.error,
          next: function next(response) {
            if (!environment.isRequestActive(cachedRequest.identifier)) {
              sink.complete();
              return;
            }
            sink.next();
          },
          complete: sink.complete,
          unsubscribe: sink.complete
        });
        return function() {
          subscription.unsubscribe();
        };
      });
    }
    function getPromiseForActiveRequest(environment, request) {
      var requestCache = getRequestCache(environment);
      var cachedRequest = requestCache.get(request.identifier);
      if (!cachedRequest) {
        return null;
      }
      if (!environment.isRequestActive(cachedRequest.identifier)) {
        return null;
      }
      var promise = new Promise(function(resolve, reject) {
        var resolveOnNext = false;
        getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({
          complete: resolve,
          error: reject,
          next: function next(response) {
            if (resolveOnNext) {
              resolve(response);
            }
          }
        });
        resolveOnNext = true;
      });
      return promise;
    }
    function getObservableForActiveRequest(environment, request) {
      var requestCache = getRequestCache(environment);
      var cachedRequest = requestCache.get(request.identifier);
      if (!cachedRequest) {
        return null;
      }
      if (!environment.isRequestActive(cachedRequest.identifier)) {
        return null;
      }
      return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);
    }
    function getRequestCache(environment) {
      var cached = requestCachesByEnvironment.get(environment);
      if (cached != null) {
        return cached;
      }
      var requestCache = /* @__PURE__ */ new Map();
      requestCachesByEnvironment.set(environment, requestCache);
      return requestCache;
    }
    function getCachedRequest(requestCache, identifier) {
      var cached = requestCache.get(identifier);
      !(cached != null) ? true ? invariant(false, "[fetchQueryInternal] getCachedRequest: Expected request to be cached") : invariant(false) : void 0;
      return cached;
    }
    module.exports = {
      fetchQuery,
      fetchQueryDeduped,
      getPromiseForActiveRequest,
      getObservableForActiveRequest
    };
  }
});

// node_modules/relay-runtime/lib/query/fetchQuery.js
var require_fetchQuery = __commonJS({
  "node_modules/relay-runtime/lib/query/fetchQuery.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var RelayObservable = require_RelayObservable();
    var _require = require_RelayModernOperationDescriptor();
    var createOperationDescriptor = _require.createOperationDescriptor;
    var handlePotentialSnapshotErrors = require_handlePotentialSnapshotErrors();
    var fetchQueryInternal = require_fetchQueryInternal();
    var _require2 = require_GraphQLTag();
    var getRequest = _require2.getRequest;
    var invariant = require_browser();
    function fetchQuery(environment, query, variables, options) {
      var _options$fetchPolicy;
      var queryNode = getRequest(query);
      !(queryNode.params.operationKind === "query") ? true ? invariant(false, "fetchQuery: Expected query operation") : invariant(false) : void 0;
      var networkCacheConfig = (0, _objectSpread2["default"])({
        force: true
      }, options === null || options === void 0 ? void 0 : options.networkCacheConfig);
      var operation = createOperationDescriptor(queryNode, variables, networkCacheConfig);
      var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : "network-only";
      function readData(snapshot) {
        var _queryNode$fragment$m, _queryNode$fragment$m2;
        handlePotentialSnapshotErrors(environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors, snapshot.errorResponseFields, (_queryNode$fragment$m = (_queryNode$fragment$m2 = queryNode.fragment.metadata) === null || _queryNode$fragment$m2 === void 0 ? void 0 : _queryNode$fragment$m2.throwOnFieldError) !== null && _queryNode$fragment$m !== void 0 ? _queryNode$fragment$m : false);
        return snapshot.data;
      }
      switch (fetchPolicy) {
        case "network-only": {
          return getNetworkObservable(environment, operation).map(readData);
        }
        case "store-or-network": {
          if (environment.check(operation).status === "available") {
            return RelayObservable.from(environment.lookup(operation.fragment)).map(readData);
          }
          return getNetworkObservable(environment, operation).map(readData);
        }
        default:
          fetchPolicy;
          throw new Error("fetchQuery: Invalid fetchPolicy " + fetchPolicy);
      }
    }
    function getNetworkObservable(environment, operation) {
      return fetchQueryInternal.fetchQuery(environment, operation).map(function() {
        return environment.lookup(operation.fragment);
      });
    }
    module.exports = fetchQuery;
  }
});

// node_modules/relay-runtime/lib/query/fetchQuery_DEPRECATED.js
var require_fetchQuery_DEPRECATED = __commonJS({
  "node_modules/relay-runtime/lib/query/fetchQuery_DEPRECATED.js"(exports, module) {
    "use strict";
    var _require = require_RelayModernOperationDescriptor();
    var createOperationDescriptor = _require.createOperationDescriptor;
    var _require2 = require_GraphQLTag();
    var getRequest = _require2.getRequest;
    function fetchQuery_DEPRECATED(environment, taggedNode, variables, cacheConfig) {
      var query = getRequest(taggedNode);
      if (query.params.operationKind !== "query") {
        throw new Error("fetchQuery: Expected query operation");
      }
      var operation = createOperationDescriptor(query, variables, cacheConfig);
      return environment.execute({
        operation
      }).map(function() {
        return environment.lookup(operation.fragment).data;
      }).toPromise();
    }
    module.exports = fetchQuery_DEPRECATED;
  }
});

// node_modules/relay-runtime/lib/query/PreloadableQueryRegistry.js
var require_PreloadableQueryRegistry = __commonJS({
  "node_modules/relay-runtime/lib/query/PreloadableQueryRegistry.js"(exports, module) {
    "use strict";
    var PreloadableQueryRegistry = function() {
      function PreloadableQueryRegistry2() {
        this._preloadableQueries = /* @__PURE__ */ new Map();
        this._callbacks = /* @__PURE__ */ new Map();
      }
      var _proto = PreloadableQueryRegistry2.prototype;
      _proto.set = function set(key, value) {
        this._preloadableQueries.set(key, value);
        var callbacks = this._callbacks.get(key);
        if (callbacks != null) {
          callbacks.forEach(function(cb) {
            try {
              cb(value);
            } catch (e) {
              setTimeout(function() {
                throw e;
              }, 0);
            }
          });
        }
      };
      _proto.get = function get(key) {
        return this._preloadableQueries.get(key);
      };
      _proto.onLoad = function onLoad(key, callback) {
        var _this$_callbacks$get;
        var callbacks = (_this$_callbacks$get = this._callbacks.get(key)) !== null && _this$_callbacks$get !== void 0 ? _this$_callbacks$get : /* @__PURE__ */ new Set();
        callbacks.add(callback);
        var dispose = function dispose2() {
          callbacks["delete"](callback);
        };
        this._callbacks.set(key, callbacks);
        return {
          dispose
        };
      };
      _proto.clear = function clear() {
        this._preloadableQueries.clear();
      };
      return PreloadableQueryRegistry2;
    }();
    var preloadableQueryRegistry = new PreloadableQueryRegistry();
    module.exports = preloadableQueryRegistry;
  }
});

// node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js
var require_getPendingOperationsForFragment = __commonJS({
  "node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js"(exports, module) {
    "use strict";
    var _require = require_fetchQueryInternal();
    var getPromiseForActiveRequest = _require.getPromiseForActiveRequest;
    function getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner) {
      var _pendingOperations$ma, _pendingOperations;
      var pendingOperations = [];
      var promise = getPromiseForActiveRequest(environment, fragmentOwner);
      if (promise != null) {
        pendingOperations = [fragmentOwner];
      } else {
        var _result$pendingOperat, _result$promise;
        var result = environment.getOperationTracker().getPendingOperationsAffectingOwner(fragmentOwner);
        pendingOperations = (_result$pendingOperat = result === null || result === void 0 ? void 0 : result.pendingOperations) !== null && _result$pendingOperat !== void 0 ? _result$pendingOperat : [];
        promise = (_result$promise = result === null || result === void 0 ? void 0 : result.promise) !== null && _result$promise !== void 0 ? _result$promise : null;
      }
      if (!promise) {
        return null;
      }
      var pendingOperationName = (_pendingOperations$ma = (_pendingOperations = pendingOperations) === null || _pendingOperations === void 0 ? void 0 : _pendingOperations.map(function(op) {
        return op.node.params.name;
      }).join(",")) !== null && _pendingOperations$ma !== void 0 ? _pendingOperations$ma : null;
      if (pendingOperationName == null || pendingOperationName.length === 0) {
        pendingOperationName = "Unknown pending operation";
      }
      var fragmentName = fragmentNode.name;
      var promiseDisplayName = pendingOperationName === fragmentName ? "Relay(".concat(pendingOperationName, ")") : "Relay(".concat(pendingOperationName, ":").concat(fragmentName, ")");
      promise.displayName = promiseDisplayName;
      environment.__log({
        name: "pendingoperation.found",
        fragment: fragmentNode,
        fragmentOwner,
        pendingOperations
      });
      return {
        promise,
        pendingOperations
      };
    }
    module.exports = getPendingOperationsForFragment;
  }
});

// node_modules/relay-runtime/lib/util/isScalarAndEqual.js
var require_isScalarAndEqual = __commonJS({
  "node_modules/relay-runtime/lib/util/isScalarAndEqual.js"(exports, module) {
    "use strict";
    function isScalarAndEqual(valueA, valueB) {
      return valueA === valueB && (valueA === null || typeof valueA !== "object");
    }
    module.exports = isScalarAndEqual;
  }
});

// node_modules/relay-runtime/lib/util/recycleNodesInto.js
var require_recycleNodesInto = __commonJS({
  "node_modules/relay-runtime/lib/util/recycleNodesInto.js"(exports, module) {
    "use strict";
    function recycleNodesInto(prevData, nextData) {
      return recycleNodesIntoImpl(prevData, nextData, true);
    }
    function recycleNodesIntoImpl(prevData, nextData, canMutate) {
      if (prevData === nextData || typeof prevData !== "object" || !prevData || prevData.constructor !== Object && !Array.isArray(prevData) || typeof nextData !== "object" || !nextData || nextData.constructor !== Object && !Array.isArray(nextData)) {
        return nextData;
      }
      var canRecycle = false;
      var prevArray = Array.isArray(prevData) ? prevData : null;
      var nextArray = Array.isArray(nextData) ? nextData : null;
      if (prevArray && nextArray) {
        var canMutateNext = canMutate && !Object.isFrozen(nextArray);
        canRecycle = nextArray.reduce(function(wasEqual, nextItem, ii) {
          var prevValue = prevArray[ii];
          var nextValue = recycleNodesIntoImpl(prevValue, nextItem, canMutateNext);
          if (nextValue !== nextArray[ii] && canMutateNext) {
            nextArray[ii] = nextValue;
          }
          return wasEqual && nextValue === prevArray[ii];
        }, true) && prevArray.length === nextArray.length;
      } else if (!prevArray && !nextArray) {
        var prevObject = prevData;
        var nextObject = nextData;
        var prevKeys = Object.keys(prevObject);
        var nextKeys = Object.keys(nextObject);
        var _canMutateNext = canMutate && !Object.isFrozen(nextObject);
        canRecycle = nextKeys.reduce(function(wasEqual, key) {
          var prevValue = prevObject[key];
          var nextValue = recycleNodesIntoImpl(prevValue, nextObject[key], _canMutateNext);
          if (nextValue !== nextObject[key] && _canMutateNext) {
            nextObject[key] = nextValue;
          }
          return wasEqual && nextValue === prevObject[key];
        }, true) && prevKeys.length === nextKeys.length;
      }
      return canRecycle ? prevData : nextData;
    }
    module.exports = recycleNodesInto;
  }
});

// node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js
var require_RelayModernFragmentSpecResolver = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var getPendingOperationsForFragment = require_getPendingOperationsForFragment();
    var handlePotentialSnapshotErrors = require_handlePotentialSnapshotErrors();
    var isScalarAndEqual = require_isScalarAndEqual();
    var recycleNodesInto = require_recycleNodesInto();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var _require = require_RelayModernOperationDescriptor();
    var createRequestDescriptor = _require.createRequestDescriptor;
    var _require2 = require_RelayModernSelector();
    var areEqualSelectors = _require2.areEqualSelectors;
    var createReaderSelector = _require2.createReaderSelector;
    var getSelectorsFromObject = _require2.getSelectorsFromObject;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    var warning = require_warning();
    var RelayModernFragmentSpecResolver = function() {
      function RelayModernFragmentSpecResolver2(context, fragments, props, callback, rootIsQueryRenderer) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_onChange", function() {
          _this._stale = true;
          if (typeof _this._callback === "function") {
            _this._callback();
          }
        });
        this._callback = callback;
        this._context = context;
        this._data = {};
        this._fragments = fragments;
        this._props = {};
        this._resolvers = {};
        this._stale = false;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this.setProps(props);
      }
      var _proto = RelayModernFragmentSpecResolver2.prototype;
      _proto.dispose = function dispose() {
        for (var key in this._resolvers) {
          if (this._resolvers.hasOwnProperty(key)) {
            disposeCallback(this._resolvers[key]);
          }
        }
      };
      _proto.resolve = function resolve() {
        if (this._stale) {
          var prevData = this._data;
          var nextData;
          for (var key in this._resolvers) {
            if (this._resolvers.hasOwnProperty(key)) {
              var resolver = this._resolvers[key];
              var prevItem = prevData[key];
              if (resolver) {
                var nextItem = resolver.resolve();
                if (nextData || nextItem !== prevItem) {
                  nextData = nextData || (0, _objectSpread2["default"])({}, prevData);
                  nextData[key] = nextItem;
                }
              } else {
                var prop = this._props[key];
                var _nextItem = prop !== void 0 ? prop : null;
                if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {
                  nextData = nextData || (0, _objectSpread2["default"])({}, prevData);
                  nextData[key] = _nextItem;
                }
              }
            }
          }
          this._data = nextData || prevData;
          this._stale = false;
        }
        return this._data;
      };
      _proto.setCallback = function setCallback(props, callback) {
        this._callback = callback;
        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
          this.setProps(props);
        }
      };
      _proto.setProps = function setProps(props) {
        this._props = {};
        var ownedSelectors = getSelectorsFromObject(this._fragments, props);
        for (var key in ownedSelectors) {
          if (ownedSelectors.hasOwnProperty(key)) {
            var ownedSelector = ownedSelectors[key];
            var resolver = this._resolvers[key];
            if (ownedSelector == null) {
              if (resolver != null) {
                resolver.dispose();
              }
              resolver = null;
            } else if (ownedSelector.kind === "PluralReaderSelector") {
              if (resolver == null) {
                resolver = new SelectorListResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);
              } else {
                !(resolver instanceof SelectorListResolver) ? true ? invariant(false, "RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.", key) : invariant(false) : void 0;
                resolver.setSelector(ownedSelector);
              }
            } else {
              if (resolver == null) {
                resolver = new SelectorResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);
              } else {
                !(resolver instanceof SelectorResolver) ? true ? invariant(false, "RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.", key) : invariant(false) : void 0;
                resolver.setSelector(ownedSelector);
              }
            }
            this._props[key] = props[key];
            this._resolvers[key] = resolver;
          }
        }
        this._stale = true;
      };
      _proto.setVariables = function setVariables(variables, request) {
        for (var key in this._resolvers) {
          if (this._resolvers.hasOwnProperty(key)) {
            var resolver = this._resolvers[key];
            if (resolver) {
              resolver.setVariables(variables, request);
            }
          }
        }
        this._stale = true;
      };
      return RelayModernFragmentSpecResolver2;
    }();
    var SelectorResolver = function() {
      function SelectorResolver2(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {
        var _this2 = this;
        (0, _defineProperty2["default"])(this, "_onChange", function(snapshot) {
          _this2._data = snapshot.data;
          _this2._isMissingData = snapshot.isMissingData;
          _this2._missingRequiredFields = snapshot.missingRequiredFields;
          _this2._errorResponseFields = snapshot.errorResponseFields;
          _this2._relayResolverErrors = snapshot.relayResolverErrors;
          _this2._callback();
        });
        var _snapshot = environment.lookup(selector);
        this._callback = callback;
        this._data = _snapshot.data;
        this._isMissingData = _snapshot.isMissingData;
        this._missingRequiredFields = _snapshot.missingRequiredFields;
        this._errorResponseFields = _snapshot.errorResponseFields;
        this._relayResolverErrors = _snapshot.relayResolverErrors;
        this._environment = environment;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this._selector = selector;
        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
          if (subscribeOnConstruction) {
            this._subscription = environment.subscribe(_snapshot, this._onChange);
          }
        } else {
          this._subscription = environment.subscribe(_snapshot, this._onChange);
        }
      }
      var _proto2 = SelectorResolver2.prototype;
      _proto2.dispose = function dispose() {
        if (this._subscription) {
          this._subscription.dispose();
          this._subscription = null;
        }
      };
      _proto2.resolve = function resolve() {
        var _this$_selector$node$, _this$_selector$node$2;
        if (this._isMissingData === true) {
          var pendingOperationsResult = getPendingOperationsForFragment(this._environment, this._selector.node, this._selector.owner);
          var promise = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.promise;
          if (promise != null) {
            if (this._rootIsQueryRenderer) {
              true ? warning(false, "Relay: Relay Container for fragment `%s` has missing data and would suspend. When using features such as @defer or @module, use `useFragment` instead of a Relay Container.", this._selector.node.name) : void 0;
            } else {
              var _pendingOperationsRes;
              var pendingOperations = (_pendingOperationsRes = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.pendingOperations) !== null && _pendingOperationsRes !== void 0 ? _pendingOperationsRes : [];
              true ? warning(false, "Relay: Relay Container for fragment `%s` suspended. When using features such as @defer or @module, use `useFragment` instead of a Relay Container.", this._selector.node.name) : void 0;
              this._environment.__log({
                name: "suspense.fragment",
                data: this._data,
                fragment: this._selector.node,
                isRelayHooks: false,
                isMissingData: this._isMissingData,
                isPromiseCached: false,
                pendingOperations
              });
              throw promise;
            }
          }
        }
        handlePotentialSnapshotErrors(this._environment, this._missingRequiredFields, this._relayResolverErrors, this._errorResponseFields, (_this$_selector$node$ = (_this$_selector$node$2 = this._selector.node.metadata) === null || _this$_selector$node$2 === void 0 ? void 0 : _this$_selector$node$2.throwOnFieldError) !== null && _this$_selector$node$ !== void 0 ? _this$_selector$node$ : false);
        return this._data;
      };
      _proto2.setSelector = function setSelector(selector) {
        if (this._subscription != null && areEqualSelectors(selector, this._selector)) {
          return;
        }
        this.dispose();
        var snapshot = this._environment.lookup(selector);
        this._data = recycleNodesInto(this._data, snapshot.data);
        this._isMissingData = snapshot.isMissingData;
        this._missingRequiredFields = snapshot.missingRequiredFields;
        this._errorResponseFields = snapshot.errorResponseFields;
        this._relayResolverErrors = snapshot.relayResolverErrors;
        this._selector = selector;
        this._subscription = this._environment.subscribe(snapshot, this._onChange);
      };
      _proto2.setVariables = function setVariables(variables, request) {
        if (areEqual(variables, this._selector.variables)) {
          return;
        }
        var requestDescriptor = createRequestDescriptor(request, variables);
        var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);
        this.setSelector(selector);
      };
      return SelectorResolver2;
    }();
    var SelectorListResolver = function() {
      function SelectorListResolver2(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {
        var _this3 = this;
        (0, _defineProperty2["default"])(this, "_onChange", function(data) {
          _this3._stale = true;
          _this3._callback();
        });
        this._callback = callback;
        this._data = [];
        this._environment = environment;
        this._resolvers = [];
        this._stale = true;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this._subscribeOnConstruction = subscribeOnConstruction;
        this.setSelector(selector);
      }
      var _proto3 = SelectorListResolver2.prototype;
      _proto3.dispose = function dispose() {
        this._resolvers.forEach(disposeCallback);
      };
      _proto3.resolve = function resolve() {
        if (this._stale) {
          var prevData = this._data;
          var nextData;
          for (var ii = 0; ii < this._resolvers.length; ii++) {
            var prevItem = prevData[ii];
            var nextItem = this._resolvers[ii].resolve();
            if (nextData || nextItem !== prevItem) {
              nextData = nextData || prevData.slice(0, ii);
              nextData.push(nextItem);
            }
          }
          if (!nextData && this._resolvers.length !== prevData.length) {
            nextData = prevData.slice(0, this._resolvers.length);
          }
          this._data = nextData || prevData;
          this._stale = false;
        }
        return this._data;
      };
      _proto3.setSelector = function setSelector(selector) {
        var selectors = selector.selectors;
        while (this._resolvers.length > selectors.length) {
          var resolver = this._resolvers.pop();
          resolver.dispose();
        }
        for (var ii = 0; ii < selectors.length; ii++) {
          if (ii < this._resolvers.length) {
            this._resolvers[ii].setSelector(selectors[ii]);
          } else {
            this._resolvers[ii] = new SelectorResolver(this._environment, this._rootIsQueryRenderer, selectors[ii], this._subscribeOnConstruction, this._onChange);
          }
        }
        this._stale = true;
      };
      _proto3.setVariables = function setVariables(variables, request) {
        this._resolvers.forEach(function(resolver) {
          return resolver.setVariables(variables, request);
        });
        this._stale = true;
      };
      return SelectorListResolver2;
    }();
    function disposeCallback(disposable) {
      disposable && disposable.dispose();
    }
    module.exports = RelayModernFragmentSpecResolver;
  }
});

// node_modules/relay-runtime/lib/store/createFragmentSpecResolver.js
var require_createFragmentSpecResolver = __commonJS({
  "node_modules/relay-runtime/lib/store/createFragmentSpecResolver.js"(exports, module) {
    "use strict";
    var RelayModernFragmentSpecResolver = require_RelayModernFragmentSpecResolver();
    var warning = require_warning();
    function createFragmentSpecResolver(context, containerName, fragments, props, rootIsQueryRenderer, callback) {
      if (true) {
        var fragmentNames = Object.keys(fragments);
        fragmentNames.forEach(function(fragmentName) {
          var propValue = props[fragmentName];
          true ? warning(propValue !== void 0, "createFragmentSpecResolver: Expected prop `%s` to be supplied to `%s`, but got `undefined`. Pass an explicit `null` if this is intentional.", fragmentName, containerName) : void 0;
        });
      }
      return new RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer);
    }
    module.exports = createFragmentSpecResolver;
  }
});

// node_modules/relay-runtime/lib/store/createRelayContext.js
var require_createRelayContext = __commonJS({
  "node_modules/relay-runtime/lib/store/createRelayContext.js"(exports, module) {
    "use strict";
    var invariant = require_browser();
    var relayContext;
    var firstReact;
    function createRelayContext(react) {
      if (!relayContext) {
        relayContext = react.createContext(null);
        if (true) {
          relayContext.displayName = "RelayContext";
        }
        firstReact = react;
      }
      !(react === firstReact) ? true ? invariant(false, "[createRelayContext]: You are passing a different instance of React", react.version) : invariant(false) : void 0;
      return relayContext;
    }
    module.exports = createRelayContext;
  }
});

// node_modules/relay-runtime/lib/store/experimental-live-resolvers/LiveResolverSuspenseSentinel.js
var require_LiveResolverSuspenseSentinel = __commonJS({
  "node_modules/relay-runtime/lib/store/experimental-live-resolvers/LiveResolverSuspenseSentinel.js"(exports, module) {
    "use strict";
    var LIVE_RESOLVER_SUSPENSE_SENTINEL = Object.freeze({
      __LIVE_RESOLVER_SUSPENSE_SENTINEL: true
    });
    function suspenseSentinel() {
      return LIVE_RESOLVER_SUSPENSE_SENTINEL;
    }
    function isSuspenseSentinel(value) {
      return value === LIVE_RESOLVER_SUSPENSE_SENTINEL;
    }
    module.exports = {
      isSuspenseSentinel,
      suspenseSentinel
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayModernRecord.js
var require_RelayModernRecord = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayModernRecord.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require_objectWithoutPropertiesLoose());
    var _toPropertyKey2 = _interopRequireDefault(require_toPropertyKey());
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var deepFreeze = require_deepFreeze();
    var _require = require_ClientID();
    var generateClientObjectClientID = _require.generateClientObjectClientID;
    var isClientID = _require.isClientID;
    var _require2 = require_LiveResolverSuspenseSentinel();
    var isSuspenseSentinel = _require2.isSuspenseSentinel;
    var _require3 = require_RelayStoreUtils();
    var ACTOR_IDENTIFIER_KEY = _require3.ACTOR_IDENTIFIER_KEY;
    var ERRORS_KEY = _require3.ERRORS_KEY;
    var ID_KEY = _require3.ID_KEY;
    var INVALIDATED_AT_KEY = _require3.INVALIDATED_AT_KEY;
    var REF_KEY = _require3.REF_KEY;
    var REFS_KEY = _require3.REFS_KEY;
    var RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY;
    var ROOT_ID = _require3.ROOT_ID;
    var TYPENAME_KEY = _require3.TYPENAME_KEY;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    var warning = require_warning();
    function clone(record) {
      return (0, _objectSpread2["default"])({}, record);
    }
    function copyFields(source, sink) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          if (key !== ID_KEY && key !== TYPENAME_KEY) {
            sink[key] = source[key];
          }
        }
      }
    }
    function create(dataID, typeName) {
      var record = {};
      record[ID_KEY] = dataID;
      record[TYPENAME_KEY] = typeName;
      return record;
    }
    function fromObject(json) {
      return json;
    }
    function getDataID(record) {
      return record[ID_KEY];
    }
    function getFields(record) {
      if (ERRORS_KEY in record) {
        return Object.keys(record).filter(function(field) {
          return field !== ERRORS_KEY;
        });
      }
      return Object.keys(record);
    }
    function getType(record) {
      return record[TYPENAME_KEY];
    }
    function getErrors(record, storageKey) {
      var _record$ERRORS_KEY;
      return (_record$ERRORS_KEY = record[ERRORS_KEY]) === null || _record$ERRORS_KEY === void 0 ? void 0 : _record$ERRORS_KEY[storageKey];
    }
    function getValue(record, storageKey) {
      var value = record[storageKey];
      if (value && typeof value === "object") {
        !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? true ? invariant(false, "RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` but found %s.", record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? "a linked record" : "plural linked records") : invariant(false) : void 0;
      }
      return value;
    }
    function hasValue(record, storageKey) {
      return storageKey in record;
    }
    function getLinkedRecordID(record, storageKey) {
      var maybeLink = record[storageKey];
      if (maybeLink == null) {
        return maybeLink;
      }
      var link = maybeLink;
      !(typeof link === "object" && link && typeof link[REF_KEY] === "string") ? true ? invariant(false, "RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, was `%s`.%s", record[ID_KEY], storageKey, JSON.stringify(link), typeof link === "object" && link[REFS_KEY] !== void 0 ? " It appears to be a plural linked record: did you mean to call getLinkedRecords() instead of getLinkedRecord()?" : "") : invariant(false) : void 0;
      return link[REF_KEY];
    }
    function hasLinkedRecordID(record, storageKey) {
      var maybeLink = record[storageKey];
      if (maybeLink == null) {
        return false;
      }
      var link = maybeLink;
      return typeof link === "object" && link && typeof link[REF_KEY] === "string";
    }
    function getLinkedRecordIDs(record, storageKey) {
      var links = record[storageKey];
      if (links == null) {
        return links;
      }
      !(typeof links === "object" && Array.isArray(links[REFS_KEY])) ? true ? invariant(false, "RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array of linked IDs, got `%s`.%s", record[ID_KEY], storageKey, JSON.stringify(links), typeof links === "object" && links[REF_KEY] !== void 0 ? " It appears to be a singular linked record: did you mean to call getLinkedRecord() instead of getLinkedRecords()?" : "") : invariant(false) : void 0;
      return links[REFS_KEY];
    }
    function hasLinkedRecordIDs(record, storageKey) {
      var links = record[storageKey];
      if (links == null) {
        return false;
      }
      return typeof links === "object" && Array.isArray(links[REFS_KEY]) && links[REFS_KEY].every(function(link) {
        return typeof link === "string";
      });
    }
    function getInvalidationEpoch(record) {
      if (record == null) {
        return null;
      }
      var invalidatedAt = record[INVALIDATED_AT_KEY];
      if (typeof invalidatedAt !== "number") {
        return null;
      }
      return invalidatedAt;
    }
    function update(prevRecord, nextRecord) {
      var _updated2;
      if (true) {
        var _getType, _getType2;
        var prevID = getDataID(prevRecord);
        var nextID = getDataID(nextRecord);
        true ? warning(prevID === nextID, "RelayModernRecord: Invalid record update, expected both versions of the record to have the same id, got `%s` and `%s`.", prevID, nextID) : void 0;
        var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;
        var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;
        true ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, "RelayModernRecord: Invalid record update, expected both versions of record `%s` to have the same `%s` but got conflicting types `%s` and `%s`. The GraphQL server likely violated the globally unique id requirement by returning the same id for different objects.", prevID, TYPENAME_KEY, prevType, nextType) : void 0;
      }
      var prevErrorsByKey = prevRecord[ERRORS_KEY];
      var nextErrorsByKey = nextRecord[ERRORS_KEY];
      var updated = null;
      if (prevErrorsByKey == null && nextErrorsByKey == null) {
        var _updated;
        for (var storageKey in nextRecord) {
          if (updated || !areEqual(prevRecord[storageKey], nextRecord[storageKey])) {
            updated = updated !== null ? updated : (0, _objectSpread2["default"])({}, prevRecord);
            updated[storageKey] = nextRecord[storageKey];
          }
        }
        return (_updated = updated) !== null && _updated !== void 0 ? _updated : prevRecord;
      }
      for (var _storageKey2 in nextRecord) {
        if (_storageKey2 === ERRORS_KEY) {
          continue;
        }
        var nextValue = nextRecord[_storageKey2];
        var nextErrors = nextErrorsByKey === null || nextErrorsByKey === void 0 ? void 0 : nextErrorsByKey[_storageKey2];
        if (updated == null) {
          var prevValue = prevRecord[_storageKey2];
          var prevErrors = prevErrorsByKey === null || prevErrorsByKey === void 0 ? void 0 : prevErrorsByKey[_storageKey2];
          if (areEqual(prevValue, nextValue) && areEqual(prevErrors, nextErrors)) {
            continue;
          }
          updated = (0, _objectSpread2["default"])({}, prevRecord);
          if (prevErrorsByKey != null) {
            updated[ERRORS_KEY] = (0, _objectSpread2["default"])({}, prevErrorsByKey);
          }
        }
        setValue(updated, _storageKey2, nextValue);
        setErrors(updated, _storageKey2, nextErrors);
      }
      return (_updated2 = updated) !== null && _updated2 !== void 0 ? _updated2 : prevRecord;
    }
    function merge(record1, record2) {
      if (true) {
        var _getType3, _getType4;
        var prevID = getDataID(record1);
        var nextID = getDataID(record2);
        true ? warning(prevID === nextID, "RelayModernRecord: Invalid record merge, expected both versions of the record to have the same id, got `%s` and `%s`.", prevID, nextID) : void 0;
        var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;
        var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;
        true ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, "RelayModernRecord: Invalid record merge, expected both versions of record `%s` to have the same `%s` but got conflicting types `%s` and `%s`. The GraphQL server likely violated the globally unique id requirement by returning the same id for different objects.", prevID, TYPENAME_KEY, prevType, nextType) : void 0;
      }
      if (ERRORS_KEY in record1 || ERRORS_KEY in record2) {
        var errors1 = record1[ERRORS_KEY], fields1 = (0, _objectWithoutPropertiesLoose2["default"])(record1, [ERRORS_KEY].map(_toPropertyKey2["default"]));
        var errors2 = record2[ERRORS_KEY], fields2 = (0, _objectWithoutPropertiesLoose2["default"])(record2, [ERRORS_KEY].map(_toPropertyKey2["default"]));
        var updated = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fields1), fields2);
        if (errors1 == null && errors2 == null) {
          return updated;
        }
        var updatedErrors = {};
        for (var storageKey in errors1) {
          if (fields2.hasOwnProperty(storageKey)) {
            continue;
          }
          updatedErrors[storageKey] = errors1[storageKey];
        }
        for (var _storageKey3 in errors2) {
          updatedErrors[_storageKey3] = errors2[_storageKey3];
        }
        for (var _storageKey in updatedErrors) {
          updated[ERRORS_KEY] = updatedErrors;
          break;
        }
        return updated;
      } else {
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, record1), record2);
      }
    }
    function freeze(record) {
      deepFreeze(record);
    }
    function setErrors(record, storageKey, errors) {
      if (true) {
        true ? warning(storageKey in record, "RelayModernRecord: Invalid error update, `%s` should not be undefined.", storageKey) : void 0;
      }
      var errorsByStorageKey = record[ERRORS_KEY];
      if (errors != null && errors.length > 0) {
        if (errorsByStorageKey == null) {
          record[ERRORS_KEY] = (0, _defineProperty2["default"])({}, storageKey, errors);
        } else {
          errorsByStorageKey[storageKey] = errors;
        }
      } else if (errorsByStorageKey != null) {
        if (delete errorsByStorageKey[storageKey]) {
          for (var otherStorageKey in errorsByStorageKey) {
            if (errorsByStorageKey.hasOwnProperty(otherStorageKey)) {
              return;
            }
          }
          delete record[ERRORS_KEY];
        }
      }
    }
    function setValue(record, storageKey, value) {
      if (true) {
        var prevID = getDataID(record);
        if (storageKey === ID_KEY) {
          true ? warning(prevID === value, "RelayModernRecord: Invalid field update, expected both versions of the record to have the same id, got `%s` and `%s`.", prevID, value) : void 0;
        } else if (storageKey === TYPENAME_KEY) {
          var _getType5;
          var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;
          var nextType = value !== null && value !== void 0 ? value : null;
          true ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, "RelayModernRecord: Invalid field update, expected both versions of record `%s` to have the same `%s` but got conflicting types `%s` and `%s`. The GraphQL server likely violated the globally unique id requirement by returning the same id for different objects.", prevID, TYPENAME_KEY, prevType, nextType) : void 0;
        }
      }
      record[storageKey] = value;
    }
    function setLinkedRecordID(record, storageKey, linkedID) {
      var link = {};
      link[REF_KEY] = linkedID;
      record[storageKey] = link;
    }
    function setLinkedRecordIDs(record, storageKey, linkedIDs) {
      var links = {};
      links[REFS_KEY] = linkedIDs;
      record[storageKey] = links;
    }
    function setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {
      var link = {};
      link[REF_KEY] = linkedID;
      link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;
      record[storageKey] = link;
    }
    function getActorLinkedRecordID(record, storageKey) {
      var link = record[storageKey];
      if (link == null) {
        return link;
      }
      !(typeof link === "object" && typeof link[REF_KEY] === "string" && link[ACTOR_IDENTIFIER_KEY] != null) ? true ? invariant(false, "RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, was `%s`.", record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;
      return [link[ACTOR_IDENTIFIER_KEY], link[REF_KEY]];
    }
    function getResolverLinkedRecordID(record, typeName) {
      var id = getValue(record, RELAY_RESOLVER_VALUE_KEY);
      if (id == null || isSuspenseSentinel(id)) {
        return null;
      }
      if (typeof id === "object") {
        id = id.id;
      }
      !(typeof id === "string") ? true ? invariant(false, "RelayModernRecord.getResolverLinkedRecordID(): Expected value to be a linked ID, was `%s`.", JSON.stringify(id)) : invariant(false) : void 0;
      return generateClientObjectClientID(typeName, id);
    }
    function getResolverLinkedRecordIDs(record, typeName) {
      var resolverValue = getValue(record, RELAY_RESOLVER_VALUE_KEY);
      if (resolverValue == null || isSuspenseSentinel(resolverValue)) {
        return null;
      }
      !Array.isArray(resolverValue) ? true ? invariant(false, "RelayModernRecord.getResolverLinkedRecordIDs(): Expected value to be an array of linked IDs, was `%s`.", JSON.stringify(resolverValue)) : invariant(false) : void 0;
      return resolverValue.map(function(id) {
        if (id == null) {
          return null;
        }
        if (typeof id === "object") {
          id = id.id;
        }
        !(typeof id === "string") ? true ? invariant(false, "RelayModernRecord.getResolverLinkedRecordIDs(): Expected item within resolver linked field to be a DataID, was `%s`.", JSON.stringify(id)) : invariant(false) : void 0;
        return generateClientObjectClientID(typeName, id);
      });
    }
    function toJSON(record) {
      return record;
    }
    module.exports = {
      clone,
      copyFields,
      create,
      freeze,
      fromObject,
      getDataID,
      getErrors,
      getFields,
      getInvalidationEpoch,
      getLinkedRecordID,
      getLinkedRecordIDs,
      getType,
      getValue,
      hasValue,
      hasLinkedRecordID,
      hasLinkedRecordIDs,
      merge,
      setErrors,
      setValue,
      setLinkedRecordID,
      setLinkedRecordIDs,
      update,
      getActorLinkedRecordID,
      setActorLinkedRecordID,
      getResolverLinkedRecordID,
      getResolverLinkedRecordIDs,
      toJSON
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayRecordState.js
var require_RelayRecordState = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayRecordState.js"(exports, module) {
    "use strict";
    var RelayRecordState = {
      EXISTENT: "EXISTENT",
      NONEXISTENT: "NONEXISTENT",
      UNKNOWN: "UNKNOWN"
    };
    module.exports = RelayRecordState;
  }
});

// node_modules/relay-runtime/lib/store/RelayRecordSource.js
var require_RelayRecordSource = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayRecordSource.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var RelayModernRecord = require_RelayModernRecord();
    var RelayRecordState = require_RelayRecordState();
    var EXISTENT = RelayRecordState.EXISTENT;
    var NONEXISTENT = RelayRecordState.NONEXISTENT;
    var UNKNOWN = RelayRecordState.UNKNOWN;
    var RelayRecordSource = function() {
      function RelayRecordSource2(records) {
        var _this = this;
        this._records = /* @__PURE__ */ new Map();
        if (records != null) {
          Object.keys(records).forEach(function(key) {
            var object = records[key];
            var record = RelayModernRecord.fromObject(object);
            _this._records.set(key, record);
          });
        }
      }
      RelayRecordSource2.create = function create(records) {
        return new RelayRecordSource2(records);
      };
      var _proto = RelayRecordSource2.prototype;
      _proto.clear = function clear() {
        this._records = /* @__PURE__ */ new Map();
      };
      _proto["delete"] = function _delete(dataID) {
        this._records.set(dataID, null);
      };
      _proto.get = function get(dataID) {
        return this._records.get(dataID);
      };
      _proto.getRecordIDs = function getRecordIDs() {
        return Array.from(this._records.keys());
      };
      _proto.getStatus = function getStatus(dataID) {
        if (!this._records.has(dataID)) {
          return UNKNOWN;
        }
        return this._records.get(dataID) == null ? NONEXISTENT : EXISTENT;
      };
      _proto.has = function has(dataID) {
        return this._records.has(dataID);
      };
      _proto.remove = function remove(dataID) {
        this._records["delete"](dataID);
      };
      _proto.set = function set(dataID, record) {
        this._records.set(dataID, record);
      };
      _proto.size = function size() {
        return this._records.size;
      };
      _proto.toJSON = function toJSON() {
        var obj = {};
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._records), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _step.value, key = _step$value[0], record = _step$value[1];
            obj[key] = RelayModernRecord.toJSON(record);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return obj;
      };
      return RelayRecordSource2;
    }();
    module.exports = RelayRecordSource;
  }
});

// node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js
var require_ActorIdentifier = __commonJS({
  "node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js"(exports, module) {
    "use strict";
    var invariant = require_browser();
    var INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = "INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE";
    function assertInternalActorIdentifier(actorIdentifier) {
      !(actorIdentifier === INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE) ? true ? invariant(false, 'Expected to use only internal version of the `actorIdentifier`. "%s" was provided.', actorIdentifier) : invariant(false) : void 0;
    }
    module.exports = {
      assertInternalActorIdentifier,
      getActorIdentifier: function getActorIdentifier(actorID) {
        return actorID;
      },
      getDefaultActorIdentifier: function getDefaultActorIdentifier() {
        throw new Error("Not Implemented");
      },
      INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE
    };
  }
});

// node_modules/relay-runtime/lib/multi-actor-environment/ActorUtils.js
var require_ActorUtils = __commonJS({
  "node_modules/relay-runtime/lib/multi-actor-environment/ActorUtils.js"(exports, module) {
    "use strict";
    var ACTOR_IDENTIFIER_FIELD_NAME = "actor_key";
    var _require = require_ActorIdentifier();
    var getActorIdentifier = _require.getActorIdentifier;
    function getActorIdentifierFromPayload(payload) {
      if (payload != null && typeof payload === "object" && typeof payload[ACTOR_IDENTIFIER_FIELD_NAME] === "string") {
        return getActorIdentifier(payload[ACTOR_IDENTIFIER_FIELD_NAME]);
      }
    }
    module.exports = {
      ACTOR_IDENTIFIER_FIELD_NAME,
      getActorIdentifierFromPayload
    };
  }
});

// node_modules/relay-runtime/lib/store/TypeID.js
var require_TypeID = __commonJS({
  "node_modules/relay-runtime/lib/store/TypeID.js"(exports, module) {
    "use strict";
    var PREFIX = "client:__type:";
    var TYPE_SCHEMA_TYPE = "__TypeSchema";
    function generateTypeID(typeName) {
      return PREFIX + typeName;
    }
    function isTypeID(id) {
      return id.indexOf(PREFIX) === 0;
    }
    module.exports = {
      generateTypeID,
      isTypeID,
      TYPE_SCHEMA_TYPE
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js
var require_RelayResponseNormalizer = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _require = require_ActorUtils();
    var ACTOR_IDENTIFIER_FIELD_NAME = _require.ACTOR_IDENTIFIER_FIELD_NAME;
    var getActorIdentifierFromPayload = _require.getActorIdentifierFromPayload;
    var _require2 = require_ClientID();
    var generateClientID = _require2.generateClientID;
    var isClientID = _require2.isClientID;
    var _require3 = require_RelayConcreteVariables();
    var getLocalVariables = _require3.getLocalVariables;
    var _require4 = require_RelayErrorTrie();
    var buildErrorTrie = _require4.buildErrorTrie;
    var getErrorsByKey = _require4.getErrorsByKey;
    var getNestedErrorTrieByKey = _require4.getNestedErrorTrieByKey;
    var RelayModernRecord = require_RelayModernRecord();
    var _require5 = require_RelayModernSelector();
    var createNormalizationSelector = _require5.createNormalizationSelector;
    var _require6 = require_RelayStoreUtils();
    var ROOT_ID = _require6.ROOT_ID;
    var TYPENAME_KEY = _require6.TYPENAME_KEY;
    var getArgumentValues = _require6.getArgumentValues;
    var getHandleStorageKey = _require6.getHandleStorageKey;
    var getModuleComponentKey = _require6.getModuleComponentKey;
    var getModuleOperationKey = _require6.getModuleOperationKey;
    var getStorageKey = _require6.getStorageKey;
    var _require7 = require_TypeID();
    var TYPE_SCHEMA_TYPE = _require7.TYPE_SCHEMA_TYPE;
    var generateTypeID = _require7.generateTypeID;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    var warning = require_warning();
    function normalize(recordSource, selector, response, options, errors) {
      var dataID = selector.dataID, node = selector.node, variables = selector.variables;
      var normalizer = new RelayResponseNormalizer(recordSource, variables, options);
      return normalizer.normalizeResponse(node, dataID, response, errors);
    }
    var RelayResponseNormalizer = function() {
      function RelayResponseNormalizer2(recordSource, variables, options) {
        this._actorIdentifier = options.actorIdentifier;
        this._getDataId = options.getDataID;
        this._handleFieldPayloads = [];
        this._treatMissingFieldsAsNull = options.treatMissingFieldsAsNull;
        this._incrementalPlaceholders = [];
        this._isClientExtension = false;
        this._isUnmatchedAbstractType = false;
        this._followupPayloads = [];
        this._path = options.path ? (0, _toConsumableArray2["default"])(options.path) : [];
        this._recordSource = recordSource;
        this._variables = variables;
        this._shouldProcessClientComponents = options.shouldProcessClientComponents;
      }
      var _proto = RelayResponseNormalizer2.prototype;
      _proto.normalizeResponse = function normalizeResponse(node, dataID, data, errors) {
        var record = this._recordSource.get(dataID);
        !record ? true ? invariant(false, "RelayResponseNormalizer(): Expected root record `%s` to exist.", dataID) : invariant(false) : void 0;
        this._assignClientAbstractTypes(node);
        this._errorTrie = buildErrorTrie(errors);
        this._traverseSelections(node, record, data);
        return {
          errors,
          fieldPayloads: this._handleFieldPayloads,
          incrementalPlaceholders: this._incrementalPlaceholders,
          followupPayloads: this._followupPayloads,
          source: this._recordSource,
          isFinal: false
        };
      };
      _proto._assignClientAbstractTypes = function _assignClientAbstractTypes(node) {
        var clientAbstractTypes = node.clientAbstractTypes;
        if (clientAbstractTypes != null) {
          for (var _i = 0, _Object$keys = Object.keys(clientAbstractTypes); _i < _Object$keys.length; _i++) {
            var abstractType = _Object$keys[_i];
            var _iterator = (0, _createForOfIteratorHelper2["default"])(clientAbstractTypes[abstractType]), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var concreteType = _step.value;
                var typeID = generateTypeID(concreteType);
                var typeRecord = this._recordSource.get(typeID);
                if (typeRecord == null) {
                  typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);
                  this._recordSource.set(typeID, typeRecord);
                }
                RelayModernRecord.setValue(typeRecord, abstractType, true);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }
      };
      _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? true ? invariant(false, "RelayResponseNormalizer(): Undefined variable `%s`.", name) : invariant(false) : void 0;
        return this._variables[name];
      };
      _proto._getRecordType = function _getRecordType(data) {
        var typeName = data[TYPENAME_KEY];
        !(typeName != null) ? true ? invariant(false, "RelayResponseNormalizer(): Expected a typename for record `%s`.", JSON.stringify(data, null, 2)) : invariant(false) : void 0;
        return typeName;
      };
      _proto._traverseSelections = function _traverseSelections(node, record, data) {
        for (var i = 0; i < node.selections.length; i++) {
          var selection = node.selections[i];
          switch (selection.kind) {
            case "ScalarField":
            case "LinkedField":
              this._normalizeField(selection, record, data);
              break;
            case "Condition":
              var conditionValue = Boolean(this._getVariableValue(selection.condition));
              if (conditionValue === selection.passingValue) {
                this._traverseSelections(selection, record, data);
              }
              break;
            case "FragmentSpread": {
              var prevVariables = this._variables;
              this._variables = getLocalVariables(this._variables, selection.fragment.argumentDefinitions, selection.args);
              this._traverseSelections(selection.fragment, record, data);
              this._variables = prevVariables;
              break;
            }
            case "InlineFragment": {
              var abstractKey = selection.abstractKey;
              if (abstractKey == null) {
                var typeName = RelayModernRecord.getType(record);
                if (typeName === selection.type) {
                  this._traverseSelections(selection, record, data);
                }
              } else {
                var implementsInterface = data.hasOwnProperty(abstractKey);
                var _typeName = RelayModernRecord.getType(record);
                var typeID = generateTypeID(_typeName);
                var typeRecord = this._recordSource.get(typeID);
                if (typeRecord == null) {
                  typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);
                  this._recordSource.set(typeID, typeRecord);
                }
                RelayModernRecord.setValue(typeRecord, abstractKey, implementsInterface);
                if (implementsInterface) {
                  this._traverseSelections(selection, record, data);
                }
              }
              break;
            }
            case "TypeDiscriminator": {
              var _abstractKey = selection.abstractKey;
              var _implementsInterface = data.hasOwnProperty(_abstractKey);
              var _typeName2 = RelayModernRecord.getType(record);
              var _typeID = generateTypeID(_typeName2);
              var _typeRecord = this._recordSource.get(_typeID);
              if (_typeRecord == null) {
                _typeRecord = RelayModernRecord.create(_typeID, TYPE_SCHEMA_TYPE);
                this._recordSource.set(_typeID, _typeRecord);
              }
              RelayModernRecord.setValue(_typeRecord, _abstractKey, _implementsInterface);
              break;
            }
            case "LinkedHandle":
            case "ScalarHandle":
              var args = selection.args ? getArgumentValues(selection.args, this._variables) : {};
              var fieldKey = getStorageKey(selection, this._variables);
              var handleKey = getHandleStorageKey(selection, this._variables);
              this._handleFieldPayloads.push({
                args,
                dataID: RelayModernRecord.getDataID(record),
                fieldKey,
                handle: selection.handle,
                handleKey,
                handleArgs: selection.handleArgs ? getArgumentValues(selection.handleArgs, this._variables) : {}
              });
              break;
            case "ModuleImport":
              this._normalizeModuleImport(selection, record, data);
              break;
            case "Defer":
              this._normalizeDefer(selection, record, data);
              break;
            case "Stream":
              this._normalizeStream(selection, record, data);
              break;
            case "ClientExtension":
              var isClientExtension = this._isClientExtension;
              this._isClientExtension = true;
              this._traverseSelections(selection, record, data);
              this._isClientExtension = isClientExtension;
              break;
            case "ClientComponent":
              if (this._shouldProcessClientComponents === false) {
                break;
              }
              this._traverseSelections(selection.fragment, record, data);
              break;
            case "ActorChange":
              this._normalizeActorChange(selection, record, data);
              break;
            case "RelayResolver":
              this._normalizeResolver(selection, record, data);
              break;
            case "RelayLiveResolver":
              this._normalizeResolver(selection, record, data);
              break;
            case "ClientEdgeToClientObject":
              this._normalizeResolver(selection.backingField, record, data);
              break;
            default:
              selection;
              true ? true ? invariant(false, "RelayResponseNormalizer(): Unexpected ast kind `%s`.", selection.kind) : invariant(false) : void 0;
          }
        }
      };
      _proto._normalizeResolver = function _normalizeResolver(resolver, record, data) {
        if (resolver.fragment != null) {
          this._traverseSelections(resolver.fragment, record, data);
        }
      };
      _proto._normalizeDefer = function _normalizeDefer(defer, record, data) {
        var isDeferred = defer["if"] === null || this._getVariableValue(defer["if"]);
        if (true) {
          true ? warning(typeof isDeferred === "boolean", "RelayResponseNormalizer: Expected value for @defer `if` argument to be a boolean, got `%s`.", isDeferred) : void 0;
        }
        if (isDeferred === false) {
          this._traverseSelections(defer, record, data);
        } else {
          this._incrementalPlaceholders.push({
            kind: "defer",
            data,
            label: defer.label,
            path: (0, _toConsumableArray2["default"])(this._path),
            selector: createNormalizationSelector(defer, RelayModernRecord.getDataID(record), this._variables),
            typeName: RelayModernRecord.getType(record),
            actorIdentifier: this._actorIdentifier
          });
        }
      };
      _proto._normalizeStream = function _normalizeStream(stream, record, data) {
        this._traverseSelections(stream, record, data);
        var isStreamed = stream["if"] === null || this._getVariableValue(stream["if"]);
        if (true) {
          true ? warning(typeof isStreamed === "boolean", "RelayResponseNormalizer: Expected value for @stream `if` argument to be a boolean, got `%s`.", isStreamed) : void 0;
        }
        if (isStreamed === true) {
          this._incrementalPlaceholders.push({
            kind: "stream",
            label: stream.label,
            path: (0, _toConsumableArray2["default"])(this._path),
            parentID: RelayModernRecord.getDataID(record),
            node: stream,
            variables: this._variables,
            actorIdentifier: this._actorIdentifier
          });
        }
      };
      _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImport, record, data) {
        !(typeof data === "object" && data) ? true ? invariant(false, "RelayResponseNormalizer: Expected data for @module to be an object.") : invariant(false) : void 0;
        var typeName = RelayModernRecord.getType(record);
        var componentKey = getModuleComponentKey(moduleImport.documentName);
        var componentReference = moduleImport.componentModuleProvider || data[componentKey];
        RelayModernRecord.setValue(record, componentKey, componentReference !== null && componentReference !== void 0 ? componentReference : null);
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = moduleImport.operationModuleProvider || data[operationKey];
        RelayModernRecord.setValue(record, operationKey, operationReference !== null && operationReference !== void 0 ? operationReference : null);
        if (operationReference != null) {
          this._followupPayloads.push({
            kind: "ModuleImportPayload",
            args: moduleImport.args,
            data,
            dataID: RelayModernRecord.getDataID(record),
            operationReference,
            path: (0, _toConsumableArray2["default"])(this._path),
            typeName,
            variables: this._variables,
            actorIdentifier: this._actorIdentifier
          });
        }
      };
      _proto._normalizeField = function _normalizeField(selection, record, data) {
        !(typeof data === "object" && data) ? true ? invariant(false, "writeField(): Expected data for field `%s` to be an object.", selection.name) : invariant(false) : void 0;
        var responseKey = selection.alias || selection.name;
        var storageKey = getStorageKey(selection, this._variables);
        var fieldValue = data[responseKey];
        if (fieldValue == null) {
          if (fieldValue === void 0) {
            var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;
            if (isOptionalField) {
              return;
            } else if (!this._treatMissingFieldsAsNull) {
              if (true) {
                true ? warning(false, "RelayResponseNormalizer: Payload did not contain a value for field `%s: %s`. Check that you are parsing with the same query that was used to fetch the payload.", responseKey, storageKey) : void 0;
              }
              return;
            }
          }
          if (true) {
            if (selection.kind === "ScalarField") {
              this._validateConflictingFieldsWithIdenticalId(record, storageKey, null);
            }
          }
          RelayModernRecord.setValue(record, storageKey, null);
          var errorTrie = this._errorTrie;
          if (errorTrie != null) {
            var errors = getErrorsByKey(errorTrie, responseKey);
            if (errors != null) {
              RelayModernRecord.setErrors(record, storageKey, errors);
            }
          }
          return;
        }
        if (selection.kind === "ScalarField") {
          if (true) {
            this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);
          }
          RelayModernRecord.setValue(record, storageKey, fieldValue);
        } else if (selection.kind === "LinkedField") {
          this._path.push(responseKey);
          var oldErrorTrie = this._errorTrie;
          this._errorTrie = oldErrorTrie == null ? null : getNestedErrorTrieByKey(oldErrorTrie, responseKey);
          if (selection.plural) {
            this._normalizePluralLink(selection, record, storageKey, fieldValue);
          } else {
            this._normalizeLink(selection, record, storageKey, fieldValue);
          }
          this._errorTrie = oldErrorTrie;
          this._path.pop();
        } else {
          selection;
          true ? true ? invariant(false, "RelayResponseNormalizer(): Unexpected ast kind `%s` during normalization.", selection.kind) : invariant(false) : void 0;
        }
      };
      _proto._normalizeActorChange = function _normalizeActorChange(selection, record, data) {
        var _field$concreteType;
        var field = selection.linkedField;
        !(typeof data === "object" && data) ? true ? invariant(false, "_normalizeActorChange(): Expected data for field `%s` to be an object.", field.name) : invariant(false) : void 0;
        var responseKey = field.alias || field.name;
        var storageKey = getStorageKey(field, this._variables);
        var fieldValue = data[responseKey];
        if (fieldValue == null) {
          if (fieldValue === void 0) {
            var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;
            if (isOptionalField) {
              return;
            } else if (!this._treatMissingFieldsAsNull) {
              if (true) {
                true ? warning(false, "RelayResponseNormalizer: Payload did not contain a value for field `%s: %s`. Check that you are parsing with the same query that was used to fetch the payload.", responseKey, storageKey) : void 0;
              }
              return;
            }
          }
          RelayModernRecord.setValue(record, storageKey, null);
          return;
        }
        var actorIdentifier = getActorIdentifierFromPayload(fieldValue);
        if (actorIdentifier == null) {
          if (true) {
            true ? warning(false, "RelayResponseNormalizer: Payload did not contain a value for field `%s`. Check that you are parsing with the same query that was used to fetch the payload. Payload is `%s`.", ACTOR_IDENTIFIER_FIELD_NAME, JSON.stringify(fieldValue, null, 2)) : void 0;
          }
          RelayModernRecord.setValue(record, storageKey, null);
          return;
        }
        var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : this._getRecordType(fieldValue);
        var nextID = this._getDataId(fieldValue, typeName) || RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);
        !(typeof nextID === "string") ? true ? invariant(false, "RelayResponseNormalizer: Expected id on field `%s` to be a string.", storageKey) : invariant(false) : void 0;
        RelayModernRecord.setActorLinkedRecordID(record, storageKey, actorIdentifier, nextID);
        this._followupPayloads.push({
          kind: "ActorPayload",
          data: fieldValue,
          dataID: nextID,
          path: [].concat((0, _toConsumableArray2["default"])(this._path), [responseKey]),
          typeName,
          variables: this._variables,
          node: field,
          actorIdentifier
        });
      };
      _proto._normalizeLink = function _normalizeLink(field, record, storageKey, fieldValue) {
        var _field$concreteType2;
        !(typeof fieldValue === "object" && fieldValue) ? true ? invariant(false, "RelayResponseNormalizer: Expected data for field `%s` to be an object.", storageKey) : invariant(false) : void 0;
        var nextID = this._getDataId(fieldValue, (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : this._getRecordType(fieldValue)) || RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);
        !(typeof nextID === "string") ? true ? invariant(false, "RelayResponseNormalizer: Expected id on field `%s` to be a string.", storageKey) : invariant(false) : void 0;
        if (true) {
          this._validateConflictingLinkedFieldsWithIdenticalId(RelayModernRecord.getLinkedRecordID(record, storageKey), nextID, storageKey);
        }
        RelayModernRecord.setLinkedRecordID(record, storageKey, nextID);
        var nextRecord = this._recordSource.get(nextID);
        if (!nextRecord) {
          var typeName = field.concreteType || this._getRecordType(fieldValue);
          nextRecord = RelayModernRecord.create(nextID, typeName);
          this._recordSource.set(nextID, nextRecord);
        } else if (true) {
          this._validateRecordType(nextRecord, field, fieldValue);
        }
        this._traverseSelections(field, nextRecord, fieldValue);
      };
      _proto._normalizePluralLink = function _normalizePluralLink(field, record, storageKey, fieldValue) {
        var _this = this;
        !Array.isArray(fieldValue) ? true ? invariant(false, "RelayResponseNormalizer: Expected data for field `%s` to be an array of objects.", storageKey) : invariant(false) : void 0;
        var prevIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        var nextIDs = [];
        fieldValue.forEach(function(item, nextIndex) {
          var _field$concreteType3;
          if (item == null) {
            nextIDs.push(item);
            return;
          }
          _this._path.push(String(nextIndex));
          var oldErrorTrie = _this._errorTrie;
          _this._errorTrie = oldErrorTrie == null ? null : getNestedErrorTrieByKey(oldErrorTrie, nextIndex);
          !(typeof item === "object") ? true ? invariant(false, "RelayResponseNormalizer: Expected elements for field `%s` to be objects.", storageKey) : invariant(false) : void 0;
          var nextID = _this._getDataId(item, (_field$concreteType3 = field.concreteType) !== null && _field$concreteType3 !== void 0 ? _field$concreteType3 : _this._getRecordType(item)) || prevIDs && prevIDs[nextIndex] || generateClientID(RelayModernRecord.getDataID(record), storageKey, nextIndex);
          !(typeof nextID === "string") ? true ? invariant(false, "RelayResponseNormalizer: Expected id of elements of field `%s` to be strings.", storageKey) : invariant(false) : void 0;
          nextIDs.push(nextID);
          var nextRecord = _this._recordSource.get(nextID);
          if (!nextRecord) {
            var typeName = field.concreteType || _this._getRecordType(item);
            nextRecord = RelayModernRecord.create(nextID, typeName);
            _this._recordSource.set(nextID, nextRecord);
          } else if (true) {
            _this._validateRecordType(nextRecord, field, item);
          }
          if (true) {
            if (prevIDs) {
              _this._validateConflictingLinkedFieldsWithIdenticalId(prevIDs[nextIndex], nextID, storageKey);
            }
          }
          _this._traverseSelections(field, nextRecord, item);
          _this._errorTrie = oldErrorTrie;
          _this._path.pop();
        });
        RelayModernRecord.setLinkedRecordIDs(record, storageKey, nextIDs);
      };
      _proto._validateRecordType = function _validateRecordType(record, field, payload) {
        var _field$concreteType4;
        var typeName = (_field$concreteType4 = field.concreteType) !== null && _field$concreteType4 !== void 0 ? _field$concreteType4 : this._getRecordType(payload);
        var dataID = RelayModernRecord.getDataID(record);
        true ? warning(isClientID(dataID) && dataID !== ROOT_ID || RelayModernRecord.getType(record) === typeName, "RelayResponseNormalizer: Invalid record `%s`. Expected %s to be consistent, but the record was assigned conflicting types `%s` and `%s`. The GraphQL server likely violated the globally unique id requirement by returning the same id for different objects.", dataID, TYPENAME_KEY, RelayModernRecord.getType(record), typeName) : void 0;
      };
      _proto._validateConflictingFieldsWithIdenticalId = function _validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue) {
        if (true) {
          var dataID = RelayModernRecord.getDataID(record);
          var previousValue = RelayModernRecord.getValue(record, storageKey);
          true ? warning(storageKey === TYPENAME_KEY || previousValue === void 0 || areEqual(previousValue, fieldValue), "RelayResponseNormalizer: Invalid record. The record contains two instances of the same id: `%s` with conflicting field, %s and its values: %s and %s. If two fields are different but share the same id, one field will overwrite the other.", dataID, storageKey, previousValue, fieldValue) : void 0;
        }
      };
      _proto._validateConflictingLinkedFieldsWithIdenticalId = function _validateConflictingLinkedFieldsWithIdenticalId(prevID, nextID, storageKey) {
        if (true) {
          true ? warning(prevID === void 0 || prevID === nextID, "RelayResponseNormalizer: Invalid record. The record contains references to the conflicting field, %s and its id values: %s and %s. We need to make sure that the record the field points to remains consistent or one field will overwrite the other.", storageKey, prevID, nextID) : void 0;
        }
      };
      return RelayResponseNormalizer2;
    }();
    module.exports = {
      normalize
    };
  }
});

// node_modules/relay-runtime/lib/store/normalizeResponse.js
var require_normalizeResponse = __commonJS({
  "node_modules/relay-runtime/lib/store/normalizeResponse.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _RelayModernRecord = _interopRequireDefault(require_RelayModernRecord());
    var _RelayRecordSource = _interopRequireDefault(require_RelayRecordSource());
    var _RelayResponseNormalizer = _interopRequireDefault(require_RelayResponseNormalizer());
    function normalizeResponse(response, selector, typeName, options) {
      var _response$extensions;
      var data = response.data, errors = response.errors;
      var source = _RelayRecordSource["default"].create();
      var record = _RelayModernRecord["default"].create(selector.dataID, typeName);
      source.set(selector.dataID, record);
      var relayPayload = _RelayResponseNormalizer["default"].normalize(source, selector, data, options, errors);
      return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, relayPayload), {}, {
        isFinal: ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.is_final) === true
      });
    }
    module.exports = normalizeResponse;
  }
});

// node_modules/relay-runtime/lib/store/readInlineData.js
var require_readInlineData = __commonJS({
  "node_modules/relay-runtime/lib/store/readInlineData.js"(exports, module) {
    "use strict";
    var _require = require_GraphQLTag();
    var getInlineDataFragment = _require.getInlineDataFragment;
    var _require2 = require_RelayStoreUtils();
    var FRAGMENTS_KEY = _require2.FRAGMENTS_KEY;
    var invariant = require_browser();
    function readInlineData(fragment, fragmentRef) {
      var _fragmentRef$FRAGMENT;
      var inlineDataFragment = getInlineDataFragment(fragment);
      if (fragmentRef == null) {
        return fragmentRef;
      }
      !(typeof fragmentRef === "object") ? true ? invariant(false, "readInlineData(): Expected an object, got `%s`.", typeof fragmentRef) : invariant(false) : void 0;
      var inlineData = (_fragmentRef$FRAGMENT = fragmentRef[FRAGMENTS_KEY]) === null || _fragmentRef$FRAGMENT === void 0 ? void 0 : _fragmentRef$FRAGMENT[inlineDataFragment.name];
      !(inlineData != null) ? true ? invariant(false, "readInlineData(): Expected fragment `%s` to be spread in the parent fragment.", inlineDataFragment.name) : invariant(false) : void 0;
      return inlineData;
    }
    module.exports = readInlineData;
  }
});

// node_modules/relay-runtime/lib/util/generateID.js
var require_generateID = __commonJS({
  "node_modules/relay-runtime/lib/util/generateID.js"(exports, module) {
    "use strict";
    var id = 1e5;
    function generateID() {
      return id++;
    }
    module.exports = generateID;
  }
});

// node_modules/relay-runtime/lib/network/wrapNetworkWithLogObserver.js
var require_wrapNetworkWithLogObserver = __commonJS({
  "node_modules/relay-runtime/lib/network/wrapNetworkWithLogObserver.js"(exports, module) {
    "use strict";
    var generateID = require_generateID();
    function wrapNetworkWithLogObserver(env, network) {
      return {
        execute: function execute(params, variables, cacheConfig, uploadables) {
          var networkRequestId = generateID();
          var logObserver = {
            start: function start(subscription) {
              env.__log({
                name: "network.start",
                networkRequestId,
                params,
                variables,
                cacheConfig
              });
            },
            next: function next(response) {
              env.__log({
                name: "network.next",
                networkRequestId,
                response
              });
            },
            error: function error(_error) {
              env.__log({
                name: "network.error",
                networkRequestId,
                error: _error
              });
            },
            complete: function complete() {
              env.__log({
                name: "network.complete",
                networkRequestId
              });
            },
            unsubscribe: function unsubscribe() {
              env.__log({
                name: "network.unsubscribe",
                networkRequestId
              });
            }
          };
          var logRequestInfo = function logRequestInfo2(info) {
            env.__log({
              name: "network.info",
              networkRequestId,
              info
            });
          };
          return network.execute(params, variables, cacheConfig, uploadables, logRequestInfo)["do"](logObserver);
        }
      };
    }
    module.exports = wrapNetworkWithLogObserver;
  }
});

// node_modules/relay-runtime/lib/store/RelayOperationTracker.js
var require_RelayOperationTracker = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayOperationTracker.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var invariant = require_browser();
    var RelayOperationTracker = function() {
      function RelayOperationTracker2() {
        this._ownersToPendingOperations = /* @__PURE__ */ new Map();
        this._pendingOperationsToOwners = /* @__PURE__ */ new Map();
        this._ownersToPendingPromise = /* @__PURE__ */ new Map();
      }
      var _proto = RelayOperationTracker2.prototype;
      _proto.update = function update(pendingOperation, affectedOwners) {
        if (affectedOwners.size === 0) {
          return;
        }
        var pendingOperationIdentifier = pendingOperation.identifier;
        var newlyAffectedOwnersIdentifier = /* @__PURE__ */ new Set();
        var _iterator = (0, _createForOfIteratorHelper2["default"])(affectedOwners), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var owner = _step.value;
            var ownerIdentifier = owner.identifier;
            var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(ownerIdentifier);
            if (pendingOperationsAffectingOwner != null) {
              if (!pendingOperationsAffectingOwner.has(pendingOperationIdentifier)) {
                pendingOperationsAffectingOwner.set(pendingOperationIdentifier, pendingOperation);
                newlyAffectedOwnersIdentifier.add(ownerIdentifier);
              }
            } else {
              this._ownersToPendingOperations.set(ownerIdentifier, /* @__PURE__ */ new Map([[pendingOperationIdentifier, pendingOperation]]));
              newlyAffectedOwnersIdentifier.add(ownerIdentifier);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (newlyAffectedOwnersIdentifier.size === 0) {
          return;
        }
        var ownersAffectedByPendingOperation = this._pendingOperationsToOwners.get(pendingOperationIdentifier) || /* @__PURE__ */ new Set();
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(newlyAffectedOwnersIdentifier), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _ownerIdentifier = _step2.value;
            this._resolveOwnerResolvers(_ownerIdentifier);
            ownersAffectedByPendingOperation.add(_ownerIdentifier);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this._pendingOperationsToOwners.set(pendingOperationIdentifier, ownersAffectedByPendingOperation);
      };
      _proto.complete = function complete(pendingOperation) {
        var pendingOperationIdentifier = pendingOperation.identifier;
        var affectedOwnersIdentifier = this._pendingOperationsToOwners.get(pendingOperationIdentifier);
        if (affectedOwnersIdentifier == null) {
          return;
        }
        var completedOwnersIdentifier = /* @__PURE__ */ new Set();
        var updatedOwnersIdentifier = /* @__PURE__ */ new Set();
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(affectedOwnersIdentifier), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var ownerIdentifier = _step3.value;
            var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(ownerIdentifier);
            if (!pendingOperationsAffectingOwner) {
              continue;
            }
            pendingOperationsAffectingOwner["delete"](pendingOperationIdentifier);
            if (pendingOperationsAffectingOwner.size > 0) {
              updatedOwnersIdentifier.add(ownerIdentifier);
            } else {
              completedOwnersIdentifier.add(ownerIdentifier);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(completedOwnersIdentifier), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _ownerIdentifier2 = _step4.value;
            this._resolveOwnerResolvers(_ownerIdentifier2);
            this._ownersToPendingOperations["delete"](_ownerIdentifier2);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(updatedOwnersIdentifier), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var _ownerIdentifier3 = _step5.value;
            this._resolveOwnerResolvers(_ownerIdentifier3);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        this._pendingOperationsToOwners["delete"](pendingOperationIdentifier);
      };
      _proto._resolveOwnerResolvers = function _resolveOwnerResolvers(ownerIdentifier) {
        var promiseEntry = this._ownersToPendingPromise.get(ownerIdentifier);
        if (promiseEntry != null) {
          promiseEntry.resolve();
        }
        this._ownersToPendingPromise["delete"](ownerIdentifier);
      };
      _proto.getPendingOperationsAffectingOwner = function getPendingOperationsAffectingOwner(owner) {
        var ownerIdentifier = owner.identifier;
        var pendingOperationsForOwner = this._ownersToPendingOperations.get(ownerIdentifier);
        if (pendingOperationsForOwner == null || pendingOperationsForOwner.size === 0) {
          return null;
        }
        var cachedPromiseEntry = this._ownersToPendingPromise.get(ownerIdentifier);
        if (cachedPromiseEntry != null) {
          return {
            promise: cachedPromiseEntry.promise,
            pendingOperations: cachedPromiseEntry.pendingOperations
          };
        }
        var resolve;
        var promise = new Promise(function(r) {
          resolve = r;
        });
        !(resolve != null) ? true ? invariant(false, "RelayOperationTracker: Expected resolver to be defined. If youare seeing this, it is likely a bug in Relay.") : invariant(false) : void 0;
        var pendingOperations = Array.from(pendingOperationsForOwner.values());
        this._ownersToPendingPromise.set(ownerIdentifier, {
          promise,
          resolve,
          pendingOperations
        });
        return {
          promise,
          pendingOperations
        };
      };
      return RelayOperationTracker2;
    }();
    module.exports = RelayOperationTracker;
  }
});

// node_modules/relay-runtime/lib/util/registerEnvironmentWithDevTools.js
var require_registerEnvironmentWithDevTools = __commonJS({
  "node_modules/relay-runtime/lib/util/registerEnvironmentWithDevTools.js"(exports, module) {
    "use strict";
    function registerEnvironmentWithDevTools(environment) {
      var _global = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : void 0;
      var devToolsHook = _global && _global.__RELAY_DEVTOOLS_HOOK__;
      if (devToolsHook) {
        devToolsHook.registerEnvironment(environment);
      }
    }
    module.exports = registerEnvironmentWithDevTools;
  }
});

// node_modules/relay-runtime/lib/store/ViewerPattern.js
var require_ViewerPattern = __commonJS({
  "node_modules/relay-runtime/lib/store/ViewerPattern.js"(exports, module) {
    "use strict";
    var _require = require_ClientID();
    var generateClientID = _require.generateClientID;
    var _require2 = require_RelayStoreUtils();
    var ROOT_ID = _require2.ROOT_ID;
    var VIEWER_ID = generateClientID(ROOT_ID, "viewer");
    var VIEWER_TYPE = "Viewer";
    module.exports = {
      VIEWER_ID,
      VIEWER_TYPE
    };
  }
});

// node_modules/relay-runtime/lib/store/defaultGetDataID.js
var require_defaultGetDataID = __commonJS({
  "node_modules/relay-runtime/lib/store/defaultGetDataID.js"(exports, module) {
    "use strict";
    var _require = require_ViewerPattern();
    var VIEWER_ID = _require.VIEWER_ID;
    var VIEWER_TYPE = _require.VIEWER_TYPE;
    function defaultGetDataID(fieldValue, typeName) {
      if (typeName === VIEWER_TYPE) {
        return fieldValue.id == null ? VIEWER_ID : fieldValue.id;
      }
      return fieldValue.id;
    }
    module.exports = defaultGetDataID;
  }
});

// node_modules/relay-runtime/lib/store/defaultRelayFieldLogger.js
var require_defaultRelayFieldLogger = __commonJS({
  "node_modules/relay-runtime/lib/store/defaultRelayFieldLogger.js"(exports, module) {
    "use strict";
    var defaultRelayFieldLogger = function defaultRelayFieldLogger2(event) {
      if (event.kind === "missing_field.log") {
        throw new Error("Relay Environment Configuration Error (dev only): `@required(action: LOG)` requires that the Relay Environment be configured with a `relayFieldLogger`.");
      }
    };
    module.exports = defaultRelayFieldLogger;
  }
});

// node_modules/relay-runtime/lib/util/getOperation.js
var require_getOperation = __commonJS({
  "node_modules/relay-runtime/lib/util/getOperation.js"(exports, module) {
    "use strict";
    var _require = require_RelayConcreteNode();
    var REQUEST = _require.REQUEST;
    var SPLIT_OPERATION = _require.SPLIT_OPERATION;
    function getOperation(node) {
      switch (node.kind) {
        case REQUEST:
          return node.operation;
        case SPLIT_OPERATION:
        default:
          return node;
      }
    }
    module.exports = getOperation;
  }
});

// node_modules/relay-runtime/lib/util/RelayError.js
var require_RelayError = __commonJS({
  "node_modules/relay-runtime/lib/util/RelayError.js"(exports, module) {
    "use strict";
    function createError(type, name, messageFormat) {
      for (var _len = arguments.length, messageParams = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        messageParams[_key - 3] = arguments[_key];
      }
      var index = 0;
      var message = messageFormat.replace(/%s/g, function() {
        return String(messageParams[index++]);
      });
      var err = new Error(message);
      var error = Object.assign(err, {
        name,
        messageFormat,
        messageParams,
        type,
        taalOpcodes: [2, 2]
      });
      if (error.stack === void 0) {
        try {
          throw error;
        } catch (_unused) {
        }
      }
      return error;
    }
    module.exports = {
      create: function create(name, messageFormat) {
        for (var _len2 = arguments.length, messageParams = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          messageParams[_key2 - 2] = arguments[_key2];
        }
        return createError.apply(void 0, ["error", name, messageFormat].concat(messageParams));
      },
      createWarning: function createWarning(name, messageFormat) {
        for (var _len3 = arguments.length, messageParams = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          messageParams[_key3 - 2] = arguments[_key3];
        }
        return createError.apply(void 0, ["warn", name, messageFormat].concat(messageParams));
      }
    };
  }
});

// node_modules/relay-runtime/lib/util/withStartAndDuration.js
var require_withStartAndDuration = __commonJS({
  "node_modules/relay-runtime/lib/util/withStartAndDuration.js"(exports, module) {
    "use strict";
    var _window;
    var _window$performance;
    var isPerformanceNowAvailable = typeof window !== "undefined" && typeof ((_window = window) === null || _window === void 0 ? void 0 : (_window$performance = _window.performance) === null || _window$performance === void 0 ? void 0 : _window$performance.now) === "function";
    function currentTimestamp() {
      if (isPerformanceNowAvailable) {
        return window.performance.now();
      }
      return Date.now();
    }
    function withStartAndDuration(cb) {
      var startTime = currentTimestamp();
      var result = cb();
      return [startTime, currentTimestamp() - startTime, result];
    }
    module.exports = withStartAndDuration;
  }
});

// node_modules/relay-runtime/lib/store/OperationExecutor.js
var require_OperationExecutor = __commonJS({
  "node_modules/relay-runtime/lib/store/OperationExecutor.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var RelayObservable = require_RelayObservable();
    var generateID = require_generateID();
    var getOperation = require_getOperation();
    var RelayError = require_RelayError();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var _require = require_stableCopy();
    var stableCopy = _require.stableCopy;
    var withStartAndDuration = require_withStartAndDuration();
    var _require2 = require_ClientID();
    var generateClientID = _require2.generateClientID;
    var generateUniqueClientID = _require2.generateUniqueClientID;
    var _require3 = require_RelayConcreteVariables();
    var getLocalVariables = _require3.getLocalVariables;
    var RelayModernRecord = require_RelayModernRecord();
    var _require4 = require_RelayModernSelector();
    var createNormalizationSelector = _require4.createNormalizationSelector;
    var createReaderSelector = _require4.createReaderSelector;
    var RelayRecordSource = require_RelayRecordSource();
    var _require5 = require_RelayStoreUtils();
    var ROOT_TYPE = _require5.ROOT_TYPE;
    var TYPENAME_KEY = _require5.TYPENAME_KEY;
    var getStorageKey = _require5.getStorageKey;
    var invariant = require_browser();
    var warning = require_warning();
    function execute(config) {
      return new Executor(config);
    }
    var Executor = function() {
      function Executor2(_ref2) {
        var _this = this;
        var actorIdentifier = _ref2.actorIdentifier, getDataID = _ref2.getDataID, getPublishQueue = _ref2.getPublishQueue, getStore = _ref2.getStore, isClientPayload = _ref2.isClientPayload, operation = _ref2.operation, operationExecutions = _ref2.operationExecutions, operationLoader = _ref2.operationLoader, operationTracker = _ref2.operationTracker, optimisticConfig = _ref2.optimisticConfig, scheduler = _ref2.scheduler, shouldProcessClientComponents = _ref2.shouldProcessClientComponents, sink = _ref2.sink, source = _ref2.source, treatMissingFieldsAsNull = _ref2.treatMissingFieldsAsNull, updater = _ref2.updater, log = _ref2.log, normalizeResponse = _ref2.normalizeResponse;
        this._actorIdentifier = actorIdentifier;
        this._getDataID = getDataID;
        this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;
        this._incrementalPayloadsPending = false;
        this._incrementalResults = /* @__PURE__ */ new Map();
        this._log = log;
        this._executeId = generateID();
        this._nextSubscriptionId = 0;
        this._operation = operation;
        this._operationExecutions = operationExecutions;
        this._operationLoader = operationLoader;
        this._operationTracker = operationTracker;
        this._operationUpdateEpochs = /* @__PURE__ */ new Map();
        this._optimisticUpdates = null;
        this._pendingModulePayloadsCount = 0;
        this._getPublishQueue = getPublishQueue;
        this._scheduler = scheduler;
        this._sink = sink;
        this._source = /* @__PURE__ */ new Map();
        this._state = "started";
        this._getStore = getStore;
        this._subscriptions = /* @__PURE__ */ new Map();
        this._updater = updater;
        this._isClientPayload = isClientPayload === true;
        this._isSubscriptionOperation = this._operation.request.node.params.operationKind === "subscription";
        this._shouldProcessClientComponents = shouldProcessClientComponents;
        this._retainDisposables = /* @__PURE__ */ new Map();
        this._seenActors = /* @__PURE__ */ new Set();
        this._completeFns = [];
        this._normalizeResponse = normalizeResponse;
        var id = this._nextSubscriptionId++;
        if (RelayFeatureFlags.PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION && optimisticConfig != null) {
          this._processOptimisticResponse(optimisticConfig.response != null ? {
            data: optimisticConfig.response
          } : null, optimisticConfig.updater, false);
        }
        source.subscribe({
          complete: function complete() {
            return _this._complete(id);
          },
          error: function error(_error2) {
            return _this._error(_error2);
          },
          next: function next(response) {
            try {
              _this._next(id, response);
            } catch (error) {
              sink.error(error);
            }
          },
          start: function start(subscription) {
            var _this$_operation$requ;
            _this._start(id, subscription);
            _this._log({
              name: "execute.start",
              executeId: _this._executeId,
              params: _this._operation.request.node.params,
              variables: _this._operation.request.variables,
              cacheConfig: (_this$_operation$requ = _this._operation.request.cacheConfig) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : {}
            });
          }
        });
        if (!RelayFeatureFlags.PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION && optimisticConfig != null) {
          this._processOptimisticResponse(optimisticConfig.response != null ? {
            data: optimisticConfig.response
          } : null, optimisticConfig.updater, false);
        }
      }
      var _proto = Executor2.prototype;
      _proto.cancel = function cancel() {
        var _this2 = this;
        if (this._state === "completed") {
          return;
        }
        this._state = "completed";
        this._operationExecutions["delete"](this._operation.request.identifier);
        if (this._subscriptions.size !== 0) {
          this._subscriptions.forEach(function(sub) {
            return sub.unsubscribe();
          });
          this._subscriptions.clear();
        }
        var optimisticUpdates = this._optimisticUpdates;
        if (optimisticUpdates !== null) {
          this._optimisticUpdates = null;
          optimisticUpdates.forEach(function(update) {
            return _this2._getPublishQueueAndSaveActor().revertUpdate(update);
          });
          this._runPublishQueue();
        }
        this._incrementalResults.clear();
        if (this._asyncStoreUpdateDisposable != null) {
          this._asyncStoreUpdateDisposable.dispose();
          this._asyncStoreUpdateDisposable = null;
        }
        this._completeFns = [];
        this._completeOperationTracker();
        this._disposeRetainedData();
      };
      _proto._updateActiveState = function _updateActiveState() {
        var activeState;
        switch (this._state) {
          case "started": {
            activeState = "active";
            break;
          }
          case "loading_incremental": {
            activeState = "active";
            break;
          }
          case "completed": {
            activeState = "inactive";
            break;
          }
          case "loading_final": {
            activeState = this._pendingModulePayloadsCount > 0 ? "active" : "inactive";
            break;
          }
          default:
            this._state;
            true ? true ? invariant(false, "OperationExecutor: invalid executor state.") : invariant(false) : void 0;
        }
        this._operationExecutions.set(this._operation.request.identifier, activeState);
      };
      _proto._schedule = function _schedule(task) {
        var _this3 = this;
        var scheduler = this._scheduler;
        if (scheduler != null) {
          var id = this._nextSubscriptionId++;
          RelayObservable.create(function(sink) {
            var cancellationToken = scheduler.schedule(function() {
              try {
                task();
                sink.complete();
              } catch (error) {
                sink.error(error);
              }
            });
            return function() {
              return scheduler.cancel(cancellationToken);
            };
          }).subscribe({
            complete: function complete() {
              return _this3._complete(id);
            },
            error: function error(_error3) {
              return _this3._error(_error3);
            },
            start: function start(subscription) {
              return _this3._start(id, subscription);
            }
          });
        } else {
          task();
        }
      };
      _proto._complete = function _complete(id) {
        this._subscriptions["delete"](id);
        if (this._subscriptions.size === 0) {
          this.cancel();
          this._sink.complete();
          this._log({
            name: "execute.complete",
            executeId: this._executeId
          });
        }
      };
      _proto._error = function _error(error) {
        this.cancel();
        this._sink.error(error);
        this._log({
          name: "execute.error",
          executeId: this._executeId,
          error
        });
      };
      _proto._start = function _start(id, subscription) {
        this._subscriptions.set(id, subscription);
        this._updateActiveState();
      };
      _proto._next = function _next(_id, response) {
        var _this4 = this;
        this._schedule(function() {
          _this4._log({
            name: "execute.next.start",
            executeId: _this4._executeId,
            response,
            operation: _this4._operation
          });
          _this4._handleNext(response);
          _this4._maybeCompleteSubscriptionOperationTracking();
          _this4._log({
            name: "execute.next.end",
            executeId: _this4._executeId,
            response,
            operation: _this4._operation
          });
        });
      };
      _proto._handleErrorResponse = function _handleErrorResponse(responses) {
        var _this5 = this;
        var results = [];
        responses.forEach(function(response) {
          if (response.data === null && response.extensions != null && !response.hasOwnProperty("errors")) {
            return;
          } else if (response.data == null) {
            var errors = response.hasOwnProperty("errors") && response.errors != null ? response.errors : null;
            var messages = errors ? errors.map(function(_ref3) {
              var message = _ref3.message;
              return message;
            }).join("\n") : "(No errors)";
            var error = RelayError.create("RelayNetwork", "No data returned for operation `" + _this5._operation.request.node.params.name + "`, got error(s):\n" + messages + "\n\nSee the error `source` property for more information.");
            error.source = {
              errors,
              operation: _this5._operation.request.node,
              variables: _this5._operation.request.variables
            };
            error.stack;
            throw error;
          } else {
            var responseWithData = response;
            results.push(responseWithData);
          }
        });
        return results;
      };
      _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {
        var _response$extensions;
        if (responses.length > 1) {
          if (responses.some(function(responsePart) {
            var _responsePart$extensi;
            return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;
          })) {
            true ? true ? invariant(false, "OperationExecutor: Optimistic responses cannot be batched.") : invariant(false) : void 0;
          }
          return false;
        }
        var response = responses[0];
        var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;
        if (isOptimistic && this._state !== "started") {
          true ? true ? invariant(false, "OperationExecutor: optimistic payload received after server payload.") : invariant(false) : void 0;
        }
        if (isOptimistic) {
          this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);
          this._sink.next(response);
          return true;
        }
        return false;
      };
      _proto._handleNext = function _handleNext(response) {
        if (this._state === "completed") {
          return;
        }
        this._seenActors.clear();
        var responses = Array.isArray(response) ? response : [response];
        var responsesWithData = this._handleErrorResponse(responses);
        if (responsesWithData.length === 0) {
          var isFinal = responses.some(function(x) {
            var _x$extensions;
            return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;
          });
          if (isFinal) {
            this._state = "loading_final";
            this._updateActiveState();
            this._incrementalPayloadsPending = false;
          }
          this._sink.next(response);
          return;
        }
        var isOptimistic = this._handleOptimisticResponses(responsesWithData);
        if (isOptimistic) {
          return;
        }
        var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData), nonIncrementalResponses = _partitionGraphQLResp[0], incrementalResponses = _partitionGraphQLResp[1];
        var hasNonIncrementalResponses = nonIncrementalResponses.length > 0;
        if (hasNonIncrementalResponses) {
          if (this._isSubscriptionOperation) {
            var nextID = generateUniqueClientID();
            this._operation = {
              request: this._operation.request,
              fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),
              root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)
            };
          }
          var payloadFollowups = this._processResponses(nonIncrementalResponses);
          this._processPayloadFollowups(payloadFollowups);
        }
        if (incrementalResponses.length > 0) {
          var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);
          this._processPayloadFollowups(_payloadFollowups);
        }
        if (this._isSubscriptionOperation) {
          if (responsesWithData[0].extensions == null) {
            responsesWithData[0].extensions = {
              __relay_subscription_root_id: this._operation.fragment.dataID
            };
          } else {
            responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;
          }
        }
        var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses ? this._operation : void 0);
        if (hasNonIncrementalResponses) {
          if (this._incrementalPayloadsPending) {
            this._retainData();
          }
        }
        this._updateOperationTracker(updatedOwners);
        this._sink.next(response);
      };
      _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {
        var _this6 = this;
        !(this._optimisticUpdates === null) ? true ? invariant(false, "OperationExecutor: environment.execute: only support one optimistic response per execute.") : invariant(false) : void 0;
        if (response == null && updater == null) {
          return;
        }
        var optimisticUpdates = [];
        if (response) {
          var payload = this._normalizeResponse(response, this._operation.root, ROOT_TYPE, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            path: [],
            shouldProcessClientComponents: this._shouldProcessClientComponents,
            treatMissingFieldsAsNull
          });
          validateOptimisticResponsePayload(payload);
          optimisticUpdates.push({
            operation: this._operation,
            payload,
            updater
          });
          this._processOptimisticFollowups(payload, optimisticUpdates);
        } else if (updater) {
          optimisticUpdates.push({
            operation: this._operation,
            payload: {
              errors: null,
              fieldPayloads: null,
              incrementalPlaceholders: null,
              followupPayloads: null,
              source: RelayRecordSource.create(),
              isFinal: false
            },
            updater
          });
        }
        this._optimisticUpdates = optimisticUpdates;
        optimisticUpdates.forEach(function(update) {
          return _this6._getPublishQueueAndSaveActor().applyUpdate(update);
        });
        var updatedOwners = this._runPublishQueue();
        if (RelayFeatureFlags.ENABLE_OPERATION_TRACKER_OPTIMISTIC_UPDATES) {
          this._updateOperationTracker(updatedOwners);
        }
      };
      _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {
        if (payload.followupPayloads && payload.followupPayloads.length) {
          var followupPayloads = payload.followupPayloads;
          var _iterator = (0, _createForOfIteratorHelper2["default"])(followupPayloads), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var followupPayload = _step.value;
              switch (followupPayload.kind) {
                case "ModuleImportPayload":
                  var operationLoader = this._expectOperationLoader();
                  var operation = operationLoader.get(followupPayload.operationReference);
                  if (operation == null) {
                    this._processAsyncOptimisticModuleImport(followupPayload);
                  } else {
                    var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);
                    optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2["default"])(moduleImportOptimisticUpdates));
                  }
                  break;
                case "ActorPayload":
                  true ? warning(false, "OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.") : void 0;
                  break;
                default:
                  followupPayload;
                  true ? true ? invariant(false, "OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.", followupPayload.kind) : invariant(false) : void 0;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      };
      _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {
        var variables;
        if (normalizationNode.kind === "SplitOperation" && followupPayload.kind === "ModuleImportPayload") {
          variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);
        } else {
          variables = followupPayload.variables;
        }
        var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);
        return this._normalizeResponse({
          data: followupPayload.data
        }, selector, followupPayload.typeName, {
          actorIdentifier: this._actorIdentifier,
          getDataID: this._getDataID,
          path: followupPayload.path,
          treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
          shouldProcessClientComponents: this._shouldProcessClientComponents
        });
      };
      _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {
        var operation = getOperation(normalizationRootNode);
        var optimisticUpdates = [];
        var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);
        validateOptimisticResponsePayload(modulePayload);
        optimisticUpdates.push({
          operation: this._operation,
          payload: modulePayload,
          updater: null
        });
        this._processOptimisticFollowups(modulePayload, optimisticUpdates);
        return optimisticUpdates;
      };
      _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {
        var _this7 = this;
        this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function(operation) {
          if (operation == null || _this7._state !== "started") {
            return;
          }
          var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);
          moduleImportOptimisticUpdates.forEach(function(update) {
            return _this7._getPublishQueueAndSaveActor().applyUpdate(update);
          });
          if (_this7._optimisticUpdates == null) {
            true ? warning(false, "OperationExecutor: Unexpected ModuleImport optimistic update in operation %s." + _this7._operation.request.node.params.name) : void 0;
          } else {
            var _this$_optimisticUpda;
            (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2["default"])(moduleImportOptimisticUpdates));
            _this7._runPublishQueue();
          }
        });
      };
      _proto._processResponses = function _processResponses(responses) {
        var _this8 = this;
        if (this._optimisticUpdates !== null) {
          this._optimisticUpdates.forEach(function(update) {
            _this8._getPublishQueueAndSaveActor().revertUpdate(update);
          });
          this._optimisticUpdates = null;
        }
        this._incrementalPayloadsPending = false;
        this._incrementalResults.clear();
        this._source.clear();
        return responses.map(function(payloadPart) {
          var relayPayload = _this8._normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {
            actorIdentifier: _this8._actorIdentifier,
            getDataID: _this8._getDataID,
            path: [],
            treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,
            shouldProcessClientComponents: _this8._shouldProcessClientComponents
          });
          _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);
          return relayPayload;
        });
      };
      _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {
        var _this9 = this;
        if (this._state === "completed") {
          return;
        }
        payloads.forEach(function(payload) {
          var incrementalPlaceholders = payload.incrementalPlaceholders, followupPayloads = payload.followupPayloads, isFinal = payload.isFinal;
          _this9._state = isFinal ? "loading_final" : "loading_incremental";
          _this9._updateActiveState();
          if (isFinal) {
            _this9._incrementalPayloadsPending = false;
          }
          if (followupPayloads && followupPayloads.length !== 0) {
            followupPayloads.forEach(function(followupPayload) {
              var _followupPayload$acto;
              var prevActorIdentifier = _this9._actorIdentifier;
              _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;
              _this9._processFollowupPayload(followupPayload);
              _this9._actorIdentifier = prevActorIdentifier;
            });
          }
          if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {
            _this9._incrementalPayloadsPending = _this9._state !== "loading_final";
            incrementalPlaceholders.forEach(function(incrementalPlaceholder) {
              var _incrementalPlacehold;
              var prevActorIdentifier = _this9._actorIdentifier;
              _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;
              _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);
              _this9._actorIdentifier = prevActorIdentifier;
            });
            if (_this9._isClientPayload || _this9._state === "loading_final") {
              true ? warning(_this9._isClientPayload, "RelayModernEnvironment: Operation `%s` contains @defer/@stream directives but was executed in non-streaming mode. See https://fburl.com/relay-incremental-delivery-non-streaming-warning.", _this9._operation.request.node.params.name) : void 0;
              var relayPayloads = [];
              incrementalPlaceholders.forEach(function(placeholder) {
                if (placeholder.kind === "defer") {
                  relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {
                    data: placeholder.data
                  }));
                }
              });
              if (relayPayloads.length > 0) {
                _this9._processPayloadFollowups(relayPayloads);
              }
            }
          }
        });
      };
      _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {
        if (!this._isSubscriptionOperation) {
          return;
        }
        if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {
          this._completeOperationTracker();
        }
      };
      _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {
        var _this10 = this;
        switch (followupPayload.kind) {
          case "ModuleImportPayload":
            var operationLoader = this._expectOperationLoader();
            var node = operationLoader.get(followupPayload.operationReference);
            if (node != null) {
              this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));
            } else {
              var id = this._nextSubscriptionId++;
              this._pendingModulePayloadsCount++;
              var decrementPendingCount = function decrementPendingCount2() {
                _this10._pendingModulePayloadsCount--;
                _this10._maybeCompleteSubscriptionOperationTracking();
              };
              var networkObservable = RelayObservable.from(new Promise(function(resolve, reject) {
                operationLoader.load(followupPayload.operationReference).then(resolve, reject);
              }));
              RelayObservable.create(function(sink) {
                var cancellationToken;
                var subscription = networkObservable.subscribe({
                  next: function next(loadedNode) {
                    if (loadedNode != null) {
                      var publishModuleImportPayload = function publishModuleImportPayload2() {
                        try {
                          var operation = getOperation(loadedNode);
                          var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;
                          var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;
                          var _withStartAndDuration = withStartAndDuration(function() {
                            _this10._handleFollowupPayload(followupPayload, operation);
                            if (shouldScheduleAsyncStoreUpdate) {
                              _this10._scheduleAsyncStoreUpdate(batchAsyncModuleUpdatesFN, sink.complete);
                            } else {
                              var updatedOwners = _this10._runPublishQueue();
                              _this10._updateOperationTracker(updatedOwners);
                            }
                          }), _ = _withStartAndDuration[0], duration = _withStartAndDuration[1];
                          _this10._log({
                            name: "execute.async.module",
                            executeId: _this10._executeId,
                            operationName: operation.name,
                            duration
                          });
                          if (!shouldScheduleAsyncStoreUpdate) {
                            sink.complete();
                          }
                        } catch (error) {
                          sink.error(error);
                        }
                      };
                      var scheduler = _this10._scheduler;
                      if (scheduler == null) {
                        publishModuleImportPayload();
                      } else {
                        cancellationToken = scheduler.schedule(publishModuleImportPayload);
                      }
                    } else {
                      sink.complete();
                    }
                  },
                  error: sink.error
                });
                return function() {
                  subscription.unsubscribe();
                  if (_this10._scheduler != null && cancellationToken != null) {
                    _this10._scheduler.cancel(cancellationToken);
                  }
                };
              }).subscribe({
                complete: function complete() {
                  _this10._complete(id);
                  decrementPendingCount();
                },
                error: function error(_error4) {
                  _this10._error(_error4);
                  decrementPendingCount();
                },
                start: function start(subscription) {
                  return _this10._start(id, subscription);
                }
              });
            }
            break;
          case "ActorPayload":
            this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);
            break;
          default:
            followupPayload;
            true ? true ? invariant(false, "OperationExecutor: Unexpected followup kind `%s`.", followupPayload.kind) : invariant(false) : void 0;
        }
      };
      _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {
        this._handleFollowupPayload(followupPayload, normalizationNode);
        this._maybeCompleteSubscriptionOperationTracking();
      };
      _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {
        var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);
        this._processPayloadFollowups([relayPayload]);
      };
      _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {
        var _relayPayload$fieldPa;
        var label = placeholder.label, path = placeholder.path;
        var pathKey = path.map(String).join(".");
        var resultForLabel = this._incrementalResults.get(label);
        if (resultForLabel == null) {
          resultForLabel = /* @__PURE__ */ new Map();
          this._incrementalResults.set(label, resultForLabel);
        }
        var resultForPath = resultForLabel.get(pathKey);
        var pendingResponses = resultForPath != null && resultForPath.kind === "response" ? resultForPath.responses : null;
        resultForLabel.set(pathKey, {
          kind: "placeholder",
          placeholder
        });
        var parentID;
        if (placeholder.kind === "stream") {
          parentID = placeholder.parentID;
        } else if (placeholder.kind === "defer") {
          parentID = placeholder.selector.dataID;
        } else {
          placeholder;
          true ? true ? invariant(false, "OperationExecutor: Unsupported incremental placeholder kind `%s`.", placeholder.kind) : invariant(false) : void 0;
        }
        var parentRecord = relayPayload.source.get(parentID);
        var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function(fieldPayload) {
          var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);
          return fieldPayload.dataID === parentID || fieldID === parentID;
        });
        !(parentRecord != null) ? true ? invariant(false, "OperationExecutor: Expected record `%s` to exist.", parentID) : invariant(false) : void 0;
        var nextParentRecord;
        var nextParentPayloads;
        var previousParentEntry = this._source.get(parentID);
        if (previousParentEntry != null) {
          nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);
          var handlePayloads = /* @__PURE__ */ new Map();
          var dedupePayload = function dedupePayload2(payload) {
            var key = stableStringify(payload);
            handlePayloads.set(key, payload);
          };
          previousParentEntry.fieldPayloads.forEach(dedupePayload);
          parentPayloads.forEach(dedupePayload);
          nextParentPayloads = Array.from(handlePayloads.values());
        } else {
          nextParentRecord = parentRecord;
          nextParentPayloads = parentPayloads;
        }
        this._source.set(parentID, {
          record: nextParentRecord,
          fieldPayloads: nextParentPayloads
        });
        if (pendingResponses != null) {
          var payloadFollowups = this._processIncrementalResponses(pendingResponses);
          this._processPayloadFollowups(payloadFollowups);
        }
      };
      _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {
        var _this11 = this;
        var relayPayloads = [];
        incrementalResponses.forEach(function(incrementalResponse) {
          var label = incrementalResponse.label, path = incrementalResponse.path, response = incrementalResponse.response;
          var resultForLabel = _this11._incrementalResults.get(label);
          if (resultForLabel == null) {
            resultForLabel = /* @__PURE__ */ new Map();
            _this11._incrementalResults.set(label, resultForLabel);
          }
          if (label.indexOf("$defer$") !== -1) {
            var pathKey = path.map(String).join(".");
            var resultForPath = resultForLabel.get(pathKey);
            if (resultForPath == null) {
              resultForPath = {
                kind: "response",
                responses: [incrementalResponse]
              };
              resultForLabel.set(pathKey, resultForPath);
              return;
            } else if (resultForPath.kind === "response") {
              resultForPath.responses.push(incrementalResponse);
              return;
            }
            var placeholder = resultForPath.placeholder;
            !(placeholder.kind === "defer") ? true ? invariant(false, "OperationExecutor: Expected data for path `%s` for label `%s` to be data for @defer, was `@%s`.", pathKey, label, placeholder.kind) : invariant(false) : void 0;
            relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));
          } else {
            var _pathKey = path.slice(0, -2).map(String).join(".");
            var _resultForPath = resultForLabel.get(_pathKey);
            if (_resultForPath == null) {
              _resultForPath = {
                kind: "response",
                responses: [incrementalResponse]
              };
              resultForLabel.set(_pathKey, _resultForPath);
              return;
            } else if (_resultForPath.kind === "response") {
              _resultForPath.responses.push(incrementalResponse);
              return;
            }
            var _placeholder = _resultForPath.placeholder;
            !(_placeholder.kind === "stream") ? true ? invariant(false, "OperationExecutor: Expected data for path `%s` for label `%s` to be data for @stream, was `@%s`.", _pathKey, label, _placeholder.kind) : invariant(false) : void 0;
            relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));
          }
        });
        return relayPayloads;
      };
      _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {
        var _placeholder$actorIde;
        var parentID = placeholder.selector.dataID;
        var prevActorIdentifier = this._actorIdentifier;
        this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;
        var relayPayload = this._normalizeResponse(response, placeholder.selector, placeholder.typeName, {
          actorIdentifier: this._actorIdentifier,
          getDataID: this._getDataID,
          path: placeholder.path,
          treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
          shouldProcessClientComponents: this._shouldProcessClientComponents
        });
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);
        var parentEntry = this._source.get(parentID);
        !(parentEntry != null) ? true ? invariant(false, "OperationExecutor: Expected the parent record `%s` for @defer data to exist.", parentID) : invariant(false) : void 0;
        var fieldPayloads = parentEntry.fieldPayloads;
        if (fieldPayloads.length !== 0) {
          var _response$extensions2;
          var handleFieldsRelayPayload = {
            errors: null,
            fieldPayloads,
            incrementalPlaceholders: null,
            followupPayloads: null,
            source: RelayRecordSource.create(),
            isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true
          };
          this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);
        }
        this._actorIdentifier = prevActorIdentifier;
        return relayPayload;
      };
      _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {
        var parentID = placeholder.parentID, node = placeholder.node, variables = placeholder.variables, actorIdentifier = placeholder.actorIdentifier;
        var prevActorIdentifier = this._actorIdentifier;
        this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier;
        var field = node.selections[0];
        !(field != null && field.kind === "LinkedField" && field.plural === true) ? true ? invariant(false, "OperationExecutor: Expected @stream to be used on a plural field.") : invariant(false) : void 0;
        var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path), fieldPayloads = _this$_normalizeStrea.fieldPayloads, itemID = _this$_normalizeStrea.itemID, itemIndex = _this$_normalizeStrea.itemIndex, prevIDs = _this$_normalizeStrea.prevIDs, relayPayload = _this$_normalizeStrea.relayPayload, storageKey = _this$_normalizeStrea.storageKey;
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function(store) {
          var currentParentRecord = store.get(parentID);
          if (currentParentRecord == null) {
            return;
          }
          var currentItems = currentParentRecord.getLinkedRecords(storageKey);
          if (currentItems == null) {
            return;
          }
          if (currentItems.length !== prevIDs.length || currentItems.some(function(currentItem, index) {
            return prevIDs[index] !== (currentItem && currentItem.getDataID());
          })) {
            return;
          }
          var nextItems = (0, _toConsumableArray2["default"])(currentItems);
          nextItems[itemIndex] = store.get(itemID);
          currentParentRecord.setLinkedRecords(nextItems, storageKey);
        });
        if (fieldPayloads.length !== 0) {
          var handleFieldsRelayPayload = {
            errors: null,
            fieldPayloads,
            incrementalPlaceholders: null,
            followupPayloads: null,
            source: RelayRecordSource.create(),
            isFinal: false
          };
          this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);
        }
        this._actorIdentifier = prevActorIdentifier;
        return relayPayload;
      };
      _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {
        var _field$alias, _field$concreteType, _ref, _this$_getDataID;
        var data = response.data;
        !(typeof data === "object") ? true ? invariant(false, "OperationExecutor: Expected the GraphQL @stream payload `data` value to be an object.") : invariant(false) : void 0;
        var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;
        var storageKey = getStorageKey(field, variables);
        var parentEntry = this._source.get(parentID);
        !(parentEntry != null) ? true ? invariant(false, "OperationExecutor: Expected the parent record `%s` for @stream data to exist.", parentID) : invariant(false) : void 0;
        var parentRecord = parentEntry.record, fieldPayloads = parentEntry.fieldPayloads;
        var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);
        !(prevIDs != null) ? true ? invariant(false, "OperationExecutor: Expected record `%s` to have fetched field `%s` with @stream.", parentID, field.name) : invariant(false) : void 0;
        var finalPathEntry = path[path.length - 1];
        var itemIndex = parseInt(finalPathEntry, 10);
        !(itemIndex === finalPathEntry && itemIndex >= 0) ? true ? invariant(false, "OperationExecutor: Expected path for @stream to end in a positive integer index, got `%s`", finalPathEntry) : invariant(false) : void 0;
        var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];
        !(typeof typeName === "string") ? true ? invariant(false, "OperationExecutor: Expected @stream field `%s` to have a __typename.", field.name) : invariant(false) : void 0;
        var itemID = (_ref = (_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs === null || prevIDs === void 0 ? void 0 : prevIDs[itemIndex]) !== null && _ref !== void 0 ? _ref : generateClientID(parentID, storageKey, itemIndex);
        !(typeof itemID === "string") ? true ? invariant(false, "OperationExecutor: Expected id of elements of field `%s` to be strings.", storageKey) : invariant(false) : void 0;
        var selector = createNormalizationSelector(field, itemID, variables);
        var nextParentRecord = RelayModernRecord.clone(parentRecord);
        var nextIDs = (0, _toConsumableArray2["default"])(prevIDs);
        nextIDs[itemIndex] = itemID;
        RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);
        this._source.set(parentID, {
          record: nextParentRecord,
          fieldPayloads
        });
        var relayPayload = this._normalizeResponse(response, selector, typeName, {
          actorIdentifier: this._actorIdentifier,
          getDataID: this._getDataID,
          path: [].concat((0, _toConsumableArray2["default"])(normalizationPath), [responseKey, String(itemIndex)]),
          treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
          shouldProcessClientComponents: this._shouldProcessClientComponents
        });
        return {
          fieldPayloads,
          itemID,
          itemIndex,
          prevIDs,
          relayPayload,
          storageKey
        };
      };
      _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {
        var _this12 = this;
        this._completeFns.push(completeFn);
        if (this._asyncStoreUpdateDisposable != null) {
          return;
        }
        this._asyncStoreUpdateDisposable = scheduleFn(function() {
          _this12._asyncStoreUpdateDisposable = null;
          var updatedOwners = _this12._runPublishQueue();
          _this12._updateOperationTracker(updatedOwners);
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(_this12._completeFns), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var complete = _step2.value;
              complete();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          _this12._completeFns = [];
        });
      };
      _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {
        if (updatedOwners != null && updatedOwners.length > 0) {
          this._operationTracker.update(this._operation.request, new Set(updatedOwners));
        }
      };
      _proto._completeOperationTracker = function _completeOperationTracker() {
        this._operationTracker.complete(this._operation.request);
      };
      _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {
        this._seenActors.add(this._actorIdentifier);
        return this._getPublishQueue(this._actorIdentifier);
      };
      _proto._getActorsToVisit = function _getActorsToVisit() {
        if (this._seenActors.size === 0) {
          return /* @__PURE__ */ new Set([this._actorIdentifier]);
        } else {
          return this._seenActors;
        }
      };
      _proto._runPublishQueue = function _runPublishQueue(operation) {
        var updatedOwners = /* @__PURE__ */ new Set();
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(this._getActorsToVisit()), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var actorIdentifier = _step3.value;
            var owners = this._getPublishQueue(actorIdentifier).run(operation);
            owners.forEach(function(owner) {
              return updatedOwners.add(owner);
            });
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return Array.from(updatedOwners);
      };
      _proto._retainData = function _retainData() {
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(this._getActorsToVisit()), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var actorIdentifier = _step4.value;
            if (!this._retainDisposables.has(actorIdentifier)) {
              this._retainDisposables.set(actorIdentifier, this._getStore(actorIdentifier).retain(this._operation));
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      };
      _proto._disposeRetainedData = function _disposeRetainedData() {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(this._retainDisposables.values()), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var disposable = _step5.value;
            disposable.dispose();
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        this._retainDisposables.clear();
      };
      _proto._expectOperationLoader = function _expectOperationLoader() {
        var operationLoader = this._operationLoader;
        !operationLoader ? true ? invariant(false, "OperationExecutor: Expected an operationLoader to be configured when using `@match`.") : invariant(false) : void 0;
        return operationLoader;
      };
      return Executor2;
    }();
    function partitionGraphQLResponses(responses) {
      var nonIncrementalResponses = [];
      var incrementalResponses = [];
      responses.forEach(function(response) {
        if (response.path != null || response.label != null) {
          var label = response.label, path = response.path;
          if (label == null || path == null) {
            true ? true ? invariant(false, "OperationExecutor: invalid incremental payload, expected `path` and `label` to either both be null/undefined, or `path` to be an `Array<string | number>` and `label` to be a `string`.") : invariant(false) : void 0;
          }
          incrementalResponses.push({
            label,
            path,
            response
          });
        } else {
          nonIncrementalResponses.push(response);
        }
      });
      return [nonIncrementalResponses, incrementalResponses];
    }
    function stableStringify(value) {
      var _JSON$stringify;
      return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "";
    }
    function validateOptimisticResponsePayload(payload) {
      var incrementalPlaceholders = payload.incrementalPlaceholders;
      if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {
        true ? true ? invariant(false, "OperationExecutor: optimistic responses cannot be returned for operations that use incremental data delivery (@defer, @stream, and @stream_connection).") : invariant(false) : void 0;
      }
    }
    module.exports = {
      execute
    };
  }
});

// node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js
var require_RelayRecordSourceMutator = __commonJS({
  "node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js"(exports, module) {
    "use strict";
    var RelayModernRecord = require_RelayModernRecord();
    var _require = require_RelayRecordState();
    var EXISTENT = _require.EXISTENT;
    var invariant = require_browser();
    var RelayRecordSourceMutator = function() {
      function RelayRecordSourceMutator2(base, sink) {
        this.__sources = [sink, base];
        this._base = base;
        this._sink = sink;
      }
      var _proto = RelayRecordSourceMutator2.prototype;
      _proto.unstable_getRawRecordWithChanges = function unstable_getRawRecordWithChanges(dataID) {
        var baseRecord = this._base.get(dataID);
        var sinkRecord = this._sink.get(dataID);
        if (sinkRecord === void 0) {
          if (baseRecord == null) {
            return baseRecord;
          }
          var nextRecord = RelayModernRecord.clone(baseRecord);
          if (true) {
            RelayModernRecord.freeze(nextRecord);
          }
          return nextRecord;
        } else if (sinkRecord === null) {
          return null;
        } else if (baseRecord != null) {
          var _nextRecord = RelayModernRecord.update(baseRecord, sinkRecord);
          if (true) {
            if (_nextRecord !== baseRecord) {
              RelayModernRecord.freeze(_nextRecord);
            }
          }
          return _nextRecord;
        } else {
          var _nextRecord2 = RelayModernRecord.clone(sinkRecord);
          if (true) {
            RelayModernRecord.freeze(_nextRecord2);
          }
          return _nextRecord2;
        }
      };
      _proto._getSinkRecord = function _getSinkRecord(dataID) {
        var sinkRecord = this._sink.get(dataID);
        if (!sinkRecord) {
          var baseRecord = this._base.get(dataID);
          !baseRecord ? true ? invariant(false, "RelayRecordSourceMutator: Cannot modify non-existent record `%s`.", dataID) : invariant(false) : void 0;
          sinkRecord = RelayModernRecord.create(dataID, RelayModernRecord.getType(baseRecord));
          this._sink.set(dataID, sinkRecord);
        }
        return sinkRecord;
      };
      _proto.copyFields = function copyFields(sourceID, sinkID) {
        var sinkSource = this._sink.get(sourceID);
        var baseSource = this._base.get(sourceID);
        !(sinkSource || baseSource) ? true ? invariant(false, "RelayRecordSourceMutator#copyFields(): Cannot copy fields from non-existent record `%s`.", sourceID) : invariant(false) : void 0;
        var sink = this._getSinkRecord(sinkID);
        if (baseSource) {
          RelayModernRecord.copyFields(baseSource, sink);
        }
        if (sinkSource) {
          RelayModernRecord.copyFields(sinkSource, sink);
        }
      };
      _proto.copyFieldsFromRecord = function copyFieldsFromRecord(record, sinkID) {
        var sink = this._getSinkRecord(sinkID);
        RelayModernRecord.copyFields(record, sink);
      };
      _proto.create = function create(dataID, typeName) {
        !(this._base.getStatus(dataID) !== EXISTENT && this._sink.getStatus(dataID) !== EXISTENT) ? true ? invariant(false, "RelayRecordSourceMutator#create(): Cannot create a record with id `%s`, this record already exists.", dataID) : invariant(false) : void 0;
        var record = RelayModernRecord.create(dataID, typeName);
        this._sink.set(dataID, record);
      };
      _proto["delete"] = function _delete(dataID) {
        this._sink["delete"](dataID);
      };
      _proto.getStatus = function getStatus(dataID) {
        return this._sink.has(dataID) ? this._sink.getStatus(dataID) : this._base.getStatus(dataID);
      };
      _proto.getType = function getType(dataID) {
        for (var ii = 0; ii < this.__sources.length; ii++) {
          var record = this.__sources[ii].get(dataID);
          if (record) {
            return RelayModernRecord.getType(record);
          } else if (record === null) {
            return null;
          }
        }
      };
      _proto.getValue = function getValue(dataID, storageKey) {
        for (var ii = 0; ii < this.__sources.length; ii++) {
          var record = this.__sources[ii].get(dataID);
          if (record) {
            var value = RelayModernRecord.getValue(record, storageKey);
            if (value !== void 0) {
              return value;
            }
          } else if (record === null) {
            return null;
          }
        }
      };
      _proto.setValue = function setValue(dataID, storageKey, value) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setValue(sinkRecord, storageKey, value);
      };
      _proto.getLinkedRecordID = function getLinkedRecordID(dataID, storageKey) {
        for (var ii = 0; ii < this.__sources.length; ii++) {
          var record = this.__sources[ii].get(dataID);
          if (record) {
            var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
            if (linkedID !== void 0) {
              return linkedID;
            }
          } else if (record === null) {
            return null;
          }
        }
      };
      _proto.setLinkedRecordID = function setLinkedRecordID(dataID, storageKey, linkedID) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setLinkedRecordID(sinkRecord, storageKey, linkedID);
      };
      _proto.getLinkedRecordIDs = function getLinkedRecordIDs(dataID, storageKey) {
        for (var ii = 0; ii < this.__sources.length; ii++) {
          var record = this.__sources[ii].get(dataID);
          if (record) {
            var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
            if (linkedIDs !== void 0) {
              return linkedIDs;
            }
          } else if (record === null) {
            return null;
          }
        }
      };
      _proto.setLinkedRecordIDs = function setLinkedRecordIDs(dataID, storageKey, linkedIDs) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setLinkedRecordIDs(sinkRecord, storageKey, linkedIDs);
      };
      return RelayRecordSourceMutator2;
    }();
    module.exports = RelayRecordSourceMutator;
  }
});

// node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js
var require_createUpdatableProxy = __commonJS({
  "node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _require = require_RelayStoreUtils();
    var getArgumentValues = _require.getArgumentValues;
    var nonUpdatableKeys = ["id", "__id", "__typename", "js"];
    function createUpdatableProxy(updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers) {
      var mutableUpdatableProxy = {};
      updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers);
      if (true) {
        Object.freeze(mutableUpdatableProxy);
      }
      return mutableUpdatableProxy;
    }
    function updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers) {
      var _selection$alias3;
      var _iterator = (0, _createForOfIteratorHelper2["default"])(selections), _step;
      try {
        var _loop = function _loop2() {
          var selection = _step.value;
          switch (selection.kind) {
            case "LinkedField":
              if (selection.plural) {
                Object.defineProperty(mutableUpdatableProxy, (_selection$alias = selection.alias) !== null && _selection$alias !== void 0 ? _selection$alias : selection.name, {
                  get: createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers),
                  set: createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
                });
              } else {
                Object.defineProperty(mutableUpdatableProxy, (_selection$alias2 = selection.alias) !== null && _selection$alias2 !== void 0 ? _selection$alias2 : selection.name, {
                  get: createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers),
                  set: createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
                });
              }
              break;
            case "ScalarField":
              var scalarFieldName = (_selection$alias3 = selection.alias) !== null && _selection$alias3 !== void 0 ? _selection$alias3 : selection.name;
              Object.defineProperty(mutableUpdatableProxy, scalarFieldName, {
                get: function get() {
                  var _selection$args;
                  var newVariables = getArgumentValues((_selection$args = selection.args) !== null && _selection$args !== void 0 ? _selection$args : [], variables);
                  var value = updatableProxyRootRecord.getValue(selection.name, newVariables);
                  if (value == null) {
                    value = getScalarUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
                  }
                  return value;
                },
                set: nonUpdatableKeys.includes(selection.name) ? void 0 : function(newValue) {
                  var _selection$args2;
                  var newVariables = getArgumentValues((_selection$args2 = selection.args) !== null && _selection$args2 !== void 0 ? _selection$args2 : [], variables);
                  updatableProxyRootRecord.setValue__UNSAFE(newValue, selection.name, newVariables);
                }
              });
              break;
            case "InlineFragment":
              if (updatableProxyRootRecord.getType() === selection.type) {
                updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
              }
              break;
            case "ClientExtension":
              updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
              break;
            case "FragmentSpread":
              break;
            case "Condition":
            case "ActorChange":
            case "InlineDataFragmentSpread":
            case "AliasedInlineFragmentSpread":
            case "ClientEdgeToClientObject":
            case "ClientEdgeToServerObject":
            case "Defer":
            case "ModuleImport":
            case "RelayLiveResolver":
            case "RequiredField":
            case "CatchField":
            case "Stream":
            case "RelayResolver":
              throw new Error("Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.");
            default:
              selection.kind;
              throw new Error("Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.");
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _selection$alias;
          var _selection$alias2;
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    function createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
      return function set(newValue) {
        var _selection$args3;
        var newVariables = getArgumentValues((_selection$args3 = selection.args) !== null && _selection$args3 !== void 0 ? _selection$args3 : [], variables);
        if (newValue == null) {
          throw new Error("Do not assign null to plural linked fields; assign an empty array instead.");
        } else {
          var recordProxies = newValue.map(function(item) {
            if (item == null) {
              throw new Error("When assigning an array of items, none of the items should be null or undefined.");
            }
            var __id = item.__id;
            if (__id == null) {
              throw new Error("The __id field must be present on each item passed to the setter. This indicates a bug in Relay.");
            }
            var newValueRecord = recordSourceProxy.get(__id);
            if (newValueRecord == null) {
              throw new Error("Did not find item with data id ".concat(__id, " in the store."));
            }
            return newValueRecord;
          });
          updatableProxyRootRecord.setLinkedRecords(recordProxies, selection.name, newVariables);
        }
      };
    }
    function createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
      return function set(newValue) {
        var _selection$args4;
        var newVariables = getArgumentValues((_selection$args4 = selection.args) !== null && _selection$args4 !== void 0 ? _selection$args4 : [], variables);
        if (newValue == null) {
          updatableProxyRootRecord.setValue(newValue, selection.name, newVariables);
        } else {
          var __id = newValue.__id;
          if (__id == null) {
            throw new Error("The __id field must be present on the argument. This indicates a bug in Relay.");
          }
          var newValueRecord = recordSourceProxy.get(__id);
          if (newValueRecord == null) {
            throw new Error("Did not find item with data id ".concat(__id, " in the store."));
          }
          updatableProxyRootRecord.setLinkedRecord(newValueRecord, selection.name, newVariables);
        }
      };
    }
    function createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
      return function() {
        var _selection$args5;
        var newVariables = getArgumentValues((_selection$args5 = selection.args) !== null && _selection$args5 !== void 0 ? _selection$args5 : [], variables);
        var linkedRecords = updatableProxyRootRecord.getLinkedRecords(selection.name, newVariables);
        if (linkedRecords === void 0) {
          linkedRecords = getPluralLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
        }
        if (linkedRecords != null) {
          return linkedRecords.map(function(linkedRecord) {
            if (linkedRecord != null) {
              var updatableProxy = {};
              updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
              if (true) {
                Object.freeze(updatableProxy);
              }
              return updatableProxy;
            } else {
              return linkedRecord;
            }
          });
        } else {
          return linkedRecords;
        }
      };
    }
    function createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
      return function() {
        var _selection$args6;
        var newVariables = getArgumentValues((_selection$args6 = selection.args) !== null && _selection$args6 !== void 0 ? _selection$args6 : [], variables);
        var linkedRecord = updatableProxyRootRecord.getLinkedRecord(selection.name, newVariables);
        if (linkedRecord === void 0) {
          linkedRecord = getLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
        }
        if (linkedRecord != null) {
          var updatableProxy = {};
          updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
          if (true) {
            Object.freeze(updatableProxy);
          }
          return updatableProxy;
        } else {
          return linkedRecord;
        }
      };
    }
    function getLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
      var _iterator2 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var handler = _step2.value;
          if (handler.kind === "linked") {
            var newId = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
            if (newId != null) {
              return recordSourceProxy.get(newId);
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    function getPluralLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
      var _iterator3 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var handler = _step3.value;
          if (handler.kind === "pluralLinked") {
            var newIds = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
            if (newIds != null) {
              return newIds.map(function(newId) {
                if (newId != null) {
                  return recordSourceProxy.get(newId);
                }
              });
            }
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    function getScalarUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
      var _iterator4 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var handler = _step4.value;
          if (handler.kind === "scalar") {
            var value = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
            if (value !== void 0) {
              return value;
            }
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
    module.exports = {
      createUpdatableProxy
    };
  }
});

// node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js
var require_readUpdatableFragment = __commonJS({
  "node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js"(exports, module) {
    "use strict";
    var _require = require_GraphQLTag();
    var getFragment = _require.getFragment;
    var _require2 = require_RelayModernSelector();
    var getVariablesFromFragment = _require2.getVariablesFromFragment;
    var _require3 = require_RelayStoreUtils();
    var ID_KEY = _require3.ID_KEY;
    var _require4 = require_createUpdatableProxy();
    var createUpdatableProxy = _require4.createUpdatableProxy;
    var invariant = require_browser();
    function readUpdatableFragment(fragment, fragmentReference, proxy, missingFieldHandlers) {
      var updatableFragment = getFragment(fragment);
      var fragmentVariables = getVariablesFromFragment(updatableFragment, fragmentReference);
      var id = fragmentReference[ID_KEY];
      var fragmentRoot = proxy.get(id);
      !(fragmentRoot != null) ? true ? invariant(false, "No record with ".concat(id, " was found. This likely indicates a problem with Relay.")) : invariant(false) : void 0;
      return {
        updatableData: createUpdatableProxy(fragmentRoot, fragmentVariables, updatableFragment.selections, proxy, missingFieldHandlers)
      };
    }
    module.exports = {
      readUpdatableFragment
    };
  }
});

// node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js
var require_readUpdatableQuery = __commonJS({
  "node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js"(exports, module) {
    "use strict";
    var _require = require_GraphQLTag();
    var getUpdatableQuery = _require.getUpdatableQuery;
    var _require2 = require_createUpdatableProxy();
    var createUpdatableProxy = _require2.createUpdatableProxy;
    function readUpdatableQuery(query, variables, proxy, missingFieldHandlers) {
      var updatableQuery = getUpdatableQuery(query);
      return {
        updatableData: createUpdatableProxy(proxy.getRoot(), variables, updatableQuery.fragment.selections, proxy, missingFieldHandlers)
      };
    }
    module.exports = {
      readUpdatableQuery
    };
  }
});

// node_modules/relay-runtime/lib/mutations/RelayRecordProxy.js
var require_RelayRecordProxy = __commonJS({
  "node_modules/relay-runtime/lib/mutations/RelayRecordProxy.js"(exports, module) {
    "use strict";
    var _require = require_ClientID();
    var generateClientID = _require.generateClientID;
    var _require2 = require_RelayStoreUtils();
    var getStableStorageKey = _require2.getStableStorageKey;
    var invariant = require_browser();
    var RelayRecordProxy = function() {
      function RelayRecordProxy2(source, mutator, dataID) {
        this._dataID = dataID;
        this._mutator = mutator;
        this._source = source;
      }
      var _proto = RelayRecordProxy2.prototype;
      _proto.copyFieldsFrom = function copyFieldsFrom(source) {
        this._mutator.copyFields(source.getDataID(), this._dataID);
      };
      _proto.getDataID = function getDataID() {
        return this._dataID;
      };
      _proto.getType = function getType() {
        var type = this._mutator.getType(this._dataID);
        !(type != null) ? true ? invariant(false, "RelayRecordProxy: Cannot get the type of deleted record `%s`.", this._dataID) : invariant(false) : void 0;
        return type;
      };
      _proto.getValue = function getValue(name, args) {
        var storageKey = getStableStorageKey(name, args);
        return this._mutator.getValue(this._dataID, storageKey);
      };
      _proto.setValue = function setValue(value, name, args) {
        !isValidLeafValue(value) ? true ? invariant(false, "RelayRecordProxy#setValue(): Expected a scalar or array of scalars, got `%s`.", JSON.stringify(value)) : invariant(false) : void 0;
        return this.setValue__UNSAFE(value, name, args);
      };
      _proto.setValue__UNSAFE = function setValue__UNSAFE(value, name, args) {
        var storageKey = getStableStorageKey(name, args);
        this._mutator.setValue(this._dataID, storageKey, value);
        return this;
      };
      _proto.getLinkedRecord = function getLinkedRecord(name, args) {
        var storageKey = getStableStorageKey(name, args);
        var linkedID = this._mutator.getLinkedRecordID(this._dataID, storageKey);
        return linkedID != null ? this._source.get(linkedID) : linkedID;
      };
      _proto.setLinkedRecord = function setLinkedRecord(record, name, args) {
        !(record instanceof RelayRecordProxy2) ? true ? invariant(false, "RelayRecordProxy#setLinkedRecord(): Expected a record, got `%s`.", record) : invariant(false) : void 0;
        var storageKey = getStableStorageKey(name, args);
        var linkedID = record.getDataID();
        this._mutator.setLinkedRecordID(this._dataID, storageKey, linkedID);
        return this;
      };
      _proto.getOrCreateLinkedRecord = function getOrCreateLinkedRecord(name, typeName, args) {
        var linkedRecord = this.getLinkedRecord(name, args);
        if (!linkedRecord) {
          var _this$_source$get;
          var storageKey = getStableStorageKey(name, args);
          var clientID = generateClientID(this.getDataID(), storageKey);
          linkedRecord = (_this$_source$get = this._source.get(clientID)) !== null && _this$_source$get !== void 0 ? _this$_source$get : this._source.create(clientID, typeName);
          this.setLinkedRecord(linkedRecord, name, args);
        }
        return linkedRecord;
      };
      _proto.getLinkedRecords = function getLinkedRecords(name, args) {
        var _this = this;
        var storageKey = getStableStorageKey(name, args);
        var linkedIDs = this._mutator.getLinkedRecordIDs(this._dataID, storageKey);
        if (linkedIDs == null) {
          return linkedIDs;
        }
        return linkedIDs.map(function(linkedID) {
          return linkedID != null ? _this._source.get(linkedID) : linkedID;
        });
      };
      _proto.setLinkedRecords = function setLinkedRecords(records, name, args) {
        !Array.isArray(records) ? true ? invariant(false, "RelayRecordProxy#setLinkedRecords(): Expected records to be an array, got `%s`.", records) : invariant(false) : void 0;
        var storageKey = getStableStorageKey(name, args);
        var linkedIDs = records.map(function(record) {
          return record && record.getDataID();
        });
        this._mutator.setLinkedRecordIDs(this._dataID, storageKey, linkedIDs);
        return this;
      };
      _proto.invalidateRecord = function invalidateRecord() {
        this._source.markIDForInvalidation(this._dataID);
      };
      return RelayRecordProxy2;
    }();
    function isValidLeafValue(value) {
      return value == null || typeof value !== "object" || Array.isArray(value) && value.every(isValidLeafValue);
    }
    module.exports = RelayRecordProxy;
  }
});

// node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js
var require_RelayRecordSourceProxy = __commonJS({
  "node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js"(exports, module) {
    "use strict";
    var RelayModernRecord = require_RelayModernRecord();
    var _require = require_RelayRecordState();
    var EXISTENT = _require.EXISTENT;
    var NONEXISTENT = _require.NONEXISTENT;
    var _require2 = require_RelayStoreUtils();
    var ROOT_ID = _require2.ROOT_ID;
    var ROOT_TYPE = _require2.ROOT_TYPE;
    var _require3 = require_readUpdatableFragment();
    var _readUpdatableFragment = _require3.readUpdatableFragment;
    var _require4 = require_readUpdatableQuery();
    var _readUpdatableQuery = _require4.readUpdatableQuery;
    var RelayRecordProxy = require_RelayRecordProxy();
    var invariant = require_browser();
    var RelayRecordSourceProxy = function() {
      function RelayRecordSourceProxy2(mutator, getDataID, handlerProvider, missingFieldHandlers) {
        this.__mutator = mutator;
        this._handlerProvider = handlerProvider || null;
        this._proxies = {};
        this._getDataID = getDataID;
        this._invalidatedStore = false;
        this._idsMarkedForInvalidation = /* @__PURE__ */ new Set();
        this._missingFieldHandlers = missingFieldHandlers;
      }
      var _proto = RelayRecordSourceProxy2.prototype;
      _proto.publishSource = function publishSource(source, fieldPayloads) {
        var _this = this;
        var dataIDs = source.getRecordIDs();
        dataIDs.forEach(function(dataID) {
          var status = source.getStatus(dataID);
          if (status === EXISTENT) {
            var sourceRecord = source.get(dataID);
            if (sourceRecord) {
              if (_this.__mutator.getStatus(dataID) !== EXISTENT) {
                _this.create(dataID, RelayModernRecord.getType(sourceRecord));
              }
              _this.__mutator.copyFieldsFromRecord(sourceRecord, dataID);
            }
          } else if (status === NONEXISTENT) {
            _this["delete"](dataID);
          }
        });
        if (fieldPayloads && fieldPayloads.length) {
          fieldPayloads.forEach(function(fieldPayload) {
            var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);
            !handler ? true ? invariant(false, "RelayModernEnvironment: Expected a handler to be provided for handle `%s`.", fieldPayload.handle) : invariant(false) : void 0;
            handler.update(_this, fieldPayload);
          });
        }
      };
      _proto.create = function create(dataID, typeName) {
        this.__mutator.create(dataID, typeName);
        delete this._proxies[dataID];
        var record = this.get(dataID);
        !record ? true ? invariant(false, "RelayRecordSourceProxy#create(): Expected the created record to exist.") : invariant(false) : void 0;
        return record;
      };
      _proto["delete"] = function _delete(dataID) {
        !(dataID !== ROOT_ID) ? true ? invariant(false, "RelayRecordSourceProxy#delete(): Cannot delete the root record.") : invariant(false) : void 0;
        delete this._proxies[dataID];
        this.__mutator["delete"](dataID);
      };
      _proto.get = function get(dataID) {
        if (!this._proxies.hasOwnProperty(dataID)) {
          var status = this.__mutator.getStatus(dataID);
          if (status === EXISTENT) {
            this._proxies[dataID] = new RelayRecordProxy(this, this.__mutator, dataID);
          } else {
            this._proxies[dataID] = status === NONEXISTENT ? null : void 0;
          }
        }
        return this._proxies[dataID];
      };
      _proto.getRoot = function getRoot() {
        var root = this.get(ROOT_ID);
        if (!root) {
          root = this.create(ROOT_ID, ROOT_TYPE);
        }
        !(root && root.getType() === ROOT_TYPE) ? true ? invariant(false, "RelayRecordSourceProxy#getRoot(): Expected the source to contain a root record, %s.", root == null ? "no root record found" : "found a root record of type `".concat(root.getType(), "`")) : invariant(false) : void 0;
        return root;
      };
      _proto.invalidateStore = function invalidateStore() {
        this._invalidatedStore = true;
      };
      _proto.isStoreMarkedForInvalidation = function isStoreMarkedForInvalidation() {
        return this._invalidatedStore;
      };
      _proto.markIDForInvalidation = function markIDForInvalidation(dataID) {
        this._idsMarkedForInvalidation.add(dataID);
      };
      _proto.getIDsMarkedForInvalidation = function getIDsMarkedForInvalidation() {
        return this._idsMarkedForInvalidation;
      };
      _proto.readUpdatableQuery = function readUpdatableQuery(query, variables) {
        return _readUpdatableQuery(query, variables, this, this._missingFieldHandlers);
      };
      _proto.readUpdatableFragment = function readUpdatableFragment(fragment, fragmentReference) {
        return _readUpdatableFragment(fragment, fragmentReference, this, this._missingFieldHandlers);
      };
      return RelayRecordSourceProxy2;
    }();
    module.exports = RelayRecordSourceProxy;
  }
});

// node_modules/relay-runtime/lib/mutations/RelayRecordSourceSelectorProxy.js
var require_RelayRecordSourceSelectorProxy = __commonJS({
  "node_modules/relay-runtime/lib/mutations/RelayRecordSourceSelectorProxy.js"(exports, module) {
    "use strict";
    var _require = require_RelayStoreUtils();
    var ROOT_TYPE = _require.ROOT_TYPE;
    var getStorageKey = _require.getStorageKey;
    var _require2 = require_readUpdatableFragment();
    var _readUpdatableFragment = _require2.readUpdatableFragment;
    var _require3 = require_readUpdatableQuery();
    var _readUpdatableQuery = _require3.readUpdatableQuery;
    var invariant = require_browser();
    var RelayRecordSourceSelectorProxy = function() {
      function RelayRecordSourceSelectorProxy2(mutator, recordSource, readSelector, missingFieldHandlers) {
        this.__mutator = mutator;
        this.__recordSource = recordSource;
        this._readSelector = readSelector;
        this._missingFieldHandlers = missingFieldHandlers;
      }
      var _proto = RelayRecordSourceSelectorProxy2.prototype;
      _proto.create = function create(dataID, typeName) {
        return this.__recordSource.create(dataID, typeName);
      };
      _proto["delete"] = function _delete(dataID) {
        this.__recordSource["delete"](dataID);
      };
      _proto.get = function get(dataID) {
        return this.__recordSource.get(dataID);
      };
      _proto.getRoot = function getRoot() {
        return this.__recordSource.getRoot();
      };
      _proto.getOperationRoot = function getOperationRoot() {
        var root = this.__recordSource.get(this._readSelector.dataID);
        if (!root) {
          root = this.__recordSource.create(this._readSelector.dataID, ROOT_TYPE);
        }
        return root;
      };
      _proto._getRootField = function _getRootField(selector, fieldName, plural) {
        var field = selector.node.selections.find(function(selection) {
          return selection.kind === "LinkedField" && selection.name === fieldName || selection.kind === "RequiredField" && selection.field.name === fieldName;
        });
        if (field && field.kind === "RequiredField") {
          field = field.field;
        }
        !(field && field.kind === "LinkedField") ? true ? invariant(false, "RelayRecordSourceSelectorProxy#getRootField(): Cannot find root field `%s`, no such field is defined on GraphQL document `%s`.", fieldName, selector.node.name) : invariant(false) : void 0;
        !(field.plural === plural) ? true ? invariant(false, "RelayRecordSourceSelectorProxy#getRootField(): Expected root field `%s` to be %s.", fieldName, plural ? "plural" : "singular") : invariant(false) : void 0;
        return field;
      };
      _proto.getRootField = function getRootField(fieldName) {
        var field = this._getRootField(this._readSelector, fieldName, false);
        var storageKey = getStorageKey(field, this._readSelector.variables);
        return this.getOperationRoot().getLinkedRecord(storageKey);
      };
      _proto.getPluralRootField = function getPluralRootField(fieldName) {
        var field = this._getRootField(this._readSelector, fieldName, true);
        var storageKey = getStorageKey(field, this._readSelector.variables);
        return this.getOperationRoot().getLinkedRecords(storageKey);
      };
      _proto.invalidateStore = function invalidateStore() {
        this.__recordSource.invalidateStore();
      };
      _proto.readUpdatableQuery = function readUpdatableQuery(query, variables) {
        return _readUpdatableQuery(query, variables, this, this._missingFieldHandlers);
      };
      _proto.readUpdatableFragment = function readUpdatableFragment(fragment, fragmentReference) {
        return _readUpdatableFragment(fragment, fragmentReference, this, this._missingFieldHandlers);
      };
      return RelayRecordSourceSelectorProxy2;
    }();
    module.exports = RelayRecordSourceSelectorProxy;
  }
});

// node_modules/relay-runtime/lib/util/shallowFreeze.js
var require_shallowFreeze = __commonJS({
  "node_modules/relay-runtime/lib/util/shallowFreeze.js"(exports, module) {
    "use strict";
    module.exports = function shallowFreeze(value) {
      if (typeof value === "object" && value != null && (Array.isArray(value) || value.constructor === Object)) {
        Object.freeze(value);
      }
    };
  }
});

// node_modules/relay-runtime/lib/store/ResolverCache.js
var require_ResolverCache = __commonJS({
  "node_modules/relay-runtime/lib/store/ResolverCache.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var recycleNodesInto = require_recycleNodesInto();
    var _require = require_RelayConcreteNode();
    var RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var shallowFreeze = require_shallowFreeze();
    var _require2 = require_ClientID();
    var generateClientID = _require2.generateClientID;
    var RelayModernRecord = require_RelayModernRecord();
    var _require3 = require_RelayStoreUtils();
    var RELAY_RESOLVER_ERROR_KEY = _require3.RELAY_RESOLVER_ERROR_KEY;
    var RELAY_RESOLVER_INVALIDATION_KEY = _require3.RELAY_RESOLVER_INVALIDATION_KEY;
    var RELAY_RESOLVER_SNAPSHOT_KEY = _require3.RELAY_RESOLVER_SNAPSHOT_KEY;
    var RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY;
    var getStorageKey = _require3.getStorageKey;
    var invariant = require_browser();
    var warning = require_warning();
    var emptySet = /* @__PURE__ */ new Set();
    var NoopResolverCache = function() {
      function NoopResolverCache2() {
      }
      var _proto = NoopResolverCache2.prototype;
      _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
        !(field.kind !== RELAY_LIVE_RESOLVER) ? true ? invariant(false, "This store does not support Live Resolvers") : invariant(false) : void 0;
        var _evaluate = evaluate(), resolverResult = _evaluate.resolverResult, snapshot = _evaluate.snapshot, error = _evaluate.error;
        return [resolverResult, void 0, error, snapshot, void 0, void 0];
      };
      _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {
      };
      _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
        true ? true ? invariant(false, "Client Edges to Client Objects are not supported in this version of Relay Store") : invariant(false) : void 0;
      };
      _proto.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {
      };
      return NoopResolverCache2;
    }();
    function addDependencyEdge(edges, from, to) {
      var set = edges.get(from);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        edges.set(from, set);
      }
      set.add(to);
    }
    var RecordResolverCache = function() {
      function RecordResolverCache2(getRecordSource) {
        this._resolverIDToRecordIDs = /* @__PURE__ */ new Map();
        this._recordIDToResolverIDs = /* @__PURE__ */ new Map();
        this._getRecordSource = getRecordSource;
      }
      var _proto2 = RecordResolverCache2.prototype;
      _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
        var recordSource = this._getRecordSource();
        var record = recordSource.get(recordID);
        !(record != null) ? true ? invariant(false, "We expect record to exist in the store.") : invariant(false) : void 0;
        var storageKey = getStorageKey(field, variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);
        if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {
          var _linkedID;
          linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);
          linkedRecord = RelayModernRecord.create(linkedID, "__RELAY_RESOLVER__");
          var evaluationResult = evaluate();
          shallowFreeze(evaluationResult.resolverResult);
          RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);
          RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);
          RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);
          recordSource.set(linkedID, linkedRecord);
          var currentRecord = recordSource.get(recordID);
          !(currentRecord != null) ? true ? invariant(false, "Expected the parent record to still be in the record source.") : invariant(false) : void 0;
          var nextRecord = RelayModernRecord.clone(currentRecord);
          RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);
          recordSource.set(recordID, nextRecord);
          if (field.fragment != null) {
            var _evaluationResult$sna;
            var fragmentStorageKey = getStorageKey(field.fragment, variables);
            var resolverID = generateClientID(recordID, fragmentStorageKey);
            addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);
            addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);
            var seenRecordIds = (_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.seenRecords;
            if (seenRecordIds != null) {
              var _iterator = (0, _createForOfIteratorHelper2["default"])(seenRecordIds), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var seenRecordID = _step.value;
                  addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          }
        }
        var answer = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY);
        var snapshot = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY);
        var error = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY);
        return [answer, linkedID, error, snapshot, void 0, void 0];
      };
      _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {
        var recordSource = this._getRecordSource();
        var visited = /* @__PURE__ */ new Set();
        var recordsToVisit = Array.from(updatedDataIDs);
        while (recordsToVisit.length) {
          var recordID = recordsToVisit.pop();
          updatedDataIDs.add(recordID);
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _this$_recordIDToReso;
              var fragment = _step2.value;
              if (!visited.has(fragment)) {
                var _iterator3 = (0, _createForOfIteratorHelper2["default"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet), _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                    var _this$_resolverIDToRe;
                    var anotherRecordID = _step3.value;
                    this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);
                    if (!visited.has(anotherRecordID)) {
                      recordsToVisit.push(anotherRecordID);
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      };
      _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, updatedDataIDs) {
        var record = recordSource.get(dataID);
        if (!record) {
          true ? warning(false, "Expected a resolver record with ID %s, but it was missing.", dataID) : void 0;
          return;
        }
        var nextRecord = RelayModernRecord.clone(record);
        RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);
        recordSource.set(dataID, nextRecord);
      };
      _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {
        if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {
          return false;
        }
        var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);
        var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;
        var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;
        if (originalInputs == null || readerSelector == null) {
          true ? warning(false, "Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.", RelayModernRecord.getDataID(record)) : void 0;
          return true;
        }
        var _getDataForResolverFr = getDataForResolverFragment(readerSelector), latestValues = _getDataForResolverFr.data;
        var recycled = recycleNodesInto(originalInputs, latestValues);
        if (recycled !== originalInputs) {
          return true;
        }
        if (RelayFeatureFlags.MARK_RESOLVER_VALUES_AS_CLEAN_AFTER_FRAGMENT_REREAD) {
          var nextRecord = RelayModernRecord.clone(record);
          RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, false);
          var recordSource = this._getRecordSource();
          recordSource.set(RelayModernRecord.getDataID(record), nextRecord);
        }
        return false;
      };
      _proto2.ensureClientRecord = function ensureClientRecord(id, typename) {
        true ? true ? invariant(false, "Client Edges to Client Objects are not supported in this version of Relay Store") : invariant(false) : void 0;
      };
      _proto2.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {
        true ? true ? invariant(false, "Processing @outputType records is not supported in this version of Relay Store") : invariant(false) : void 0;
      };
      return RecordResolverCache2;
    }();
    module.exports = {
      NoopResolverCache,
      RecordResolverCache
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayReader.js
var require_RelayReader = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayReader.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var _require = require_LiveResolverSuspenseSentinel();
    var isSuspenseSentinel = _require.isSuspenseSentinel;
    var RelayConcreteVariables = require_RelayConcreteVariables();
    var RelayModernRecord = require_RelayModernRecord();
    var _require2 = require_RelayStoreUtils();
    var CLIENT_EDGE_TRAVERSAL_PATH = _require2.CLIENT_EDGE_TRAVERSAL_PATH;
    var FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY;
    var FRAGMENT_PROP_NAME_KEY = _require2.FRAGMENT_PROP_NAME_KEY;
    var FRAGMENTS_KEY = _require2.FRAGMENTS_KEY;
    var ID_KEY = _require2.ID_KEY;
    var MODULE_COMPONENT_KEY = _require2.MODULE_COMPONENT_KEY;
    var ROOT_ID = _require2.ROOT_ID;
    var getArgumentValues = _require2.getArgumentValues;
    var getModuleComponentKey = _require2.getModuleComponentKey;
    var getStorageKey = _require2.getStorageKey;
    var _require3 = require_ResolverCache();
    var NoopResolverCache = _require3.NoopResolverCache;
    var _require4 = require_ResolverFragments();
    var RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL = _require4.RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL;
    var withResolverContext = _require4.withResolverContext;
    var _require5 = require_TypeID();
    var generateTypeID = _require5.generateTypeID;
    var invariant = require_browser();
    function read(recordSource, selector, resolverCache, resolverContext) {
      var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache(), resolverContext);
      return reader.read();
    }
    var RelayReader = function() {
      function RelayReader2(recordSource, selector, resolverCache, resolverContext) {
        var _selector$clientEdgeT;
        this._clientEdgeTraversalPath = (_selector$clientEdgeT = selector.clientEdgeTraversalPath) !== null && _selector$clientEdgeT !== void 0 && _selector$clientEdgeT.length ? (0, _toConsumableArray2["default"])(selector.clientEdgeTraversalPath) : [];
        this._missingClientEdges = [];
        this._missingLiveResolverFields = [];
        this._isMissingData = false;
        this._isWithinUnmatchedTypeRefinement = false;
        this._missingRequiredFields = null;
        this._errorResponseFields = null;
        this._owner = selector.owner;
        this._recordSource = recordSource;
        this._seenRecords = /* @__PURE__ */ new Set();
        this._selector = selector;
        this._variables = selector.variables;
        this._resolverCache = resolverCache;
        this._resolverErrors = [];
        this._fragmentName = selector.node.name;
        this._updatedDataIDs = /* @__PURE__ */ new Set();
        this._resolverContext = resolverContext;
      }
      var _proto = RelayReader2.prototype;
      _proto.read = function read2() {
        var _this$_selector = this._selector, node = _this$_selector.node, dataID = _this$_selector.dataID, isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;
        var abstractKey = node.abstractKey;
        var record = this._recordSource.get(dataID);
        var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement;
        if (isDataExpectedToBePresent && abstractKey == null && record != null) {
          if (!this._recordMatchesTypeCondition(record, node.type)) {
            isDataExpectedToBePresent = false;
          }
        }
        if (isDataExpectedToBePresent && abstractKey != null && record != null) {
          var implementsInterface = this._implementsInterface(record, abstractKey);
          if (implementsInterface === false) {
            isDataExpectedToBePresent = false;
          }
        }
        this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;
        var data = this._traverse(node, dataID, null);
        if (this._updatedDataIDs.size > 0) {
          this._resolverCache.notifyUpdatedSubscribers(this._updatedDataIDs);
          this._updatedDataIDs.clear();
        }
        return {
          data,
          isMissingData: this._isMissingData && isDataExpectedToBePresent,
          missingClientEdges: this._missingClientEdges.length ? this._missingClientEdges : null,
          missingLiveResolverFields: this._missingLiveResolverFields,
          seenRecords: this._seenRecords,
          selector: this._selector,
          missingRequiredFields: this._missingRequiredFields,
          relayResolverErrors: this._resolverErrors,
          errorResponseFields: this._errorResponseFields
        };
      };
      _proto._maybeAddErrorResponseFields = function _maybeAddErrorResponseFields(record, storageKey) {
        var errors = RelayModernRecord.getErrors(record, storageKey);
        if (errors == null) {
          return;
        }
        var owner = this._fragmentName;
        if (this._errorResponseFields == null) {
          this._errorResponseFields = [];
        }
        var _iterator = (0, _createForOfIteratorHelper2["default"])(errors), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _error$path;
            var error = _step.value;
            this._errorResponseFields.push({
              owner,
              path: ((_error$path = error.path) !== null && _error$path !== void 0 ? _error$path : []).join("."),
              type: "PAYLOAD_ERROR",
              error
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };
      _proto._markDataAsMissing = function _markDataAsMissing() {
        var _this = this;
        var _this$_errorResponseF;
        var alreadyInErrors = Boolean((_this$_errorResponseF = this._errorResponseFields) === null || _this$_errorResponseF === void 0 ? void 0 : _this$_errorResponseF.some(function(err) {
          return err.owner === _this._fragmentName && err.type === "MISSING_DATA";
        }));
        if (!alreadyInErrors) {
          if (this._errorResponseFields == null) {
            this._errorResponseFields = [];
          }
          this._errorResponseFields.push({
            owner: this._fragmentName,
            path: "",
            type: "MISSING_DATA",
            error: {
              message: "Relay: Missing data for one or more fields in " + this._fragmentName
            }
          });
        }
        this._isMissingData = true;
        if (this._clientEdgeTraversalPath.length) {
          var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1];
          if (top !== null) {
            this._missingClientEdges.push({
              request: top.readerClientEdge.operation,
              clientEdgeDestinationID: top.clientEdgeDestinationID
            });
          }
        }
      };
      _proto._traverse = function _traverse(node, dataID, prevData) {
        var record = this._recordSource.get(dataID);
        this._seenRecords.add(dataID);
        if (record == null) {
          if (record === void 0) {
            this._markDataAsMissing();
          }
          return record;
        }
        var data = prevData || {};
        var hadRequiredData = this._traverseSelections(node.selections, record, data);
        return hadRequiredData ? data : null;
      };
      _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? true ? invariant(false, "RelayReader(): Undefined variable `%s`.", name) : invariant(false) : void 0;
        return this._variables[name];
      };
      _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action) {
        var _this$_missingRequire;
        if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === "THROW") {
          return;
        }
        var owner = this._fragmentName;
        switch (action) {
          case "THROW":
            this._missingRequiredFields = {
              action,
              field: {
                path: fieldPath,
                owner
              }
            };
            return;
          case "LOG":
            if (this._missingRequiredFields == null) {
              this._missingRequiredFields = {
                action,
                fields: [{
                  path: fieldPath,
                  owner
                }]
              };
            } else {
              this._missingRequiredFields = {
                action,
                fields: [].concat((0, _toConsumableArray2["default"])(this._missingRequiredFields.fields), [{
                  path: fieldPath,
                  owner
                }])
              };
            }
            return;
          default:
            action;
        }
      };
      _proto._handleCatchToResult = function _handleCatchToResult(selection, record, data, value) {
        var _selection$field$back, _selection$field, _field$alias, _this$_errorResponseF2, _this$_missingRequire2;
        var field = (_selection$field$back = (_selection$field = selection.field) === null || _selection$field === void 0 ? void 0 : _selection$field.backingField) !== null && _selection$field$back !== void 0 ? _selection$field$back : selection.field;
        var fieldName = (_field$alias = field === null || field === void 0 ? void 0 : field.alias) !== null && _field$alias !== void 0 ? _field$alias : field === null || field === void 0 ? void 0 : field.name;
        !(fieldName != null) ? true ? invariant(false, "Couldn't determine field name for this field. It might be a ReaderClientExtension - which is not yet supported.") : invariant(false) : void 0;
        var errors = (_this$_errorResponseF2 = this._errorResponseFields) === null || _this$_errorResponseF2 === void 0 ? void 0 : _this$_errorResponseF2.map(function(error) {
          return error.error;
        });
        if (this._resolverErrors.length > 0) {
          if (errors == null) {
            errors = [];
          }
          for (var i = 0; i < this._resolverErrors.length; i++) {
            var resolverError = this._resolverErrors[i];
            errors.push({
              message: "Relay: Error in resolver for field at ".concat(resolverError.field.path, " in ").concat(resolverError.field.owner)
            });
          }
        }
        if (((_this$_missingRequire2 = this._missingRequiredFields) === null || _this$_missingRequire2 === void 0 ? void 0 : _this$_missingRequire2.action) === "THROW") {
          var _this$_missingRequire3 = this._missingRequiredFields.field, owner = _this$_missingRequire3.owner, path = _this$_missingRequire3.path;
          var missingFieldError = {
            message: "Relay: Missing @required value at path '".concat(path, "' in '").concat(owner, "'.")
          };
          if (errors == null) {
            errors = [missingFieldError];
          } else {
            errors.push(missingFieldError);
          }
        }
        data[fieldName] = errors != null ? {
          ok: false,
          errors
        } : {
          ok: true,
          value
        };
      };
      _proto._handleRequiredFieldValue = function _handleRequiredFieldValue(selection, value) {
        if (value == null) {
          var action = selection.action;
          if (action !== "NONE") {
            this._maybeReportUnexpectedNull(selection.path, action);
          }
          return false;
        }
        return true;
      };
      _proto._traverseSelections = function _traverseSelections(selections, record, data) {
        for (var i = 0; i < selections.length; i++) {
          var selection = selections[i];
          switch (selection.kind) {
            case "RequiredField":
              var requiredFieldValue = this._readClientSideDirectiveField(selection, record, data);
              if (!this._handleRequiredFieldValue(selection, requiredFieldValue)) {
                return false;
              }
              break;
            case "CatchField": {
              var previousResponseFields = this._errorResponseFields;
              var previousMissingRequiredFields = this._missingRequiredFields;
              var previousResolverErrors = this._resolverErrors;
              this._errorResponseFields = null;
              this._missingRequiredFields = null;
              this._resolverErrors = [];
              var catchFieldValue = this._readClientSideDirectiveField(selection, record, data);
              if (selection.to === "RESULT") {
                this._handleCatchToResult(selection, record, data, catchFieldValue);
              }
              var childrenMissingRequiredFields = this._missingRequiredFields;
              this._resolverErrors = previousResolverErrors;
              this._errorResponseFields = previousResponseFields;
              this._missingRequiredFields = previousMissingRequiredFields;
              if ((childrenMissingRequiredFields === null || childrenMissingRequiredFields === void 0 ? void 0 : childrenMissingRequiredFields.action) === "LOG") {
                this._addMissingRequiredFields(childrenMissingRequiredFields);
              }
              break;
            }
            case "ScalarField":
              this._readScalar(selection, record, data);
              break;
            case "LinkedField":
              if (selection.plural) {
                this._readPluralLink(selection, record, data);
              } else {
                this._readLink(selection, record, data);
              }
              break;
            case "Condition":
              var conditionValue = Boolean(this._getVariableValue(selection.condition));
              if (conditionValue === selection.passingValue) {
                var hasExpectedData = this._traverseSelections(selection.selections, record, data);
                if (!hasExpectedData) {
                  return false;
                }
              }
              break;
            case "InlineFragment": {
              var _hasExpectedData = this._readInlineFragment(selection, record, data, false);
              if (_hasExpectedData === false) {
                return false;
              }
              break;
            }
            case "RelayLiveResolver":
            case "RelayResolver": {
              if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {
                throw new Error("Relay Resolver fields are not yet supported.");
              }
              this._readResolverField(selection, record, data);
              break;
            }
            case "FragmentSpread":
              this._createFragmentPointer(selection, record, data);
              break;
            case "AliasedInlineFragmentSpread": {
              var fieldValue = this._readInlineFragment(selection.fragment, record, {}, true);
              if (fieldValue === false) {
                fieldValue = null;
              }
              data[selection.name] = fieldValue;
              break;
            }
            case "ModuleImport":
              this._readModuleImport(selection, record, data);
              break;
            case "InlineDataFragmentSpread":
              this._createInlineDataOrResolverFragmentPointer(selection, record, data);
              break;
            case "Defer":
            case "ClientExtension": {
              var isMissingData = this._isMissingData;
              var alreadyMissingClientEdges = this._missingClientEdges.length;
              this._clientEdgeTraversalPath.push(null);
              var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);
              this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges || this._missingLiveResolverFields.length > 0;
              this._clientEdgeTraversalPath.pop();
              if (!_hasExpectedData2) {
                return false;
              }
              break;
            }
            case "Stream": {
              var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);
              if (!_hasExpectedData3) {
                return false;
              }
              break;
            }
            case "ActorChange":
              this._readActorChange(selection, record, data);
              break;
            case "ClientEdgeToClientObject":
            case "ClientEdgeToServerObject":
              this._readClientEdge(selection, record, data);
              break;
            default:
              selection;
              true ? true ? invariant(false, "RelayReader(): Unexpected ast kind `%s`.", selection.kind) : invariant(false) : void 0;
          }
        }
        return true;
      };
      _proto._readClientSideDirectiveField = function _readClientSideDirectiveField(selection, record, data) {
        switch (selection.field.kind) {
          case "ScalarField":
            return this._readScalar(selection.field, record, data);
          case "LinkedField":
            if (selection.field.plural) {
              return this._readPluralLink(selection.field, record, data);
            } else {
              return this._readLink(selection.field, record, data);
            }
          case "RelayResolver":
            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {
              throw new Error("Relay Resolver fields are not yet supported.");
            }
            return this._readResolverField(selection.field, record, data);
          case "RelayLiveResolver":
            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {
              throw new Error("Relay Resolver fields are not yet supported.");
            }
            return this._readResolverField(selection.field, record, data);
          case "ClientEdgeToClientObject":
          case "ClientEdgeToServerObject":
            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {
              throw new Error("Relay Resolver fields are not yet supported.");
            }
            return this._readClientEdge(selection.field, record, data);
          default:
            selection.field.kind;
            true ? true ? invariant(false, "RelayReader(): Unexpected ast kind `%s`.", selection.kind) : invariant(false) : void 0;
        }
      };
      _proto._readResolverField = function _readResolverField(field, record, data) {
        var _field$alias2;
        var parentRecordID = RelayModernRecord.getDataID(record);
        var result = this._readResolverFieldImpl(field, parentRecordID);
        var fieldName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;
        data[fieldName] = result;
        return result;
      };
      _proto._readResolverFieldImpl = function _readResolverFieldImpl(field, parentRecordID) {
        var _this2 = this;
        var fragment = field.fragment;
        var snapshot;
        var getDataForResolverFragment = function getDataForResolverFragment2(singularReaderSelector) {
          if (snapshot != null) {
            return {
              data: snapshot.data,
              isMissingData: snapshot.isMissingData
            };
          }
          snapshot = read(_this2._recordSource, singularReaderSelector, _this2._resolverCache);
          return {
            data: snapshot.data,
            isMissingData: snapshot.isMissingData
          };
        };
        var evaluate = function evaluate2() {
          if (fragment != null) {
            var key = {
              __id: parentRecordID,
              __fragmentOwner: _this2._owner,
              __fragments: (0, _defineProperty2["default"])({}, fragment.name, fragment.args ? getArgumentValues(fragment.args, _this2._variables) : {})
            };
            var resolverContext = {
              getDataForResolverFragment
            };
            return withResolverContext(resolverContext, function() {
              var _getResolverValue = getResolverValue(field, _this2._variables, key, _this2._resolverContext), resolverResult2 = _getResolverValue[0], resolverError2 = _getResolverValue[1];
              return {
                resolverResult: resolverResult2,
                snapshot,
                error: resolverError2
              };
            });
          } else {
            var _getResolverValue2 = getResolverValue(field, _this2._variables, null, _this2._resolverContext), resolverResult = _getResolverValue2[0], _resolverError = _getResolverValue2[1];
            return {
              resolverResult,
              snapshot: void 0,
              error: _resolverError
            };
          }
        };
        var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(parentRecordID, field, this._variables, evaluate, getDataForResolverFragment), result = _this$_resolverCache$[0], seenRecord = _this$_resolverCache$[1], resolverError = _this$_resolverCache$[2], cachedSnapshot = _this$_resolverCache$[3], suspenseID = _this$_resolverCache$[4], updatedDataIDs = _this$_resolverCache$[5];
        this._propogateResolverMetadata(field.path, cachedSnapshot, resolverError, seenRecord, suspenseID, updatedDataIDs);
        return result;
      };
      _proto._propogateResolverMetadata = function _propogateResolverMetadata(fieldPath, cachedSnapshot, resolverError, seenRecord, suspenseID, updatedDataIDs) {
        if (cachedSnapshot != null) {
          if (cachedSnapshot.missingRequiredFields != null) {
            this._addMissingRequiredFields(cachedSnapshot.missingRequiredFields);
          }
          if (cachedSnapshot.missingClientEdges != null) {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(cachedSnapshot.missingClientEdges), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var missing = _step2.value;
                this._missingClientEdges.push(missing);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          if (cachedSnapshot.missingLiveResolverFields != null) {
            this._isMissingData = this._isMissingData || cachedSnapshot.missingLiveResolverFields.length > 0;
            var _iterator3 = (0, _createForOfIteratorHelper2["default"])(cachedSnapshot.missingLiveResolverFields), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var missingResolverField = _step3.value;
                this._missingLiveResolverFields.push(missingResolverField);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
          var _iterator4 = (0, _createForOfIteratorHelper2["default"])(cachedSnapshot.relayResolverErrors), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var error = _step4.value;
              this._resolverErrors.push(error);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          this._isMissingData = this._isMissingData || cachedSnapshot.isMissingData;
        }
        if (resolverError) {
          this._resolverErrors.push({
            field: {
              path: fieldPath,
              owner: this._fragmentName
            },
            error: resolverError
          });
        }
        if (seenRecord != null) {
          this._seenRecords.add(seenRecord);
        }
        if (suspenseID != null) {
          this._isMissingData = true;
          this._missingLiveResolverFields.push({
            path: "".concat(this._fragmentName, ".").concat(fieldPath),
            liveStateID: suspenseID
          });
        }
        if (updatedDataIDs != null) {
          var _iterator5 = (0, _createForOfIteratorHelper2["default"])(updatedDataIDs), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var recordID = _step5.value;
              this._updatedDataIDs.add(recordID);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      };
      _proto._readClientEdge = function _readClientEdge(field, record, data) {
        var _this3 = this;
        var _backingField$alias;
        var backingField = field.backingField;
        !(backingField.kind !== "ClientExtension") ? true ? invariant(false, "Client extension client edges are not yet implemented.") : invariant(false) : void 0;
        var fieldName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;
        var backingFieldData = {};
        this._traverseSelections([backingField], record, backingFieldData);
        var clientEdgeResolverResponse = backingFieldData[fieldName];
        if (clientEdgeResolverResponse == null || isSuspenseSentinel(clientEdgeResolverResponse)) {
          data[fieldName] = clientEdgeResolverResponse;
          return clientEdgeResolverResponse;
        }
        if (field.linkedField.plural) {
          !Array.isArray(clientEdgeResolverResponse) ? true ? invariant(false, "Expected plural Client Edge Relay Resolver to return an array containing IDs or objects with shape {id}.") : invariant(false) : void 0;
          var storeIDs;
          !(field.kind === "ClientEdgeToClientObject") ? true ? invariant(false, "Unexpected Client Edge to plural server type. This should be prevented by the compiler.") : invariant(false) : void 0;
          if (field.backingField.normalizationInfo == null) {
            storeIDs = clientEdgeResolverResponse.map(function(itemResponse) {
              var _field$concreteType;
              var concreteType2 = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : itemResponse.__typename;
              !(typeof concreteType2 === "string") ? true ? invariant(false, "Expected resolver modeling an edge to an abstract type to return an object with a `__typename` property.") : invariant(false) : void 0;
              var localId = extractIdFromResponse(itemResponse);
              var id2 = _this3._resolverCache.ensureClientRecord(localId, concreteType2);
              var modelResolvers2 = field.modelResolvers;
              if (modelResolvers2 != null) {
                var modelResolver2 = modelResolvers2[concreteType2];
                !(modelResolver2 !== void 0) ? true ? invariant(false, "Invalid `__typename` returned by resolver. Expected one of ".concat(Object.keys(modelResolvers2).join(", "), " but got `").concat(concreteType2, "`.")) : invariant(false) : void 0;
                var model2 = _this3._readResolverFieldImpl(modelResolver2, id2);
                return model2 != null ? id2 : null;
              }
              return id2;
            });
          } else {
            storeIDs = clientEdgeResolverResponse.map(extractIdFromResponse);
          }
          this._clientEdgeTraversalPath.push(null);
          var edgeValues = this._readLinkedIds(field.linkedField, storeIDs, record, data);
          this._clientEdgeTraversalPath.pop();
          data[fieldName] = edgeValues;
          return edgeValues;
        } else {
          var _field$concreteType2;
          var id = extractIdFromResponse(clientEdgeResolverResponse);
          var storeID;
          var concreteType = (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : clientEdgeResolverResponse.__typename;
          var traversalPathSegment;
          if (field.kind === "ClientEdgeToClientObject") {
            if (field.backingField.normalizationInfo == null) {
              !(typeof concreteType === "string") ? true ? invariant(false, "Expected resolver modeling an edge to an abstract type to return an object with a `__typename` property.") : invariant(false) : void 0;
              storeID = this._resolverCache.ensureClientRecord(id, concreteType);
              traversalPathSegment = null;
            } else {
              storeID = id;
              traversalPathSegment = null;
            }
          } else {
            storeID = id;
            traversalPathSegment = {
              readerClientEdge: field,
              clientEdgeDestinationID: id
            };
          }
          var modelResolvers = field.modelResolvers;
          if (modelResolvers != null) {
            !(typeof concreteType === "string") ? true ? invariant(false, "Expected resolver modeling an edge to an abstract type to return an object with a `__typename` property.") : invariant(false) : void 0;
            var modelResolver = modelResolvers[concreteType];
            !(modelResolver !== void 0) ? true ? invariant(false, "Invalid `__typename` returned by resolver. Expected one of ".concat(Object.keys(modelResolvers).join(", "), " but got `").concat(concreteType, "`.")) : invariant(false) : void 0;
            var model = this._readResolverFieldImpl(modelResolver, storeID);
            if (model == null) {
              data[fieldName] = null;
              return null;
            }
          }
          this._clientEdgeTraversalPath.push(traversalPathSegment);
          var prevData = data[fieldName];
          !(prevData == null || typeof prevData === "object") ? true ? invariant(false, "RelayReader(): Expected data for field `%s` on record `%s` to be an object, got `%s`.", fieldName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;
          var edgeValue = this._traverse(field.linkedField, storeID, prevData);
          this._clientEdgeTraversalPath.pop();
          data[fieldName] = edgeValue;
          return edgeValue;
        }
      };
      _proto._readScalar = function _readScalar(field, record, data) {
        var _field$alias3;
        var fieldName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var value = RelayModernRecord.getValue(record, storageKey);
        if (value === null) {
          this._maybeAddErrorResponseFields(record, storageKey);
        } else if (value === void 0) {
          this._markDataAsMissing();
        }
        data[fieldName] = value;
        return value;
      };
      _proto._readLink = function _readLink(field, record, data) {
        var _field$alias4;
        var fieldName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (linkedID == null) {
          data[fieldName] = linkedID;
          if (linkedID === null) {
            this._maybeAddErrorResponseFields(record, storageKey);
          } else if (linkedID === void 0) {
            this._markDataAsMissing();
          }
          return linkedID;
        }
        var prevData = data[fieldName];
        !(prevData == null || typeof prevData === "object") ? true ? invariant(false, "RelayReader(): Expected data for field `%s` on record `%s` to be an object, got `%s`.", fieldName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;
        var value = this._traverse(field, linkedID, prevData);
        data[fieldName] = value;
        return value;
      };
      _proto._readActorChange = function _readActorChange(field, record, data) {
        var _field$alias5;
        var fieldName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);
        if (externalRef == null) {
          data[fieldName] = externalRef;
          if (externalRef === void 0) {
            this._markDataAsMissing();
          } else if (externalRef === null) {
            this._maybeAddErrorResponseFields(record, storageKey);
          }
          return data[fieldName];
        }
        var actorIdentifier = externalRef[0], dataID = externalRef[1];
        var fragmentRef = {};
        this._createFragmentPointer(field.fragmentSpread, RelayModernRecord.fromObject({
          __id: dataID
        }), fragmentRef);
        data[fieldName] = {
          __fragmentRef: fragmentRef,
          __viewer: actorIdentifier
        };
        return data[fieldName];
      };
      _proto._readPluralLink = function _readPluralLink(field, record, data) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        if (linkedIDs === null) {
          this._maybeAddErrorResponseFields(record, storageKey);
        }
        return this._readLinkedIds(field, linkedIDs, record, data);
      };
      _proto._readLinkedIds = function _readLinkedIds(field, linkedIDs, record, data) {
        var _this4 = this;
        var _field$alias6;
        var fieldName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;
        if (linkedIDs == null) {
          data[fieldName] = linkedIDs;
          if (linkedIDs === void 0) {
            this._markDataAsMissing();
          }
          return linkedIDs;
        }
        var prevData = data[fieldName];
        !(prevData == null || Array.isArray(prevData)) ? true ? invariant(false, "RelayReader(): Expected data for field `%s` on record `%s` to be an array, got `%s`.", fieldName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;
        var linkedArray = prevData || [];
        linkedIDs.forEach(function(linkedID, nextIndex) {
          if (linkedID == null) {
            if (linkedID === void 0) {
              _this4._markDataAsMissing();
            }
            linkedArray[nextIndex] = linkedID;
            return;
          }
          var prevItem = linkedArray[nextIndex];
          !(prevItem == null || typeof prevItem === "object") ? true ? invariant(false, "RelayReader(): Expected data for field `%s` on record `%s` to be an object, got `%s`.", fieldName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0;
          linkedArray[nextIndex] = _this4._traverse(field, linkedID, prevItem);
        });
        data[fieldName] = linkedArray;
        return linkedArray;
      };
      _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {
        var _moduleImport$compone;
        var componentKey = getModuleComponentKey(moduleImport.documentName);
        var component = (_moduleImport$compone = moduleImport.componentModuleProvider) !== null && _moduleImport$compone !== void 0 ? _moduleImport$compone : RelayModernRecord.getValue(record, componentKey);
        if (component == null) {
          if (component === void 0) {
            this._markDataAsMissing();
          }
          return;
        }
        this._createFragmentPointer({
          kind: "FragmentSpread",
          name: moduleImport.fragmentName,
          args: moduleImport.args
        }, record, data);
        data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;
        data[MODULE_COMPONENT_KEY] = component;
      };
      _proto._readInlineFragment = function _readInlineFragment(inlineFragment, record, data, skipUnmatchedAbstractTypes) {
        if (inlineFragment.type == null) {
          var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);
          if (hasExpectedData === false) {
            return false;
          }
          return data;
        }
        var abstractKey = inlineFragment.abstractKey;
        if (abstractKey == null) {
          if (!this._recordMatchesTypeCondition(record, inlineFragment.type)) {
            return null;
          } else {
            var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);
            if (!hasExpectedData) {
              return false;
            }
          }
        } else {
          var implementsInterface = this._implementsInterface(record, abstractKey);
          if (implementsInterface === false && skipUnmatchedAbstractTypes) {
            return null;
          }
          var parentIsMissingData = this._isMissingData;
          var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;
          this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;
          var hasMissingData = this._traverseSelections(inlineFragment.selections, record, data);
          this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;
          if (implementsInterface === false) {
            this._isMissingData = parentIsMissingData;
            return null;
          } else if (implementsInterface == null) {
            return void 0;
          } else if (hasMissingData === false) {
            return false;
          }
        }
        return data;
      };
      _proto._recordMatchesTypeCondition = function _recordMatchesTypeCondition(record, type) {
        var typeName = RelayModernRecord.getType(record);
        return typeName != null && typeName === type || RelayModernRecord.getDataID(record) === ROOT_ID;
      };
      _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {
        var fragmentPointers = data[FRAGMENTS_KEY];
        if (fragmentPointers == null) {
          fragmentPointers = data[FRAGMENTS_KEY] = {};
        }
        !(typeof fragmentPointers === "object" && fragmentPointers != null) ? true ? invariant(false, "RelayReader: Expected fragment spread data to be an object, got `%s`.", fragmentPointers) : invariant(false) : void 0;
        if (data[ID_KEY] == null) {
          data[ID_KEY] = RelayModernRecord.getDataID(record);
        }
        fragmentPointers[fragmentSpread.name] = getArgumentValues(fragmentSpread.args, this._variables, this._isWithinUnmatchedTypeRefinement);
        data[FRAGMENT_OWNER_KEY] = this._owner;
        if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {
          data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2["default"])(this._clientEdgeTraversalPath);
        }
      };
      _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {
        var fragmentPointers = data[FRAGMENTS_KEY];
        if (fragmentPointers == null) {
          fragmentPointers = data[FRAGMENTS_KEY] = {};
        }
        !(typeof fragmentPointers === "object" && fragmentPointers != null) ? true ? invariant(false, "RelayReader: Expected fragment spread data to be an object, got `%s`.", fragmentPointers) : invariant(false) : void 0;
        if (data[ID_KEY] == null) {
          data[ID_KEY] = RelayModernRecord.getDataID(record);
        }
        var inlineData = {};
        var parentFragmentName = this._fragmentName;
        this._fragmentName = fragmentSpreadOrFragment.name;
        var parentVariables = this._variables;
        var argumentVariables = fragmentSpreadOrFragment.args ? getArgumentValues(fragmentSpreadOrFragment.args, this._variables) : {};
        this._variables = RelayConcreteVariables.getFragmentVariables(fragmentSpreadOrFragment, this._owner.variables, argumentVariables);
        this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);
        this._variables = parentVariables;
        this._fragmentName = parentFragmentName;
        fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;
      };
      _proto._addMissingRequiredFields = function _addMissingRequiredFields(additional) {
        if (this._missingRequiredFields == null) {
          this._missingRequiredFields = additional;
          return;
        }
        if (this._missingRequiredFields.action === "THROW") {
          return;
        }
        if (additional.action === "THROW") {
          this._missingRequiredFields = additional;
          return;
        }
        this._missingRequiredFields = {
          action: "LOG",
          fields: [].concat((0, _toConsumableArray2["default"])(this._missingRequiredFields.fields), (0, _toConsumableArray2["default"])(additional.fields))
        };
      };
      _proto._implementsInterface = function _implementsInterface(record, abstractKey) {
        var typeName = RelayModernRecord.getType(record);
        var typeRecord = this._recordSource.get(generateTypeID(typeName));
        var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;
        if (implementsInterface == null) {
          this._markDataAsMissing();
        }
        return implementsInterface;
      };
      return RelayReader2;
    }();
    function getResolverValue(field, variables, fragmentKey, resolverContext) {
      var resolverFunction = typeof field.resolverModule === "function" ? field.resolverModule : field.resolverModule["default"];
      var resolverResult = null;
      var resolverError = null;
      try {
        var resolverFunctionArgs = [];
        if (field.fragment != null) {
          resolverFunctionArgs.push(fragmentKey);
        }
        var args = field.args ? getArgumentValues(field.args, variables) : void 0;
        resolverFunctionArgs.push(args);
        resolverFunctionArgs.push(resolverContext);
        resolverResult = resolverFunction.apply(null, resolverFunctionArgs);
      } catch (e) {
        if (e === RESOLVER_FRAGMENT_MISSING_DATA_SENTINEL) {
          resolverResult = void 0;
        } else {
          resolverError = e;
        }
      }
      return [resolverResult, resolverError];
    }
    function extractIdFromResponse(individualResponse) {
      if (typeof individualResponse === "string") {
        return individualResponse;
      } else if (typeof individualResponse === "object" && individualResponse != null && typeof individualResponse.id === "string") {
        return individualResponse.id;
      }
      true ? true ? invariant(false, "Expected object returned from an edge resolver to be a string or an object with an `id` property") : invariant(false) : void 0;
    }
    module.exports = {
      read
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayPublishQueue.js
var require_RelayPublishQueue = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayPublishQueue.js"(exports, module) {
    "use strict";
    var _global$ErrorUtils$ap;
    var _global$ErrorUtils;
    var RelayRecordSourceMutator = require_RelayRecordSourceMutator();
    var RelayRecordSourceProxy = require_RelayRecordSourceProxy();
    var RelayRecordSourceSelectorProxy = require_RelayRecordSourceSelectorProxy();
    var RelayReader = require_RelayReader();
    var RelayRecordSource = require_RelayRecordSource();
    var invariant = require_browser();
    var warning = require_warning();
    var _global = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : void 0;
    var applyWithGuard = (_global$ErrorUtils$ap = _global === null || _global === void 0 ? void 0 : (_global$ErrorUtils = _global.ErrorUtils) === null || _global$ErrorUtils === void 0 ? void 0 : _global$ErrorUtils.applyWithGuard) !== null && _global$ErrorUtils$ap !== void 0 ? _global$ErrorUtils$ap : function(callback, context, args, onError, name) {
      return callback.apply(context, args);
    };
    var RelayPublishQueue = function() {
      function RelayPublishQueue2(store, handlerProvider, getDataID, missingFieldHandlers) {
        this._hasStoreSnapshot = false;
        this._handlerProvider = handlerProvider || null;
        this._pendingBackupRebase = false;
        this._pendingData = /* @__PURE__ */ new Set();
        this._pendingOptimisticUpdates = /* @__PURE__ */ new Set();
        this._store = store;
        this._appliedOptimisticUpdates = /* @__PURE__ */ new Set();
        this._gcHold = null;
        this._getDataID = getDataID;
        this._missingFieldHandlers = missingFieldHandlers;
      }
      var _proto = RelayPublishQueue2.prototype;
      _proto.applyUpdate = function applyUpdate(updater) {
        !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? true ? invariant(false, "RelayPublishQueue: Cannot apply the same update function more than once concurrently.") : invariant(false) : void 0;
        this._pendingOptimisticUpdates.add(updater);
      };
      _proto.revertUpdate = function revertUpdate(updater) {
        if (this._pendingOptimisticUpdates.has(updater)) {
          this._pendingOptimisticUpdates["delete"](updater);
        } else if (this._appliedOptimisticUpdates.has(updater)) {
          this._pendingBackupRebase = true;
          this._appliedOptimisticUpdates["delete"](updater);
        }
      };
      _proto.revertAll = function revertAll() {
        this._pendingBackupRebase = true;
        this._pendingOptimisticUpdates.clear();
        this._appliedOptimisticUpdates.clear();
      };
      _proto.commitPayload = function commitPayload(operation, payload, updater) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
          kind: "payload",
          operation,
          payload,
          updater
        });
      };
      _proto.commitUpdate = function commitUpdate(updater) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
          kind: "updater",
          updater
        });
      };
      _proto.commitSource = function commitSource(source) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
          kind: "source",
          source
        });
      };
      _proto.run = function run(sourceOperation) {
        var runWillClearGcHold = this._appliedOptimisticUpdates === 0 && !!this._gcHold;
        var runIsANoop = !this._pendingBackupRebase && this._pendingOptimisticUpdates.size === 0 && !runWillClearGcHold;
        if (true) {
          true ? warning(!runIsANoop, "RelayPublishQueue.run was called, but the call would have been a noop.") : void 0;
          true ? warning(this._isRunning !== true, "A store update was detected within another store update. Please make sure new store updates aren't being executed within an updater function for a different update.") : void 0;
          this._isRunning = true;
        }
        if (runIsANoop) {
          if (true) {
            this._isRunning = false;
          }
          return [];
        }
        if (this._pendingBackupRebase) {
          if (this._hasStoreSnapshot) {
            this._store.restore();
            this._hasStoreSnapshot = false;
          }
        }
        var invalidatedStore = this._commitData();
        if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
          if (!this._hasStoreSnapshot) {
            this._store.snapshot();
            this._hasStoreSnapshot = true;
          }
          this._applyUpdates();
        }
        this._pendingBackupRebase = false;
        if (this._appliedOptimisticUpdates.size > 0) {
          if (!this._gcHold) {
            this._gcHold = this._store.holdGC();
          }
        } else {
          if (this._gcHold) {
            this._gcHold.dispose();
            this._gcHold = null;
          }
        }
        if (true) {
          this._isRunning = false;
        }
        return this._store.notify(sourceOperation, invalidatedStore);
      };
      _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {
        var _this = this;
        var payload = pendingPayload.payload, operation = pendingPayload.operation, updater = pendingPayload.updater;
        var source = payload.source, fieldPayloads = payload.fieldPayloads;
        var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);
        var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider, this._missingFieldHandlers);
        if (fieldPayloads && fieldPayloads.length) {
          fieldPayloads.forEach(function(fieldPayload) {
            var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);
            !handler ? true ? invariant(false, "RelayModernEnvironment: Expected a handler to be provided for handle `%s`.", fieldPayload.handle) : invariant(false) : void 0;
            handler.update(recordSourceProxy, fieldPayload);
          });
        }
        if (updater) {
          var selector = operation.fragment;
          !(selector != null) ? true ? invariant(false, "RelayModernEnvironment: Expected a selector to be provided with updater function.") : invariant(false) : void 0;
          var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector, this._missingFieldHandlers);
          var selectorData = lookupSelector(source, selector);
          updater(recordSourceSelectorProxy, selectorData);
        }
        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();
        this._store.publish(source, idsMarkedForInvalidation);
        return recordSourceProxy.isStoreMarkedForInvalidation();
      };
      _proto._commitData = function _commitData() {
        var _this2 = this;
        if (!this._pendingData.size) {
          return false;
        }
        var invalidatedStore = false;
        this._pendingData.forEach(function(data) {
          if (data.kind === "payload") {
            var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);
            invalidatedStore = invalidatedStore || payloadInvalidatedStore;
          } else if (data.kind === "source") {
            var source = data.source;
            _this2._store.publish(source);
          } else {
            var updater = data.updater;
            var sink = RelayRecordSource.create();
            var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);
            var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID, _this2._handlerProvider, _this2._missingFieldHandlers);
            applyWithGuard(updater, null, [recordSourceProxy], null, "RelayPublishQueue:commitData");
            invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();
            var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();
            _this2._store.publish(sink, idsMarkedForInvalidation);
          }
        });
        this._pendingData.clear();
        return invalidatedStore;
      };
      _proto._applyUpdates = function _applyUpdates() {
        var _this3 = this;
        var sink = RelayRecordSource.create();
        var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);
        var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider, this._missingFieldHandlers);
        var processUpdate = function processUpdate2(optimisticUpdate) {
          if (optimisticUpdate.storeUpdater) {
            var storeUpdater = optimisticUpdate.storeUpdater;
            applyWithGuard(storeUpdater, null, [recordSourceProxy], null, "RelayPublishQueue:applyUpdates");
          } else {
            var operation = optimisticUpdate.operation, payload = optimisticUpdate.payload, updater = optimisticUpdate.updater;
            var source = payload.source, fieldPayloads = payload.fieldPayloads;
            if (source) {
              recordSourceProxy.publishSource(source, fieldPayloads);
            }
            if (updater) {
              var selectorData;
              if (source) {
                selectorData = lookupSelector(source, operation.fragment);
              }
              var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment, _this3._missingFieldHandlers);
              applyWithGuard(updater, null, [recordSourceSelectorProxy, selectorData], null, "RelayPublishQueue:applyUpdates");
            }
          }
        };
        if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
          this._appliedOptimisticUpdates.forEach(processUpdate);
        }
        if (this._pendingOptimisticUpdates.size) {
          this._pendingOptimisticUpdates.forEach(function(optimisticUpdate) {
            processUpdate(optimisticUpdate);
            _this3._appliedOptimisticUpdates.add(optimisticUpdate);
          });
          this._pendingOptimisticUpdates.clear();
        }
        this._store.publish(sink);
      };
      return RelayPublishQueue2;
    }();
    function lookupSelector(source, selector) {
      var selectorData = RelayReader.read(source, selector).data;
      if (true) {
        var deepFreeze = require_deepFreeze();
        if (selectorData) {
          deepFreeze(selectorData);
        }
      }
      return selectorData;
    }
    module.exports = RelayPublishQueue;
  }
});

// node_modules/relay-runtime/lib/store/StoreInspector.js
var require_StoreInspector = __commonJS({
  "node_modules/relay-runtime/lib/store/StoreInspector.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var inspect = function inspect2() {
    };
    if (true) {
      formattersInstalled = false;
      installDevtoolFormatters = function installDevtoolFormatters2() {
        var _window$devtoolsForma;
        if (formattersInstalled) {
          return;
        }
        formattersInstalled = true;
        if (window.devtoolsFormatters == null) {
          window.devtoolsFormatters = [];
        }
        if (!Array.isArray(window.devtoolsFormatters)) {
          return;
        }
        console.info('Make sure to select "Enable custom formatters" in the Chrome Developer Tools settings, tab "Preferences" under the "Console" section.');
        (_window$devtoolsForma = window.devtoolsFormatters).push.apply(_window$devtoolsForma, (0, _toConsumableArray2["default"])(createFormatters()));
      };
      createFormatters = function createFormatters2() {
        var listStyle = {
          style: "list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal"
        };
        var keyStyle = {
          style: "rgb(136, 19, 145)"
        };
        var nullStyle = {
          style: "color: #777"
        };
        var reference = function reference2(object, config) {
          return object == null ? ["span", nullStyle, "undefined"] : ["object", {
            object,
            config
          }];
        };
        var renderRecordHeader = function renderRecordHeader2(record) {
          return ["span", {
            style: "font-style: italic"
          }, record.__typename, ["span", nullStyle, ' {id: "', record.__id, '", â€¦}']];
        };
        var isRecord = function isRecord2(o) {
          return o != null && typeof o.__id === "string";
        };
        var RecordEntry = function RecordEntry2(key, value) {
          this.key = key;
          this.value = value;
        };
        var renderRecordEntries = function renderRecordEntries2(record) {
          var children = Object.keys(record).map(function(key) {
            return ["li", {}, ["object", {
              object: new RecordEntry(key, record[key])
            }]];
          });
          return ["ol", listStyle].concat((0, _toConsumableArray2["default"])(children));
        };
        var recordFormatter = {
          header: function header(obj) {
            if (!isRecord(obj)) {
              return null;
            }
            return renderRecordHeader(obj);
          },
          hasBody: function hasBody(obj) {
            return true;
          },
          body: function body(obj) {
            return renderRecordEntries(obj);
          }
        };
        var recordEntryFormatter = {
          header: function header(obj) {
            if (obj instanceof RecordEntry) {
              var value = isRecord(obj.value) ? renderRecordHeader(obj.value) : reference(obj.value);
              return ["span", keyStyle, obj.key, ": ", value];
            }
            return null;
          },
          hasBody: function hasBody(obj) {
            return isRecord(obj.value);
          },
          body: function body(obj) {
            return renderRecordEntries(obj.value);
          }
        };
        return [recordFormatter, recordEntryFormatter];
      };
      getWrappedRecord = function getWrappedRecord2(source, dataID) {
        var record = source.get(dataID);
        if (record == null) {
          return record;
        }
        return new Proxy((0, _objectSpread2["default"])({}, record), {
          get: function get(target, prop) {
            var value = target[prop];
            if (value == null) {
              return value;
            }
            if (typeof value === "object") {
              if (typeof value.__ref === "string") {
                return getWrappedRecord2(source, value.__ref);
              }
              if (Array.isArray(value.__refs)) {
                return value.__refs.map(function(ref) {
                  return getWrappedRecord2(source, ref);
                });
              }
            }
            return value;
          }
        });
      };
      inspect = function inspect2(environment, dataID) {
        installDevtoolFormatters();
        return getWrappedRecord(environment.getStore().getSource(), dataID !== null && dataID !== void 0 ? dataID : "client:root");
      };
    }
    var formattersInstalled;
    var installDevtoolFormatters;
    var createFormatters;
    var getWrappedRecord;
    module.exports = {
      inspect
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayModernEnvironment.js
var require_RelayModernEnvironment = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayModernEnvironment.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var RelayDefaultHandlerProvider = require_RelayDefaultHandlerProvider();
    var _require = require_ActorIdentifier();
    var INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE;
    var assertInternalActorIdentifier = _require.assertInternalActorIdentifier;
    var RelayObservable = require_RelayObservable();
    var wrapNetworkWithLogObserver = require_wrapNetworkWithLogObserver();
    var RelayOperationTracker = require_RelayOperationTracker();
    var registerEnvironmentWithDevTools = require_registerEnvironmentWithDevTools();
    var defaultGetDataID = require_defaultGetDataID();
    var defaultRelayFieldLogger = require_defaultRelayFieldLogger();
    var normalizeResponse = require_normalizeResponse();
    var OperationExecutor = require_OperationExecutor();
    var RelayPublishQueue = require_RelayPublishQueue();
    var RelayRecordSource = require_RelayRecordSource();
    var invariant = require_browser();
    var RelayModernEnvironment = function() {
      function RelayModernEnvironment2(config) {
        var _this = this;
        var _config$log, _config$relayFieldLog, _config$UNSTABLE_defa, _config$getDataID, _config$missingFieldH, _config$handlerProvid, _config$scheduler, _config$isServer, _config$normalizeResp, _config$operationTrac;
        this.configName = config.configName;
        this._treatMissingFieldsAsNull = config.treatMissingFieldsAsNull === true;
        var operationLoader = config.operationLoader;
        if (true) {
          if (operationLoader != null) {
            !(typeof operationLoader === "object" && typeof operationLoader.get === "function" && typeof operationLoader.load === "function") ? true ? invariant(false, "RelayModernEnvironment: Expected `operationLoader` to be an object with get() and load() functions, got `%s`.", operationLoader) : invariant(false) : void 0;
          }
        }
        this.__log = (_config$log = config.log) !== null && _config$log !== void 0 ? _config$log : emptyFunction;
        this.relayFieldLogger = (_config$relayFieldLog = config.relayFieldLogger) !== null && _config$relayFieldLog !== void 0 ? _config$relayFieldLog : defaultRelayFieldLogger;
        this._defaultRenderPolicy = (_config$UNSTABLE_defa = config.UNSTABLE_defaultRenderPolicy) !== null && _config$UNSTABLE_defa !== void 0 ? _config$UNSTABLE_defa : "partial";
        this._operationLoader = operationLoader;
        this._operationExecutions = /* @__PURE__ */ new Map();
        this._network = wrapNetworkWithLogObserver(this, config.network);
        this._getDataID = (_config$getDataID = config.getDataID) !== null && _config$getDataID !== void 0 ? _config$getDataID : defaultGetDataID;
        this._missingFieldHandlers = (_config$missingFieldH = config.missingFieldHandlers) !== null && _config$missingFieldH !== void 0 ? _config$missingFieldH : [];
        this._publishQueue = new RelayPublishQueue(config.store, (_config$handlerProvid = config.handlerProvider) !== null && _config$handlerProvid !== void 0 ? _config$handlerProvid : RelayDefaultHandlerProvider, this._getDataID, this._missingFieldHandlers);
        this._scheduler = (_config$scheduler = config.scheduler) !== null && _config$scheduler !== void 0 ? _config$scheduler : null;
        this._store = config.store;
        this.options = config.options;
        this._isServer = (_config$isServer = config.isServer) !== null && _config$isServer !== void 0 ? _config$isServer : false;
        this._normalizeResponse = (_config$normalizeResp = config.normalizeResponse) !== null && _config$normalizeResp !== void 0 ? _config$normalizeResp : normalizeResponse;
        this.__setNet = function(newNet) {
          return _this._network = wrapNetworkWithLogObserver(_this, newNet);
        };
        if (true) {
          var _require2 = require_StoreInspector(), inspect = _require2.inspect;
          this.DEBUG_inspect = function(dataID) {
            return inspect(_this, dataID);
          };
        }
        this._operationTracker = (_config$operationTrac = config.operationTracker) !== null && _config$operationTrac !== void 0 ? _config$operationTrac : new RelayOperationTracker();
        this._shouldProcessClientComponents = config.shouldProcessClientComponents;
        registerEnvironmentWithDevTools(this);
      }
      var _proto = RelayModernEnvironment2.prototype;
      _proto.getStore = function getStore() {
        return this._store;
      };
      _proto.getNetwork = function getNetwork() {
        return this._network;
      };
      _proto.getOperationTracker = function getOperationTracker() {
        return this._operationTracker;
      };
      _proto.getScheduler = function getScheduler() {
        return this._scheduler;
      };
      _proto.isRequestActive = function isRequestActive(requestIdentifier) {
        var activeState = this._operationExecutions.get(requestIdentifier);
        return activeState === "active";
      };
      _proto.UNSTABLE_getDefaultRenderPolicy = function UNSTABLE_getDefaultRenderPolicy() {
        return this._defaultRenderPolicy;
      };
      _proto.applyUpdate = function applyUpdate(optimisticUpdate) {
        var _this2 = this;
        var dispose = function dispose2() {
          _this2._scheduleUpdates(function() {
            _this2._publishQueue.revertUpdate(optimisticUpdate);
            _this2._publishQueue.run();
          });
        };
        this._scheduleUpdates(function() {
          _this2._publishQueue.applyUpdate(optimisticUpdate);
          _this2._publishQueue.run();
        });
        return {
          dispose
        };
      };
      _proto.revertUpdate = function revertUpdate(update) {
        var _this3 = this;
        this._scheduleUpdates(function() {
          _this3._publishQueue.revertUpdate(update);
          _this3._publishQueue.run();
        });
      };
      _proto.replaceUpdate = function replaceUpdate(update, newUpdate) {
        var _this4 = this;
        this._scheduleUpdates(function() {
          _this4._publishQueue.revertUpdate(update);
          _this4._publishQueue.applyUpdate(newUpdate);
          _this4._publishQueue.run();
        });
      };
      _proto.applyMutation = function applyMutation(optimisticConfig) {
        var subscription = this._execute({
          createSource: function createSource() {
            return RelayObservable.create(function(_sink) {
            });
          },
          isClientPayload: false,
          operation: optimisticConfig.operation,
          optimisticConfig,
          updater: null
        }).subscribe({});
        return {
          dispose: function dispose() {
            return subscription.unsubscribe();
          }
        };
      };
      _proto.check = function check(operation) {
        if (this._missingFieldHandlers.length === 0 && !operationHasClientAbstractTypes(operation)) {
          return this._store.check(operation);
        }
        return this._checkSelectorAndHandleMissingFields(operation, this._missingFieldHandlers);
      };
      _proto.commitPayload = function commitPayload(operation, payload) {
        this._execute({
          createSource: function createSource() {
            return RelayObservable.from({
              data: payload
            });
          },
          isClientPayload: true,
          operation,
          optimisticConfig: null,
          updater: null
        }).subscribe({});
      };
      _proto.commitUpdate = function commitUpdate(updater) {
        var _this5 = this;
        this._scheduleUpdates(function() {
          _this5._publishQueue.commitUpdate(updater);
          _this5._publishQueue.run();
        });
      };
      _proto.lookup = function lookup(readSelector) {
        return this._store.lookup(readSelector);
      };
      _proto.subscribe = function subscribe(snapshot, callback) {
        return this._store.subscribe(snapshot, callback);
      };
      _proto.retain = function retain(operation) {
        return this._store.retain(operation);
      };
      _proto.isServer = function isServer() {
        return this._isServer;
      };
      _proto._checkSelectorAndHandleMissingFields = function _checkSelectorAndHandleMissingFields(operation, handlers) {
        var _this6 = this;
        var target = RelayRecordSource.create();
        var source = this._store.getSource();
        var result = this._store.check(operation, {
          handlers,
          defaultActorIdentifier: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,
          getSourceForActor: function getSourceForActor(actorIdentifier) {
            assertInternalActorIdentifier(actorIdentifier);
            return source;
          },
          getTargetForActor: function getTargetForActor(actorIdentifier) {
            assertInternalActorIdentifier(actorIdentifier);
            return target;
          }
        });
        if (target.size() > 0) {
          this._scheduleUpdates(function() {
            _this6._publishQueue.commitSource(target);
            _this6._publishQueue.run();
          });
        }
        return result;
      };
      _proto._scheduleUpdates = function _scheduleUpdates(task) {
        var scheduler = this._scheduler;
        if (scheduler != null) {
          scheduler.schedule(task);
        } else {
          task();
        }
      };
      _proto.execute = function execute(_ref) {
        var _this7 = this;
        var operation = _ref.operation;
        return this._execute({
          createSource: function createSource() {
            return _this7.getNetwork().execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null);
          },
          isClientPayload: false,
          operation,
          optimisticConfig: null,
          updater: null
        });
      };
      _proto.executeSubscription = function executeSubscription(_ref2) {
        var _this8 = this;
        var operation = _ref2.operation, updater = _ref2.updater;
        return this._execute({
          createSource: function createSource() {
            return _this8.getNetwork().execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null);
          },
          isClientPayload: false,
          operation,
          optimisticConfig: null,
          updater
        });
      };
      _proto.executeMutation = function executeMutation(_ref3) {
        var _this9 = this;
        var operation = _ref3.operation, optimisticResponse = _ref3.optimisticResponse, optimisticUpdater = _ref3.optimisticUpdater, updater = _ref3.updater, uploadables = _ref3.uploadables;
        var optimisticConfig;
        if (optimisticResponse || optimisticUpdater) {
          optimisticConfig = {
            operation,
            response: optimisticResponse,
            updater: optimisticUpdater
          };
        }
        return this._execute({
          createSource: function createSource() {
            return _this9.getNetwork().execute(operation.request.node.params, operation.request.variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, operation.request.cacheConfig), {}, {
              force: true
            }), uploadables);
          },
          isClientPayload: false,
          operation,
          optimisticConfig,
          updater
        });
      };
      _proto.executeWithSource = function executeWithSource(_ref4) {
        var operation = _ref4.operation, source = _ref4.source;
        return this._execute({
          createSource: function createSource() {
            return source;
          },
          isClientPayload: false,
          operation,
          optimisticConfig: null,
          updater: null
        });
      };
      _proto.toJSON = function toJSON() {
        var _this$configName;
        return "RelayModernEnvironment(".concat((_this$configName = this.configName) !== null && _this$configName !== void 0 ? _this$configName : "", ")");
      };
      _proto._execute = function _execute(_ref5) {
        var _this10 = this;
        var createSource = _ref5.createSource, isClientPayload = _ref5.isClientPayload, operation = _ref5.operation, optimisticConfig = _ref5.optimisticConfig, updater = _ref5.updater;
        var publishQueue = this._publishQueue;
        var store = this._store;
        return RelayObservable.create(function(sink) {
          var executor = OperationExecutor.execute({
            actorIdentifier: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,
            getDataID: _this10._getDataID,
            isClientPayload,
            log: _this10.__log,
            operation,
            operationExecutions: _this10._operationExecutions,
            operationLoader: _this10._operationLoader,
            operationTracker: _this10._operationTracker,
            optimisticConfig,
            getPublishQueue: function getPublishQueue(actorIdentifier) {
              assertInternalActorIdentifier(actorIdentifier);
              return publishQueue;
            },
            scheduler: _this10._scheduler,
            shouldProcessClientComponents: _this10._shouldProcessClientComponents,
            sink,
            source: createSource(),
            getStore: function getStore(actorIdentifier) {
              assertInternalActorIdentifier(actorIdentifier);
              return store;
            },
            treatMissingFieldsAsNull: _this10._treatMissingFieldsAsNull,
            updater,
            normalizeResponse: _this10._normalizeResponse
          });
          return function() {
            return executor.cancel();
          };
        });
      };
      return RelayModernEnvironment2;
    }();
    function operationHasClientAbstractTypes(operation) {
      return operation.root.node.kind === "Operation" && operation.root.node.clientAbstractTypes != null;
    }
    RelayModernEnvironment.prototype["@@RelayModernEnvironment"] = true;
    function emptyFunction() {
    }
    module.exports = RelayModernEnvironment;
  }
});

// node_modules/relay-runtime/lib/util/resolveImmediate.js
var require_resolveImmediate = __commonJS({
  "node_modules/relay-runtime/lib/util/resolveImmediate.js"(exports, module) {
    "use strict";
    var resolvedPromise = Promise.resolve();
    function resolveImmediate(callback) {
      resolvedPromise.then(callback)["catch"](throwNext);
    }
    function throwNext(error) {
      setTimeout(function() {
        throw error;
      }, 0);
    }
    module.exports = resolveImmediate;
  }
});

// node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js
var require_cloneRelayHandleSourceField = __commonJS({
  "node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js"(exports, module) {
    "use strict";
    var _require = require_RelayConcreteNode();
    var LINKED_FIELD = _require.LINKED_FIELD;
    var _require2 = require_RelayStoreUtils();
    var getHandleStorageKey = _require2.getHandleStorageKey;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    function cloneRelayHandleSourceField(handleField, selections, variables) {
      var sourceField = selections.find(function(source) {
        return source.kind === LINKED_FIELD && source.name === handleField.name && source.alias === handleField.alias && areEqual(source.args, handleField.args);
      });
      !(sourceField && sourceField.kind === LINKED_FIELD) ? true ? invariant(false, "cloneRelayHandleSourceField: Expected a corresponding source field for handle `%s`.", handleField.handle) : invariant(false) : void 0;
      var handleKey = getHandleStorageKey(handleField, variables);
      return {
        kind: "LinkedField",
        alias: sourceField.alias,
        name: handleKey,
        storageKey: handleKey,
        args: null,
        concreteType: sourceField.concreteType,
        plural: sourceField.plural,
        selections: sourceField.selections
      };
    }
    module.exports = cloneRelayHandleSourceField;
  }
});

// node_modules/relay-runtime/lib/store/cloneRelayScalarHandleSourceField.js
var require_cloneRelayScalarHandleSourceField = __commonJS({
  "node_modules/relay-runtime/lib/store/cloneRelayScalarHandleSourceField.js"(exports, module) {
    "use strict";
    var _require = require_RelayConcreteNode();
    var SCALAR_FIELD = _require.SCALAR_FIELD;
    var _require2 = require_RelayStoreUtils();
    var getHandleStorageKey = _require2.getHandleStorageKey;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    function cloneRelayScalarHandleSourceField(handleField, selections, variables) {
      var sourceField = selections.find(function(source) {
        return source.kind === SCALAR_FIELD && source.name === handleField.name && source.alias === handleField.alias && areEqual(source.args, handleField.args);
      });
      !(sourceField && sourceField.kind === SCALAR_FIELD) ? true ? invariant(false, "cloneRelayScalarHandleSourceField: Expected a corresponding source field for handle `%s`.", handleField.handle) : invariant(false) : void 0;
      var handleKey = getHandleStorageKey(handleField, variables);
      return {
        kind: "ScalarField",
        alias: sourceField.alias,
        name: handleKey,
        storageKey: handleKey,
        args: null
      };
    }
    module.exports = cloneRelayScalarHandleSourceField;
  }
});

// node_modules/relay-runtime/lib/store/DataChecker.js
var require_DataChecker = __commonJS({
  "node_modules/relay-runtime/lib/store/DataChecker.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var RelayRecordSourceMutator = require_RelayRecordSourceMutator();
    var RelayRecordSourceProxy = require_RelayRecordSourceProxy();
    var getOperation = require_getOperation();
    var _require = require_ClientID();
    var isClientID = _require.isClientID;
    var cloneRelayHandleSourceField = require_cloneRelayHandleSourceField();
    var cloneRelayScalarHandleSourceField = require_cloneRelayScalarHandleSourceField();
    var _require2 = require_RelayConcreteVariables();
    var getLocalVariables = _require2.getLocalVariables;
    var RelayModernRecord = require_RelayModernRecord();
    var _require3 = require_RelayRecordState();
    var EXISTENT = _require3.EXISTENT;
    var UNKNOWN = _require3.UNKNOWN;
    var RelayStoreUtils = require_RelayStoreUtils();
    var _require4 = require_TypeID();
    var TYPE_SCHEMA_TYPE = _require4.TYPE_SCHEMA_TYPE;
    var generateTypeID = _require4.generateTypeID;
    var invariant = require_browser();
    var getModuleOperationKey = RelayStoreUtils.getModuleOperationKey;
    var getStorageKey = RelayStoreUtils.getStorageKey;
    var getArgumentValues = RelayStoreUtils.getArgumentValues;
    function check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents, log) {
      if (log != null) {
        log({
          name: "store.datachecker.start",
          selector
        });
      }
      var dataID = selector.dataID, node = selector.node, variables = selector.variables;
      var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);
      var result = checker.check(node, dataID);
      if (log != null) {
        log({
          name: "store.datachecker.end",
          selector
        });
      }
      return result;
    }
    var DataChecker = function() {
      function DataChecker2(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {
        this._getSourceForActor = getSourceForActor;
        this._getTargetForActor = getTargetForActor;
        this._getDataID = getDataID;
        this._source = getSourceForActor(defaultActorIdentifier);
        this._mutatorRecordSourceProxyCache = /* @__PURE__ */ new Map();
        var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier), mutator = _this$_getMutatorAndR[0], recordSourceProxy = _this$_getMutatorAndR[1];
        this._mostRecentlyInvalidatedAt = null;
        this._handlers = handlers;
        this._mutator = mutator;
        this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
        this._recordSourceProxy = recordSourceProxy;
        this._recordWasMissing = false;
        this._variables = variables;
        this._shouldProcessClientComponents = shouldProcessClientComponents;
      }
      var _proto = DataChecker2.prototype;
      _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {
        var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);
        if (tuple == null) {
          var target = this._getTargetForActor(actorIdentifier);
          var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);
          var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, void 0, this._handlers);
          tuple = [mutator, recordSourceProxy];
          this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);
        }
        return tuple;
      };
      _proto.check = function check2(node, dataID) {
        this._assignClientAbstractTypes(node);
        this._traverse(node, dataID);
        return this._recordWasMissing === true ? {
          status: "missing",
          mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
        } : {
          status: "available",
          mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
        };
      };
      _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? true ? invariant(false, "RelayAsyncLoader(): Undefined variable `%s`.", name) : invariant(false) : void 0;
        return this._variables[name];
      };
      _proto._handleMissing = function _handleMissing() {
        this._recordWasMissing = true;
      };
      _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {
        if (field.name === "id" && field.alias == null && isClientID(dataID)) {
          return void 0;
        }
        var args = field.args != void 0 ? getArgumentValues(field.args, this._variables) : {};
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var handler = _step.value;
            if (handler.kind === "scalar") {
              var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
              if (newValue !== void 0) {
                return newValue;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this._handleMissing();
      };
      _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {
        var args = field.args != void 0 ? getArgumentValues(field.args, this._variables) : {};
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var handler = _step2.value;
            if (handler.kind === "linked") {
              var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
              if (newValue !== void 0 && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {
                return newValue;
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this._handleMissing();
      };
      _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {
        var _this = this;
        var args = field.args != void 0 ? getArgumentValues(field.args, this._variables) : {};
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var handler = _step3.value;
            if (handler.kind === "pluralLinked") {
              var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
              if (newValue != null) {
                var allItemsKnown = newValue.every(function(linkedID) {
                  return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;
                });
                if (allItemsKnown) {
                  return newValue;
                }
              } else if (newValue === null) {
                return null;
              }
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        this._handleMissing();
      };
      _proto._traverse = function _traverse(node, dataID) {
        var status = this._mutator.getStatus(dataID);
        if (status === UNKNOWN) {
          this._handleMissing();
        }
        if (status === EXISTENT) {
          var record = this._source.get(dataID);
          var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);
          if (invalidatedAt != null) {
            this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;
          }
          this._traverseSelections(node.selections, dataID);
        }
      };
      _proto._traverseSelections = function _traverseSelections(selections, dataID) {
        var _this2 = this;
        selections.forEach(function(selection) {
          switch (selection.kind) {
            case "ScalarField":
              _this2._checkScalar(selection, dataID);
              break;
            case "LinkedField":
              if (selection.plural) {
                _this2._checkPluralLink(selection, dataID);
              } else {
                _this2._checkLink(selection, dataID);
              }
              break;
            case "ActorChange":
              _this2._checkActorChange(selection.linkedField, dataID);
              break;
            case "Condition":
              var conditionValue = Boolean(_this2._getVariableValue(selection.condition));
              if (conditionValue === selection.passingValue) {
                _this2._traverseSelections(selection.selections, dataID);
              }
              break;
            case "InlineFragment": {
              var _abstractKey = selection.abstractKey;
              if (_abstractKey == null) {
                var typeName = _this2._mutator.getType(dataID);
                if (typeName === selection.type) {
                  _this2._traverseSelections(selection.selections, dataID);
                }
              } else {
                var _recordType = _this2._mutator.getType(dataID);
                !(_recordType != null) ? true ? invariant(false, "DataChecker: Expected record `%s` to have a known type", dataID) : invariant(false) : void 0;
                var _typeID = generateTypeID(_recordType);
                var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);
                if (_implementsInterface === true) {
                  _this2._traverseSelections(selection.selections, dataID);
                } else if (_implementsInterface == null) {
                  _this2._handleMissing();
                }
              }
              break;
            }
            case "LinkedHandle": {
              var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);
              if (handleField.plural) {
                _this2._checkPluralLink(handleField, dataID);
              } else {
                _this2._checkLink(handleField, dataID);
              }
              break;
            }
            case "ScalarHandle": {
              var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);
              _this2._checkScalar(_handleField, dataID);
              break;
            }
            case "ModuleImport":
              _this2._checkModuleImport(selection, dataID);
              break;
            case "Defer":
            case "Stream":
              _this2._traverseSelections(selection.selections, dataID);
              break;
            case "FragmentSpread":
              var prevVariables = _this2._variables;
              _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);
              _this2._traverseSelections(selection.fragment.selections, dataID);
              _this2._variables = prevVariables;
              break;
            case "ClientExtension":
              var recordWasMissing = _this2._recordWasMissing;
              _this2._traverseSelections(selection.selections, dataID);
              _this2._recordWasMissing = recordWasMissing;
              break;
            case "TypeDiscriminator":
              var abstractKey = selection.abstractKey;
              var recordType = _this2._mutator.getType(dataID);
              !(recordType != null) ? true ? invariant(false, "DataChecker: Expected record `%s` to have a known type", dataID) : invariant(false) : void 0;
              var typeID = generateTypeID(recordType);
              var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);
              if (implementsInterface == null) {
                _this2._handleMissing();
              }
              break;
            case "ClientComponent":
              if (_this2._shouldProcessClientComponents === false) {
                break;
              }
              _this2._traverseSelections(selection.fragment.selections, dataID);
              break;
            case "RelayResolver":
              _this2._checkResolver(selection, dataID);
              break;
            case "RelayLiveResolver":
              _this2._checkResolver(selection, dataID);
              break;
            case "ClientEdgeToClientObject":
              _this2._checkResolver(selection.backingField, dataID);
              break;
            default:
              selection;
              true ? true ? invariant(false, "RelayAsyncLoader(): Unexpected ast kind `%s`.", selection.kind) : invariant(false) : void 0;
          }
        });
      };
      _proto._checkResolver = function _checkResolver(resolver, dataID) {
        if (resolver.fragment) {
          this._traverseSelections([resolver.fragment], dataID);
        }
      };
      _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {
        var operationLoader = this._operationLoader;
        !(operationLoader !== null) ? true ? invariant(false, "DataChecker: Expected an operationLoader to be configured when using `@module`.") : invariant(false) : void 0;
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = this._mutator.getValue(dataID, operationKey);
        if (operationReference == null) {
          if (operationReference === void 0) {
            this._handleMissing();
          }
          return;
        }
        var normalizationRootNode = operationLoader.get(operationReference);
        if (normalizationRootNode != null) {
          var operation = getOperation(normalizationRootNode);
          var prevVariables = this._variables;
          this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);
          this._traverse(operation, dataID);
          this._variables = prevVariables;
        } else {
          this._handleMissing();
        }
      };
      _proto._checkScalar = function _checkScalar(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var fieldValue = this._mutator.getValue(dataID, storageKey);
        if (fieldValue === void 0) {
          fieldValue = this._handleMissingScalarField(field, dataID);
          if (fieldValue !== void 0) {
            this._mutator.setValue(dataID, storageKey, fieldValue);
          }
        }
      };
      _proto._checkLink = function _checkLink(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);
        if (linkedID === void 0) {
          linkedID = this._handleMissingLinkField(field, dataID);
          if (linkedID != null) {
            this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);
          } else if (linkedID === null) {
            this._mutator.setValue(dataID, storageKey, null);
          }
        }
        if (linkedID != null) {
          this._traverse(field, linkedID);
        }
      };
      _proto._checkPluralLink = function _checkPluralLink(field, dataID) {
        var _this3 = this;
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);
        if (linkedIDs === void 0) {
          linkedIDs = this._handleMissingPluralLinkField(field, dataID);
          if (linkedIDs != null) {
            this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);
          } else if (linkedIDs === null) {
            this._mutator.setValue(dataID, storageKey, null);
          }
        }
        if (linkedIDs) {
          linkedIDs.forEach(function(linkedID) {
            if (linkedID != null) {
              _this3._traverse(field, linkedID);
            }
          });
        }
      };
      _proto._checkActorChange = function _checkActorChange(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var record = this._source.get(dataID);
        var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;
        if (tuple == null) {
          if (tuple === void 0) {
            this._handleMissing();
          }
        } else {
          var actorIdentifier = tuple[0], linkedID = tuple[1];
          var prevSource = this._source;
          var prevMutator = this._mutator;
          var prevRecordSourceProxy = this._recordSourceProxy;
          var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(actorIdentifier), mutator = _this$_getMutatorAndR2[0], recordSourceProxy = _this$_getMutatorAndR2[1];
          this._source = this._getSourceForActor(actorIdentifier);
          this._mutator = mutator;
          this._recordSourceProxy = recordSourceProxy;
          this._assignClientAbstractTypes(field);
          this._traverse(field, linkedID);
          this._source = prevSource;
          this._mutator = prevMutator;
          this._recordSourceProxy = prevRecordSourceProxy;
        }
      };
      _proto._assignClientAbstractTypes = function _assignClientAbstractTypes(node) {
        var clientAbstractTypes = node.clientAbstractTypes;
        if (clientAbstractTypes != null) {
          for (var _i = 0, _Object$keys = Object.keys(clientAbstractTypes); _i < _Object$keys.length; _i++) {
            var abstractType = _Object$keys[_i];
            var _iterator4 = (0, _createForOfIteratorHelper2["default"])(clientAbstractTypes[abstractType]), _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                var concreteType = _step4.value;
                var typeID = generateTypeID(concreteType);
                if (this._source.get(typeID) == null) {
                  this._mutator.create(typeID, TYPE_SCHEMA_TYPE);
                }
                if (this._mutator.getValue(typeID, abstractType) == null) {
                  this._mutator.setValue(typeID, abstractType, true);
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        }
      };
      return DataChecker2;
    }();
    module.exports = {
      check
    };
  }
});

// node_modules/relay-runtime/lib/store/RelayOptimisticRecordSource.js
var require_RelayOptimisticRecordSource = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayOptimisticRecordSource.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var RelayModernRecord = require_RelayModernRecord();
    var RelayRecordSource = require_RelayRecordSource();
    var invariant = require_browser();
    var UNPUBLISH_RECORD_SENTINEL = RelayModernRecord.fromObject(Object.freeze({
      __UNPUBLISH_RECORD_SENTINEL: true
    }));
    var RelayOptimisticRecordSource = function() {
      function RelayOptimisticRecordSource2(base) {
        this._base = base;
        this._sink = RelayRecordSource.create();
      }
      var _proto = RelayOptimisticRecordSource2.prototype;
      _proto.has = function has(dataID) {
        if (this._sink.has(dataID)) {
          var sinkRecord = this._sink.get(dataID);
          return sinkRecord !== UNPUBLISH_RECORD_SENTINEL;
        } else {
          return this._base.has(dataID);
        }
      };
      _proto.get = function get(dataID) {
        if (this._sink.has(dataID)) {
          var sinkRecord = this._sink.get(dataID);
          if (sinkRecord === UNPUBLISH_RECORD_SENTINEL) {
            return void 0;
          } else {
            return sinkRecord;
          }
        } else {
          return this._base.get(dataID);
        }
      };
      _proto.getStatus = function getStatus(dataID) {
        var record = this.get(dataID);
        if (record === void 0) {
          return "UNKNOWN";
        } else if (record === null) {
          return "NONEXISTENT";
        } else {
          return "EXISTENT";
        }
      };
      _proto.clear = function clear() {
        this._base = RelayRecordSource.create();
        this._sink.clear();
      };
      _proto["delete"] = function _delete(dataID) {
        this._sink["delete"](dataID);
      };
      _proto.remove = function remove(dataID) {
        this._sink.set(dataID, UNPUBLISH_RECORD_SENTINEL);
      };
      _proto.set = function set(dataID, record) {
        this._sink.set(dataID, record);
      };
      _proto.getRecordIDs = function getRecordIDs() {
        return Object.keys(this.toJSON());
      };
      _proto.size = function size() {
        return Object.keys(this.toJSON()).length;
      };
      _proto.toJSON = function toJSON() {
        var _this = this;
        var merged = (0, _objectSpread2["default"])({}, this._base.toJSON());
        this._sink.getRecordIDs().forEach(function(dataID) {
          var record = _this.get(dataID);
          if (record === void 0) {
            delete merged[dataID];
          } else {
            merged[dataID] = RelayModernRecord.toJSON(record);
          }
        });
        return merged;
      };
      _proto.getOptimisticRecordIDs = function getOptimisticRecordIDs2() {
        return new Set(this._sink.getRecordIDs());
      };
      return RelayOptimisticRecordSource2;
    }();
    function create(base) {
      return new RelayOptimisticRecordSource(base);
    }
    function getOptimisticRecordIDs(source) {
      !(source instanceof RelayOptimisticRecordSource) ? true ? invariant(false, "getOptimisticRecordIDs: Instance of RelayOptimisticRecordSource is expected") : invariant(false) : void 0;
      return source.getOptimisticRecordIDs();
    }
    module.exports = {
      create,
      getOptimisticRecordIDs
    };
  }
});

// node_modules/relay-runtime/lib/store/experimental-live-resolvers/getOutputTypeRecordIDs.js
var require_getOutputTypeRecordIDs = __commonJS({
  "node_modules/relay-runtime/lib/store/experimental-live-resolvers/getOutputTypeRecordIDs.js"(exports, module) {
    "use strict";
    var RelayModernRecord = require_RelayModernRecord();
    var _require = require_RelayStoreUtils();
    var RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS = _require.RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS;
    var invariant = require_browser();
    function getOutputTypeRecordIDs(record) {
      var maybeOutputTypeRecordIDs = RelayModernRecord.getValue(record, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS);
      if (maybeOutputTypeRecordIDs == null) {
        return null;
      }
      !(maybeOutputTypeRecordIDs instanceof Set) ? true ? invariant(false, "getOutputTypeRecordIDs: Expected the `%s` field on record `%s` to be of type Set. Instead, it is a %s.", RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, typeof maybeOutputTypeRecordIDs) : invariant(false) : void 0;
      return maybeOutputTypeRecordIDs;
    }
    module.exports = getOutputTypeRecordIDs;
  }
});

// node_modules/relay-runtime/lib/store/RelayReferenceMarker.js
var require_RelayReferenceMarker = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayReferenceMarker.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var getOperation = require_getOperation();
    var cloneRelayHandleSourceField = require_cloneRelayHandleSourceField();
    var getOutputTypeRecordIDs = require_getOutputTypeRecordIDs();
    var _require = require_RelayConcreteVariables();
    var getLocalVariables = _require.getLocalVariables;
    var RelayModernRecord = require_RelayModernRecord();
    var RelayStoreUtils = require_RelayStoreUtils();
    var _require2 = require_TypeID();
    var generateTypeID = _require2.generateTypeID;
    var invariant = require_browser();
    var getStorageKey = RelayStoreUtils.getStorageKey;
    var getModuleOperationKey = RelayStoreUtils.getModuleOperationKey;
    function mark(recordSource, selector, references, operationLoader, shouldProcessClientComponents) {
      var dataID = selector.dataID, node = selector.node, variables = selector.variables;
      var marker = new RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents);
      marker.mark(node, dataID);
    }
    var RelayReferenceMarker = function() {
      function RelayReferenceMarker2(recordSource, variables, references, operationLoader, shouldProcessClientComponents) {
        this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
        this._operationName = null;
        this._recordSource = recordSource;
        this._references = references;
        this._variables = variables;
        this._shouldProcessClientComponents = shouldProcessClientComponents;
      }
      var _proto = RelayReferenceMarker2.prototype;
      _proto.mark = function mark2(node, dataID) {
        if (node.kind === "Operation" || node.kind === "SplitOperation") {
          this._operationName = node.name;
        }
        this._traverse(node, dataID);
      };
      _proto._traverse = function _traverse(node, dataID) {
        this._references.add(dataID);
        var record = this._recordSource.get(dataID);
        if (record == null) {
          return;
        }
        this._traverseSelections(node.selections, record);
      };
      _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? true ? invariant(false, "RelayReferenceMarker(): Undefined variable `%s`.", name) : invariant(false) : void 0;
        return this._variables[name];
      };
      _proto._traverseSelections = function _traverseSelections(selections, record) {
        var _this = this;
        selections.forEach(function(selection) {
          switch (selection.kind) {
            case "ActorChange":
              _this._traverseLink(selection.linkedField, record);
              break;
            case "LinkedField":
              if (selection.plural) {
                _this._traversePluralLink(selection, record);
              } else {
                _this._traverseLink(selection, record);
              }
              break;
            case "Condition":
              var conditionValue = Boolean(_this._getVariableValue(selection.condition));
              if (conditionValue === selection.passingValue) {
                _this._traverseSelections(selection.selections, record);
              }
              break;
            case "InlineFragment":
              if (selection.abstractKey == null) {
                var typeName = RelayModernRecord.getType(record);
                if (typeName != null && typeName === selection.type || typeName === RelayStoreUtils.ROOT_TYPE) {
                  _this._traverseSelections(selection.selections, record);
                }
              } else {
                var _typeName = RelayModernRecord.getType(record);
                var typeID = generateTypeID(_typeName);
                _this._references.add(typeID);
                _this._traverseSelections(selection.selections, record);
              }
              break;
            case "FragmentSpread":
              var prevVariables = _this._variables;
              _this._variables = getLocalVariables(_this._variables, selection.fragment.argumentDefinitions, selection.args);
              _this._traverseSelections(selection.fragment.selections, record);
              _this._variables = prevVariables;
              break;
            case "LinkedHandle":
              var handleField = cloneRelayHandleSourceField(selection, selections, _this._variables);
              if (handleField.plural) {
                _this._traversePluralLink(handleField, record);
              } else {
                _this._traverseLink(handleField, record);
              }
              break;
            case "Defer":
            case "Stream":
              _this._traverseSelections(selection.selections, record);
              break;
            case "ScalarField":
            case "ScalarHandle":
              break;
            case "TypeDiscriminator": {
              var _typeName2 = RelayModernRecord.getType(record);
              var _typeID = generateTypeID(_typeName2);
              _this._references.add(_typeID);
              break;
            }
            case "ModuleImport":
              _this._traverseModuleImport(selection, record);
              break;
            case "ClientExtension":
              _this._traverseSelections(selection.selections, record);
              break;
            case "ClientComponent":
              if (_this._shouldProcessClientComponents === false) {
                break;
              }
              _this._traverseSelections(selection.fragment.selections, record);
              break;
            case "RelayResolver":
              _this._traverseResolverField(selection, record);
              break;
            case "RelayLiveResolver":
              _this._traverseResolverField(selection, record);
              break;
            case "ClientEdgeToClientObject":
              _this._traverseClientEdgeToClientObject(selection, record);
              break;
            default:
              selection;
              true ? true ? invariant(false, "RelayReferenceMarker: Unknown AST node `%s`.", selection) : invariant(false) : void 0;
          }
        });
      };
      _proto._traverseClientEdgeToClientObject = function _traverseClientEdgeToClientObject(field, record) {
        var dataID = this._traverseResolverField(field.backingField, record);
        if (dataID == null) {
          return;
        }
        var resolverRecord = this._recordSource.get(dataID);
        if (resolverRecord == null) {
          return;
        }
        if (field.backingField.isOutputType) {
          var outputTypeRecordIDs = getOutputTypeRecordIDs(resolverRecord);
          if (outputTypeRecordIDs != null) {
            var _iterator = (0, _createForOfIteratorHelper2["default"])(outputTypeRecordIDs), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _dataID = _step.value;
                this._references.add(_dataID);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        } else {
          var linkedField = field.linkedField;
          var concreteType = linkedField.concreteType;
          if (concreteType == null) {
            return;
          }
          if (linkedField.plural) {
            var dataIDs = RelayModernRecord.getResolverLinkedRecordIDs(resolverRecord, concreteType);
            if (dataIDs != null) {
              var _iterator2 = (0, _createForOfIteratorHelper2["default"])(dataIDs), _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var _dataID2 = _step2.value;
                  if (_dataID2 != null) {
                    this._traverse(linkedField, _dataID2);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          } else {
            var _dataID3 = RelayModernRecord.getResolverLinkedRecordID(resolverRecord, concreteType);
            if (_dataID3 != null) {
              this._traverse(linkedField, _dataID3);
            }
          }
        }
      };
      _proto._traverseResolverField = function _traverseResolverField(field, record) {
        var storageKey = getStorageKey(field, this._variables);
        var dataID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (dataID != null) {
          this._references.add(dataID);
        }
        var fragment = field.fragment;
        if (fragment != null) {
          this._traverseSelections([fragment], record);
        }
        return dataID;
      };
      _proto._traverseModuleImport = function _traverseModuleImport(moduleImport, record) {
        var _this$_operationName;
        var operationLoader = this._operationLoader;
        !(operationLoader !== null) ? true ? invariant(false, "RelayReferenceMarker: Expected an operationLoader to be configured when using `@module`. Could not load fragment `%s` in operation `%s`.", moduleImport.fragmentName, (_this$_operationName = this._operationName) !== null && _this$_operationName !== void 0 ? _this$_operationName : "(unknown)") : invariant(false) : void 0;
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = RelayModernRecord.getValue(record, operationKey);
        if (operationReference == null) {
          return;
        }
        var normalizationRootNode = operationLoader.get(operationReference);
        if (normalizationRootNode != null) {
          var operation = getOperation(normalizationRootNode);
          var prevVariables = this._variables;
          this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);
          this._traverseSelections(operation.selections, record);
          this._variables = prevVariables;
        }
      };
      _proto._traverseLink = function _traverseLink(field, record) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (linkedID == null) {
          return;
        }
        this._traverse(field, linkedID);
      };
      _proto._traversePluralLink = function _traversePluralLink(field, record) {
        var _this2 = this;
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        if (linkedIDs == null) {
          return;
        }
        linkedIDs.forEach(function(linkedID) {
          if (linkedID != null) {
            _this2._traverse(field, linkedID);
          }
        });
      };
      return RelayReferenceMarker2;
    }();
    module.exports = {
      mark
    };
  }
});

// node_modules/relay-runtime/lib/store/hasOverlappingIDs.js
var require_hasOverlappingIDs = __commonJS({
  "node_modules/relay-runtime/lib/store/hasOverlappingIDs.js"(exports, module) {
    "use strict";
    var ITERATOR_KEY = Symbol.iterator;
    function hasOverlappingIDs(seenRecords, updatedRecordIDs) {
      var iterator = seenRecords[ITERATOR_KEY]();
      var next = iterator.next();
      while (!next.done) {
        var key = next.value;
        if (updatedRecordIDs.has(key)) {
          return true;
        }
        next = iterator.next();
      }
      return false;
    }
    module.exports = hasOverlappingIDs;
  }
});

// node_modules/relay-runtime/lib/store/hasSignificantOverlappingIDs.js
var require_hasSignificantOverlappingIDs = __commonJS({
  "node_modules/relay-runtime/lib/store/hasSignificantOverlappingIDs.js"(exports, module) {
    "use strict";
    var _require = require_RelayStoreUtils();
    var ROOT_ID = _require.ROOT_ID;
    var _require2 = require_ViewerPattern();
    var VIEWER_ID = _require2.VIEWER_ID;
    var ITERATOR_KEY = Symbol.iterator;
    function hasSignificantOverlappingIDs(seenRecords, updatedRecordIDs) {
      var iterator = seenRecords[ITERATOR_KEY]();
      var next = iterator.next();
      while (!next.done) {
        var key = next.value;
        if (updatedRecordIDs.has(key) && key !== ROOT_ID && key !== VIEWER_ID) {
          return true;
        }
        next = iterator.next();
      }
      return false;
    }
    module.exports = hasSignificantOverlappingIDs;
  }
});

// node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js
var require_RelayStoreSubscriptions = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js"(exports, module) {
    "use strict";
    var deepFreeze = require_deepFreeze();
    var recycleNodesInto = require_recycleNodesInto();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var hasOverlappingIDs = require_hasOverlappingIDs();
    var hasSignificantOverlappingIDs = require_hasSignificantOverlappingIDs();
    var RelayReader = require_RelayReader();
    var RelayStoreSubscriptions = function() {
      function RelayStoreSubscriptions2(log, resolverCache, resolverContext) {
        this._subscriptions = /* @__PURE__ */ new Set();
        this.__log = log;
        this._resolverCache = resolverCache;
        this._resolverContext = resolverContext;
      }
      var _proto = RelayStoreSubscriptions2.prototype;
      _proto.subscribe = function subscribe(snapshot, callback) {
        var _this = this;
        var subscription = {
          backup: null,
          callback,
          snapshot,
          stale: false
        };
        var dispose = function dispose2() {
          _this._subscriptions["delete"](subscription);
        };
        this._subscriptions.add(subscription);
        return {
          dispose
        };
      };
      _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {
        var _this2 = this;
        this._subscriptions.forEach(function(subscription) {
          if (!subscription.stale) {
            subscription.backup = subscription.snapshot;
            return;
          }
          var snapshot = subscription.snapshot;
          var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache, _this2._resolverContext);
          var nextData = recycleNodesInto(snapshot.data, backup.data);
          backup.data = nextData;
          subscription.backup = backup;
        });
      };
      _proto.restoreSubscriptions = function restoreSubscriptions() {
        this._subscriptions.forEach(function(subscription) {
          var backup = subscription.backup;
          subscription.backup = null;
          if (backup) {
            if (backup.data !== subscription.snapshot.data) {
              subscription.stale = true;
            }
            subscription.snapshot = {
              data: subscription.snapshot.data,
              isMissingData: backup.isMissingData,
              missingClientEdges: backup.missingClientEdges,
              missingLiveResolverFields: backup.missingLiveResolverFields,
              seenRecords: backup.seenRecords,
              selector: backup.selector,
              missingRequiredFields: backup.missingRequiredFields,
              relayResolverErrors: backup.relayResolverErrors,
              errorResponseFields: backup.errorResponseFields
            };
          } else {
            subscription.stale = true;
          }
        });
      };
      _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {
        var _this3 = this;
        var hasUpdatedRecords = updatedRecordIDs.size !== 0;
        this._subscriptions.forEach(function(subscription) {
          var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);
          if (owner != null) {
            updatedOwners.push(owner);
          }
        });
      };
      _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {
        var backup = subscription.backup, callback = subscription.callback, snapshot = subscription.snapshot, stale = subscription.stale;
        var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);
        if (!stale && !hasOverlappingUpdates) {
          return;
        }
        var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache, this._resolverContext) : backup;
        var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);
        nextSnapshot = {
          data: nextData,
          isMissingData: nextSnapshot.isMissingData,
          missingClientEdges: nextSnapshot.missingClientEdges,
          missingLiveResolverFields: nextSnapshot.missingLiveResolverFields,
          seenRecords: nextSnapshot.seenRecords,
          selector: nextSnapshot.selector,
          missingRequiredFields: nextSnapshot.missingRequiredFields,
          relayResolverErrors: nextSnapshot.relayResolverErrors,
          errorResponseFields: nextSnapshot.errorResponseFields
        };
        if (true) {
          deepFreeze(nextSnapshot);
        }
        subscription.snapshot = nextSnapshot;
        subscription.stale = false;
        if (nextSnapshot.data !== snapshot.data) {
          if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {
            this.__log({
              name: "store.notify.subscription",
              sourceOperation,
              snapshot,
              nextSnapshot
            });
          }
          callback(nextSnapshot);
          return snapshot.selector.owner;
        }
        if (RelayFeatureFlags.ENABLE_LOOSE_SUBSCRIPTION_ATTRIBUTION && (stale || hasSignificantOverlappingIDs(snapshot.seenRecords, updatedRecordIDs))) {
          return snapshot.selector.owner;
        }
      };
      _proto.size = function size() {
        return this._subscriptions.size;
      };
      return RelayStoreSubscriptions2;
    }();
    module.exports = RelayStoreSubscriptions;
  }
});

// node_modules/relay-runtime/lib/store/RelayModernStore.js
var require_RelayModernStore = __commonJS({
  "node_modules/relay-runtime/lib/store/RelayModernStore.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _require = require_ActorIdentifier();
    var INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE;
    var assertInternalActorIdentifier = _require.assertInternalActorIdentifier;
    var deepFreeze = require_deepFreeze();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var resolveImmediate = require_resolveImmediate();
    var DataChecker = require_DataChecker();
    var defaultGetDataID = require_defaultGetDataID();
    var RelayModernRecord = require_RelayModernRecord();
    var RelayOptimisticRecordSource = require_RelayOptimisticRecordSource();
    var RelayReader = require_RelayReader();
    var RelayReferenceMarker = require_RelayReferenceMarker();
    var RelayStoreSubscriptions = require_RelayStoreSubscriptions();
    var RelayStoreUtils = require_RelayStoreUtils();
    var _require2 = require_RelayStoreUtils();
    var ROOT_ID = _require2.ROOT_ID;
    var ROOT_TYPE = _require2.ROOT_TYPE;
    var _require3 = require_ResolverCache();
    var RecordResolverCache = _require3.RecordResolverCache;
    var invariant = require_browser();
    var DEFAULT_RELEASE_BUFFER_SIZE = 10;
    var RelayModernStore = function() {
      function RelayModernStore2(source, options) {
        var _this = this;
        var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;
        (0, _defineProperty2["default"])(this, "_gcStep", function() {
          if (_this._gcRun) {
            if (_this._gcRun.next().done) {
              _this._gcRun = null;
            } else {
              _this._gcScheduler(_this._gcStep);
            }
          }
        });
        if (true) {
          var storeIDs = source.getRecordIDs();
          for (var ii = 0; ii < storeIDs.length; ii++) {
            var record = source.get(storeIDs[ii]);
            if (record) {
              RelayModernRecord.freeze(record);
            }
          }
        }
        this._currentWriteEpoch = 0;
        this._gcHoldCounter = 0;
        this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;
        this._gcRun = null;
        this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;
        this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;
        this._globalInvalidationEpoch = null;
        this._invalidationSubscriptions = /* @__PURE__ */ new Set();
        this._invalidatedRecordIDs = /* @__PURE__ */ new Set();
        this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;
        this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;
        this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;
        this._optimisticSource = null;
        this._recordSource = source;
        this._releaseBuffer = [];
        this._roots = /* @__PURE__ */ new Map();
        this._shouldScheduleGC = false;
        this._resolverCache = new RecordResolverCache(function() {
          return _this._getMutableRecordSource();
        });
        this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache);
        this._updatedRecordIDs = /* @__PURE__ */ new Set();
        this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;
        initializeRecordSource(this._recordSource);
      }
      var _proto = RelayModernStore2.prototype;
      _proto.getSource = function getSource() {
        var _this$_optimisticSour;
        return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;
      };
      _proto._getMutableRecordSource = function _getMutableRecordSource() {
        var _this$_optimisticSour2;
        return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;
      };
      _proto.check = function check(operation, options) {
        var _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;
        var selector = operation.root;
        var source = this._getMutableRecordSource();
        var globalInvalidationEpoch = this._globalInvalidationEpoch;
        var rootEntry = this._roots.get(operation.request.identifier);
        var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null;
        if (globalInvalidationEpoch != null) {
          if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {
            return {
              status: "stale"
            };
          }
        }
        var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];
        var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function(actorIdentifier) {
          assertInternalActorIdentifier(actorIdentifier);
          return source;
        };
        var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function(actorIdentifier) {
          assertInternalActorIdentifier(actorIdentifier);
          return source;
        };
        var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents, this.__log);
        return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);
      };
      _proto.retain = function retain(operation) {
        var _this2 = this;
        var id = operation.request.identifier;
        var disposed = false;
        var dispose = function dispose2() {
          if (disposed) {
            return;
          }
          disposed = true;
          var rootEntry2 = _this2._roots.get(id);
          if (rootEntry2 == null) {
            return;
          }
          rootEntry2.refCount--;
          if (rootEntry2.refCount === 0) {
            var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;
            var rootEntryIsStale = rootEntry2.fetchTime != null && _queryCacheExpirationTime != null && rootEntry2.fetchTime <= Date.now() - _queryCacheExpirationTime;
            if (rootEntryIsStale) {
              _this2._roots["delete"](id);
              _this2.scheduleGC();
            } else {
              _this2._releaseBuffer.push(id);
              if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {
                var _id = _this2._releaseBuffer.shift();
                _this2._roots["delete"](_id);
                _this2.scheduleGC();
              }
            }
          }
        };
        var rootEntry = this._roots.get(id);
        if (rootEntry != null) {
          if (rootEntry.refCount === 0) {
            this._releaseBuffer = this._releaseBuffer.filter(function(_id) {
              return _id !== id;
            });
          }
          rootEntry.refCount += 1;
        } else {
          this._roots.set(id, {
            operation,
            refCount: 1,
            epoch: null,
            fetchTime: null
          });
        }
        return {
          dispose
        };
      };
      _proto.lookup = function lookup(selector) {
        var log = this.__log;
        if (log != null) {
          log({
            name: "store.lookup.start",
            selector
          });
        }
        var source = this.getSource();
        var snapshot = RelayReader.read(source, selector, this._resolverCache);
        if (true) {
          deepFreeze(snapshot);
        }
        if (log != null) {
          log({
            name: "store.lookup.end",
            selector
          });
        }
        return snapshot;
      };
      _proto.notify = function notify(sourceOperation, invalidateStore) {
        var _this3 = this;
        var log = this.__log;
        if (log != null) {
          log({
            name: "store.notify.start",
            sourceOperation
          });
        }
        this._currentWriteEpoch++;
        if (invalidateStore === true) {
          this._globalInvalidationEpoch = this._currentWriteEpoch;
        }
        if (RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {
          this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);
        }
        var source = this.getSource();
        var updatedOwners = [];
        this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);
        this._invalidationSubscriptions.forEach(function(subscription) {
          _this3._updateInvalidationSubscription(subscription, invalidateStore === true);
        });
        if (sourceOperation != null) {
          var id = sourceOperation.request.identifier;
          var rootEntry = this._roots.get(id);
          if (rootEntry != null) {
            rootEntry.epoch = this._currentWriteEpoch;
            rootEntry.fetchTime = Date.now();
          } else if (sourceOperation.request.node.params.operationKind === "query" && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {
            var temporaryRootEntry = {
              operation: sourceOperation,
              refCount: 0,
              epoch: this._currentWriteEpoch,
              fetchTime: Date.now()
            };
            this._releaseBuffer.push(id);
            this._roots.set(id, temporaryRootEntry);
          }
        }
        if (log != null) {
          log({
            name: "store.notify.complete",
            sourceOperation,
            updatedRecordIDs: this._updatedRecordIDs,
            invalidatedRecordIDs: this._invalidatedRecordIDs,
            subscriptionsSize: this._storeSubscriptions.size(),
            updatedOwners
          });
        }
        this._updatedRecordIDs.clear();
        this._invalidatedRecordIDs.clear();
        return updatedOwners;
      };
      _proto.publish = function publish(source, idsMarkedForInvalidation) {
        var target = this._getMutableRecordSource();
        updateTargetFromSource(target, source, this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs);
        var log = this.__log;
        if (log != null) {
          log({
            name: "store.publish",
            source,
            optimistic: target === this._optimisticSource
          });
        }
      };
      _proto.subscribe = function subscribe(snapshot, callback) {
        return this._storeSubscriptions.subscribe(snapshot, callback);
      };
      _proto.holdGC = function holdGC() {
        var _this4 = this;
        if (this._gcRun) {
          this._gcRun = null;
          this._shouldScheduleGC = true;
        }
        this._gcHoldCounter++;
        var dispose = function dispose2() {
          if (_this4._gcHoldCounter > 0) {
            _this4._gcHoldCounter--;
            if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {
              _this4.scheduleGC();
              _this4._shouldScheduleGC = false;
            }
          }
        };
        return {
          dispose
        };
      };
      _proto.toJSON = function toJSON() {
        return "RelayModernStore()";
      };
      _proto.getEpoch = function getEpoch() {
        return this._currentWriteEpoch;
      };
      _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {
        return this._updatedRecordIDs;
      };
      _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {
        var _this5 = this;
        var invalidations = /* @__PURE__ */ new Map();
        dataIDs.forEach(function(dataID) {
          var _RelayModernRecord$ge;
          var record = _this5.getSource().get(dataID);
          invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);
        });
        invalidations.set("global", this._globalInvalidationEpoch);
        return {
          dataIDs,
          invalidations
        };
      };
      _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {
        var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);
        var currentInvalidations = latestInvalidationState.invalidations;
        var prevInvalidations = prevInvalidationState.invalidations;
        if (currentInvalidations.get("global") !== prevInvalidations.get("global")) {
          return true;
        }
        var _iterator = (0, _createForOfIteratorHelper2["default"])(prevInvalidationState.dataIDs), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var dataID = _step.value;
            if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {
              return true;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return false;
      };
      _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {
        var _this6 = this;
        var subscription = {
          callback,
          invalidationState
        };
        var dispose = function dispose2() {
          _this6._invalidationSubscriptions["delete"](subscription);
        };
        this._invalidationSubscriptions.add(subscription);
        return {
          dispose
        };
      };
      _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {
        var _this7 = this;
        var callback = subscription.callback, invalidationState = subscription.invalidationState;
        var dataIDs = invalidationState.dataIDs;
        var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function(dataID) {
          return _this7._invalidatedRecordIDs.has(dataID);
        });
        if (!isSubscribedToInvalidatedIDs) {
          return;
        }
        callback();
      };
      _proto.snapshot = function snapshot() {
        !(this._optimisticSource == null) ? true ? invariant(false, "RelayModernStore: Unexpected call to snapshot() while a previous snapshot exists.") : invariant(false) : void 0;
        var log = this.__log;
        if (log != null) {
          log({
            name: "store.snapshot"
          });
        }
        this._storeSubscriptions.snapshotSubscriptions(this.getSource());
        if (this._gcRun) {
          this._gcRun = null;
          this._shouldScheduleGC = true;
        }
        this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());
      };
      _proto.restore = function restore() {
        !(this._optimisticSource != null) ? true ? invariant(false, "RelayModernStore: Unexpected call to restore(), expected a snapshot to exist (make sure to call snapshot()).") : invariant(false) : void 0;
        var log = this.__log;
        if (log != null) {
          log({
            name: "store.restore"
          });
        }
        this._optimisticSource = null;
        if (this._shouldScheduleGC) {
          this.scheduleGC();
        }
        this._storeSubscriptions.restoreSubscriptions();
      };
      _proto.scheduleGC = function scheduleGC() {
        if (this._gcHoldCounter > 0) {
          this._shouldScheduleGC = true;
          return;
        }
        if (this._gcRun) {
          return;
        }
        this._gcRun = this._collect();
        this._gcScheduler(this._gcStep);
      };
      _proto.__gc = function __gc() {
        if (this._optimisticSource != null) {
          return;
        }
        var gcRun = this._collect();
        while (!gcRun.next().done) {
        }
      };
      _proto._collect = function* _collect() {
        var log = this.__log;
        top: while (true) {
          if (log != null) {
            log({
              name: "store.gc.start"
            });
          }
          var startEpoch = this._currentWriteEpoch;
          var references = /* @__PURE__ */ new Set();
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._roots.values()), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var operation = _step2.value.operation;
              var selector = operation.root;
              RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents);
              yield;
              if (startEpoch !== this._currentWriteEpoch) {
                if (log != null) {
                  log({
                    name: "store.gc.interrupted"
                  });
                }
                continue top;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          if (references.size === 0) {
            this._recordSource.clear();
          } else {
            var storeIDs = this._recordSource.getRecordIDs();
            for (var ii = 0; ii < storeIDs.length; ii++) {
              var dataID = storeIDs[ii];
              if (!references.has(dataID)) {
                this._recordSource.remove(dataID);
              }
            }
          }
          if (log != null) {
            log({
              name: "store.gc.end",
              references
            });
          }
          return;
        }
      };
      return RelayModernStore2;
    }();
    function initializeRecordSource(target) {
      if (!target.has(ROOT_ID)) {
        var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);
        target.set(ROOT_ID, rootRecord);
      }
    }
    function updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {
      if (idsMarkedForInvalidation) {
        idsMarkedForInvalidation.forEach(function(dataID2) {
          var targetRecord2 = target.get(dataID2);
          var sourceRecord2 = source.get(dataID2);
          if (sourceRecord2 === null) {
            return;
          }
          var nextRecord2;
          if (targetRecord2 != null) {
            nextRecord2 = RelayModernRecord.clone(targetRecord2);
          } else {
            nextRecord2 = sourceRecord2 != null ? RelayModernRecord.clone(sourceRecord2) : null;
          }
          if (!nextRecord2) {
            return;
          }
          RelayModernRecord.setValue(nextRecord2, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);
          invalidatedRecordIDs.add(dataID2);
          target.set(dataID2, nextRecord2);
        });
      }
      var dataIDs = source.getRecordIDs();
      for (var ii = 0; ii < dataIDs.length; ii++) {
        var dataID = dataIDs[ii];
        var sourceRecord = source.get(dataID);
        var targetRecord = target.get(dataID);
        if (true) {
          if (sourceRecord) {
            RelayModernRecord.freeze(sourceRecord);
          }
        }
        if (sourceRecord && targetRecord) {
          var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);
          if (nextRecord !== targetRecord) {
            if (true) {
              RelayModernRecord.freeze(nextRecord);
            }
            updatedRecordIDs.add(dataID);
            target.set(dataID, nextRecord);
          }
        } else if (sourceRecord === null) {
          target["delete"](dataID);
          if (targetRecord !== null) {
            updatedRecordIDs.add(dataID);
          }
        } else if (sourceRecord) {
          target.set(dataID, sourceRecord);
          updatedRecordIDs.add(dataID);
        }
      }
    }
    function getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {
      var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt, status = operationAvailability.status;
      if (typeof mostRecentlyInvalidatedAt === "number") {
        if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {
          return {
            status: "stale"
          };
        }
      }
      if (status === "missing") {
        return {
          status: "missing"
        };
      }
      if (operationFetchTime != null && queryCacheExpirationTime != null) {
        var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;
        if (isStale) {
          return {
            status: "stale"
          };
        }
      }
      return {
        status: "available",
        fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null
      };
    }
    module.exports = RelayModernStore;
  }
});

// node_modules/relay-runtime/lib/subscription/requestSubscription.js
var require_requestSubscription = __commonJS({
  "node_modules/relay-runtime/lib/subscription/requestSubscription.js"(exports, module) {
    "use strict";
    var RelayDeclarativeMutationConfig = require_RelayDeclarativeMutationConfig();
    var _require = require_GraphQLTag();
    var getRequest = _require.getRequest;
    var _require2 = require_RelayModernOperationDescriptor();
    var createOperationDescriptor = _require2.createOperationDescriptor;
    var _require3 = require_RelayModernSelector();
    var createReaderSelector = _require3.createReaderSelector;
    var warning = require_warning();
    function requestSubscription(environment, config) {
      var subscription = getRequest(config.subscription);
      if (subscription.params.operationKind !== "subscription") {
        throw new Error("requestSubscription: Must use Subscription operation");
      }
      var configs = config.configs, onCompleted = config.onCompleted, onError = config.onError, onNext = config.onNext, variables = config.variables, cacheConfig = config.cacheConfig;
      var operation = createOperationDescriptor(subscription, variables, cacheConfig);
      true ? warning(!(config.updater && configs), "requestSubscription: Expected only one of `updater` and `configs` to be provided") : void 0;
      var _ref = configs ? RelayDeclarativeMutationConfig.convert(configs, subscription, null, config.updater) : config, updater = _ref.updater;
      var sub = environment.executeSubscription({
        operation,
        updater
      }).subscribe({
        next: function next(responses) {
          if (onNext != null) {
            var selector = operation.fragment;
            var nextID;
            if (Array.isArray(responses)) {
              var _responses$, _responses$$extension;
              nextID = (_responses$ = responses[0]) === null || _responses$ === void 0 ? void 0 : (_responses$$extension = _responses$.extensions) === null || _responses$$extension === void 0 ? void 0 : _responses$$extension.__relay_subscription_root_id;
            } else {
              var _responses$extensions;
              nextID = (_responses$extensions = responses.extensions) === null || _responses$extensions === void 0 ? void 0 : _responses$extensions.__relay_subscription_root_id;
            }
            if (typeof nextID === "string") {
              selector = createReaderSelector(selector.node, nextID, selector.variables, selector.owner);
            }
            var data = environment.lookup(selector).data;
            onNext(data);
          }
        },
        error: onError,
        complete: onCompleted
      });
      return {
        dispose: sub.unsubscribe
      };
    }
    module.exports = requestSubscription;
  }
});

// node_modules/relay-runtime/lib/util/createPayloadFor3DField.js
var require_createPayloadFor3DField = __commonJS({
  "node_modules/relay-runtime/lib/util/createPayloadFor3DField.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _require = require_RelayStoreUtils();
    var getModuleComponentKey = _require.getModuleComponentKey;
    var getModuleOperationKey = _require.getModuleOperationKey;
    function createPayloadFor3DField(name, operation, component, response) {
      var data = (0, _objectSpread2["default"])({}, response);
      data[getModuleComponentKey(name)] = component;
      data[getModuleOperationKey(name)] = operation;
      return data;
    }
    module.exports = createPayloadFor3DField;
  }
});

// node_modules/relay-runtime/lib/util/isEmptyObject.js
var require_isEmptyObject = __commonJS({
  "node_modules/relay-runtime/lib/util/isEmptyObject.js"(exports, module) {
    "use strict";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function isEmptyObject(obj) {
      for (var _key in obj) {
        if (hasOwnProperty.call(obj, _key)) {
          return false;
        }
      }
      return true;
    }
    module.exports = isEmptyObject;
  }
});

// node_modules/relay-runtime/lib/util/getFragmentIdentifier.js
var require_getFragmentIdentifier = __commonJS({
  "node_modules/relay-runtime/lib/util/getFragmentIdentifier.js"(exports, module) {
    "use strict";
    var _require = require_RelayModernSelector();
    var getDataIDsFromFragment = _require.getDataIDsFromFragment;
    var getSelector = _require.getSelector;
    var getVariablesFromFragment = _require.getVariablesFromFragment;
    var isEmptyObject = require_isEmptyObject();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var _require2 = require_stableCopy();
    var stableCopy = _require2.stableCopy;
    var _require3 = require_StringInterner();
    var intern = _require3.intern;
    function getFragmentIdentifier(fragmentNode, fragmentRef) {
      var selector = getSelector(fragmentNode, fragmentRef);
      var fragmentOwnerIdentifier = selector == null ? "null" : selector.kind === "SingularReaderSelector" ? selector.owner.identifier : "[" + selector.selectors.map(function(sel) {
        return sel.owner.identifier;
      }).join(",") + "]";
      var fragmentVariables = getVariablesFromFragment(fragmentNode, fragmentRef);
      var dataIDs = getDataIDsFromFragment(fragmentNode, fragmentRef);
      if (RelayFeatureFlags.ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION) {
        var ids = typeof dataIDs === "undefined" ? "missing" : dataIDs == null ? "null" : Array.isArray(dataIDs) ? "[" + dataIDs.join(",") + "]" : dataIDs;
        ids = RelayFeatureFlags.STRING_INTERN_LEVEL <= 1 ? ids : intern(ids, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
        return fragmentOwnerIdentifier + "/" + fragmentNode.name + "/" + (fragmentVariables == null || isEmptyObject(fragmentVariables) ? "{}" : JSON.stringify(stableCopy(fragmentVariables))) + "/" + ids;
      } else {
        var _JSON$stringify;
        var _ids = (_JSON$stringify = JSON.stringify(dataIDs)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "missing";
        _ids = RelayFeatureFlags.STRING_INTERN_LEVEL <= 1 ? _ids : intern(_ids, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
        return fragmentOwnerIdentifier + "/" + fragmentNode.name + "/" + JSON.stringify(stableCopy(fragmentVariables)) + "/" + _ids;
      }
    }
    module.exports = getFragmentIdentifier;
  }
});

// node_modules/relay-runtime/lib/util/getRefetchMetadata.js
var require_getRefetchMetadata = __commonJS({
  "node_modules/relay-runtime/lib/util/getRefetchMetadata.js"(exports, module) {
    "use strict";
    var invariant = require_browser();
    function getRefetchMetadata(fragmentNode, componentDisplayName) {
      var _fragmentNode$metadat, _fragmentNode$metadat2;
      !(((_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) !== true) ? true ? invariant(false, "Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using `%s`. Remove `@relay(plural: true)` from fragment `%s` in order to use it with `%s`.", fragmentNode.name, componentDisplayName, fragmentNode.name, componentDisplayName) : invariant(false) : void 0;
      var refetchMetadata = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.refetch;
      !(refetchMetadata != null) ? true ? invariant(false, "Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. Did you forget to add a @refetchable directive to the fragment?", componentDisplayName, fragmentNode.name) : invariant(false) : void 0;
      var refetchableRequest = refetchMetadata.operation["default"] ? refetchMetadata.operation["default"] : refetchMetadata.operation;
      var fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;
      !(typeof refetchableRequest !== "string") ? true ? invariant(false, "Relay: getRefetchMetadata(): Expected refetch query to be an operation and not a string when using `%s`. If you're seeing this, this is likely a bug in Relay.", componentDisplayName) : invariant(false) : void 0;
      var identifierInfo = refetchMetadata.identifierInfo;
      if (identifierInfo != null) {
        !(identifierInfo.identifierField == null || typeof identifierInfo.identifierField === "string") ? true ? invariant(false, "Relay: getRefetchMetadata(): Expected `identifierField` to be a string.") : invariant(false) : void 0;
        !(identifierInfo.identifierQueryVariableName == null || typeof identifierInfo.identifierQueryVariableName === "string") ? true ? invariant(false, "Relay: getRefetchMetadata(): Expected `identifierQueryVariableName` to be a string.") : invariant(false) : void 0;
      }
      return {
        fragmentRefPathInResponse,
        identifierInfo,
        refetchableRequest,
        refetchMetadata
      };
    }
    module.exports = getRefetchMetadata;
  }
});

// node_modules/relay-runtime/lib/util/getPaginationMetadata.js
var require_getPaginationMetadata = __commonJS({
  "node_modules/relay-runtime/lib/util/getPaginationMetadata.js"(exports, module) {
    "use strict";
    var getRefetchMetadata = require_getRefetchMetadata();
    var invariant = require_browser();
    function getPaginationMetadata(fragmentNode, componentDisplayName) {
      var _fragmentNode$metadat, _fragmentNode$metadat2;
      var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), paginationRequest = _getRefetchMetadata.refetchableRequest, refetchMetadata = _getRefetchMetadata.refetchMetadata;
      var paginationMetadata = refetchMetadata.connection;
      !(paginationMetadata != null) ? true ? invariant(false, "Relay: getPaginationMetadata(): Expected fragment `%s` to include a connection when using `%s`. Did you forget to add a @connection directive to the connection field in the fragment?", componentDisplayName, fragmentNode.name) : invariant(false) : void 0;
      var connectionPathInFragmentData = paginationMetadata.path;
      var connectionMetadata = ((_fragmentNode$metadat = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.connection) !== null && _fragmentNode$metadat !== void 0 ? _fragmentNode$metadat : [])[0];
      !(connectionMetadata != null) ? true ? invariant(false, "Relay: getPaginationMetadata(): Expected fragment `%s` to include a connection when using `%s`. Did you forget to add a @connection directive to the connection field in the fragment?", componentDisplayName, fragmentNode.name) : invariant(false) : void 0;
      var identifierInfo = refetchMetadata.identifierInfo;
      !((identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) == null || typeof identifierInfo.identifierField === "string") ? true ? invariant(false, "Relay: getRefetchMetadata(): Expected `identifierField` to be a string.") : invariant(false) : void 0;
      return {
        connectionPathInFragmentData,
        identifierField: identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField,
        paginationRequest,
        paginationMetadata,
        stream: connectionMetadata.stream === true
      };
    }
    module.exports = getPaginationMetadata;
  }
});

// node_modules/relay-runtime/lib/util/getPaginationVariables.js
var require_getPaginationVariables = __commonJS({
  "node_modules/relay-runtime/lib/util/getPaginationVariables.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _objectSpread4 = _interopRequireDefault(require_objectSpread2());
    var invariant = require_browser();
    var warning = require_warning();
    function getPaginationVariables(direction, count, cursor, baseVariables, extraVariables, paginationMetadata) {
      var _objectSpread3;
      var backwardMetadata = paginationMetadata.backward, forwardMetadata = paginationMetadata.forward;
      if (direction === "backward") {
        var _objectSpread2;
        !(backwardMetadata != null && backwardMetadata.count != null && backwardMetadata.cursor != null) ? true ? invariant(false, "Relay: Expected backward pagination metadata to be available. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
        true ? warning(!extraVariables.hasOwnProperty(backwardMetadata.cursor), "Relay: `UNSTABLE_extraVariables` provided by caller should not contain cursor variable `%s`. This variable is automatically determined by Relay.", backwardMetadata.cursor) : void 0;
        true ? warning(!extraVariables.hasOwnProperty(backwardMetadata.count), "Relay: `UNSTABLE_extraVariables` provided by caller should not contain count variable `%s`. This variable is automatically determined by Relay.", backwardMetadata.count) : void 0;
        var _paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread2 = {}, (0, _defineProperty2["default"])(_objectSpread2, backwardMetadata.cursor, cursor), (0, _defineProperty2["default"])(_objectSpread2, backwardMetadata.count, count), _objectSpread2));
        if (forwardMetadata && forwardMetadata.cursor) {
          _paginationVariables[forwardMetadata.cursor] = null;
        }
        if (forwardMetadata && forwardMetadata.count) {
          _paginationVariables[forwardMetadata.count] = null;
        }
        return _paginationVariables;
      }
      !(forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null) ? true ? invariant(false, "Relay: Expected forward pagination metadata to be available. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
      true ? warning(!extraVariables.hasOwnProperty(forwardMetadata.cursor), "Relay: `UNSTABLE_extraVariables` provided by caller should not contain cursor variable `%s`. This variable is automatically determined by Relay.", forwardMetadata.cursor) : void 0;
      true ? warning(!extraVariables.hasOwnProperty(forwardMetadata.count), "Relay: `UNSTABLE_extraVariables` provided by caller should not contain count variable `%s`. This variable is automatically determined by Relay.", forwardMetadata.count) : void 0;
      var paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread3 = {}, (0, _defineProperty2["default"])(_objectSpread3, forwardMetadata.cursor, cursor), (0, _defineProperty2["default"])(_objectSpread3, forwardMetadata.count, count), _objectSpread3));
      if (backwardMetadata && backwardMetadata.cursor) {
        paginationVariables[backwardMetadata.cursor] = null;
      }
      if (backwardMetadata && backwardMetadata.count) {
        paginationVariables[backwardMetadata.count] = null;
      }
      return paginationVariables;
    }
    module.exports = getPaginationVariables;
  }
});

// node_modules/relay-runtime/lib/util/getValueAtPath.js
var require_getValueAtPath = __commonJS({
  "node_modules/relay-runtime/lib/util/getValueAtPath.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
    var invariant = require_browser();
    function getValueAtPath(data, path) {
      var result = data;
      var _iterator = (0, _createForOfIteratorHelper2["default"])(path), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var key = _step.value;
          if (result == null) {
            return null;
          }
          if (typeof key === "number") {
            !Array.isArray(result) ? true ? invariant(false, "Relay: Expected an array when extracting value at path. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
            result = result[key];
          } else {
            !(typeof result === "object" && !Array.isArray(result)) ? true ? invariant(false, "Relay: Expected an object when extracting value at path. If you're seeing this, this is likely a bug in Relay.") : invariant(false) : void 0;
            result = result[key];
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return result;
    }
    module.exports = getValueAtPath;
  }
});

// node_modules/relay-runtime/lib/util/RelayProfiler.js
var require_RelayProfiler = __commonJS({
  "node_modules/relay-runtime/lib/util/RelayProfiler.js"(exports, module) {
    "use strict";
    var profileHandlersByName = {};
    var defaultProfiler = {
      stop: function stop() {
      }
    };
    var RelayProfiler = {
      profile: function profile(name, state) {
        var handlers = profileHandlersByName[name];
        if (handlers && handlers.length > 0) {
          var stopHandlers = [];
          for (var ii = handlers.length - 1; ii >= 0; ii--) {
            var stopHandler = handlers[ii](name, state);
            stopHandlers.unshift(stopHandler);
          }
          return {
            stop: function stop(error) {
              stopHandlers.forEach(function(stopHandler2) {
                return stopHandler2(error);
              });
            }
          };
        }
        return defaultProfiler;
      },
      attachProfileHandler: function attachProfileHandler(name, handler) {
        if (!profileHandlersByName.hasOwnProperty(name)) {
          profileHandlersByName[name] = [];
        }
        profileHandlersByName[name].push(handler);
      },
      detachProfileHandler: function detachProfileHandler(name, handler) {
        if (profileHandlersByName.hasOwnProperty(name)) {
          removeFromArray(profileHandlersByName[name], handler);
        }
      }
    };
    function removeFromArray(array, element) {
      var index = array.indexOf(element);
      if (index !== -1) {
        array.splice(index, 1);
      }
    }
    module.exports = RelayProfiler;
  }
});

// node_modules/relay-runtime/lib/index.js
var require_lib = __commonJS({
  "node_modules/relay-runtime/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_experimental();
    var isErrorResult = _require.isErrorResult;
    var isValueResult = _require.isValueResult;
    var ConnectionHandler = require_ConnectionHandler();
    var ConnectionInterface = require_ConnectionInterface();
    var MutationHandlers = require_MutationHandlers();
    var RelayDefaultHandlerProvider = require_RelayDefaultHandlerProvider();
    var applyOptimisticMutation = require_applyOptimisticMutation();
    var commitLocalUpdate = require_commitLocalUpdate();
    var commitMutation = require_commitMutation();
    var RelayDeclarativeMutationConfig = require_RelayDeclarativeMutationConfig();
    var RelayNetwork = require_RelayNetwork();
    var RelayObservable = require_RelayObservable();
    var RelayQueryResponseCache = require_RelayQueryResponseCache();
    var fetchQuery = require_fetchQuery();
    var fetchQuery_DEPRECATED = require_fetchQuery_DEPRECATED();
    var fetchQueryInternal = require_fetchQueryInternal();
    var GraphQLTag = require_GraphQLTag();
    var PreloadableQueryRegistry = require_PreloadableQueryRegistry();
    var _require2 = require_ClientID();
    var generateClientID = _require2.generateClientID;
    var generateUniqueClientID = _require2.generateUniqueClientID;
    var isClientID = _require2.isClientID;
    var createFragmentSpecResolver = require_createFragmentSpecResolver();
    var createRelayContext = require_createRelayContext();
    var _require3 = require_LiveResolverSuspenseSentinel();
    var isSuspenseSentinel = _require3.isSuspenseSentinel;
    var suspenseSentinel = _require3.suspenseSentinel;
    var isRelayModernEnvironment = require_isRelayModernEnvironment();
    var normalizeResponse = require_normalizeResponse();
    var readInlineData = require_readInlineData();
    var RelayConcreteVariables = require_RelayConcreteVariables();
    var RelayModernEnvironment = require_RelayModernEnvironment();
    var RelayModernOperationDescriptor = require_RelayModernOperationDescriptor();
    var RelayModernRecord = require_RelayModernRecord();
    var RelayModernSelector = require_RelayModernSelector();
    var RelayModernStore = require_RelayModernStore();
    var RelayOperationTracker = require_RelayOperationTracker();
    var RelayRecordSource = require_RelayRecordSource();
    var RelayStoreUtils = require_RelayStoreUtils();
    var ResolverFragments = require_ResolverFragments();
    var ViewerPattern = require_ViewerPattern();
    var requestSubscription = require_requestSubscription();
    var createPayloadFor3DField = require_createPayloadFor3DField();
    var deepFreeze = require_deepFreeze();
    var getFragmentIdentifier = require_getFragmentIdentifier();
    var getPaginationMetadata = require_getPaginationMetadata();
    var getPaginationVariables = require_getPaginationVariables();
    var getPendingOperationsForFragment = require_getPendingOperationsForFragment();
    var getRefetchMetadata = require_getRefetchMetadata();
    var getRelayHandleKey = require_getRelayHandleKey();
    var getRequestIdentifier = require_getRequestIdentifier();
    var getValueAtPath = require_getValueAtPath();
    var handlePotentialSnapshotErrors = require_handlePotentialSnapshotErrors();
    var isPromise = require_isPromise();
    var isScalarAndEqual = require_isScalarAndEqual();
    var recycleNodesInto = require_recycleNodesInto();
    var RelayConcreteNode = require_RelayConcreteNode();
    var RelayDefaultHandleKey = require_RelayDefaultHandleKey();
    var RelayError = require_RelayError();
    var RelayFeatureFlags = require_RelayFeatureFlags();
    var RelayProfiler = require_RelayProfiler();
    var RelayReplaySubject = require_RelayReplaySubject();
    var _require4 = require_stableCopy();
    var hasCycle = _require4.hasCycle;
    var stableCopy = _require4.stableCopy;
    var withProvidedVariables = require_withProvidedVariables();
    if (true) {
      mapStr = typeof Map !== "function" ? "Map" : null;
      setStr = typeof Set !== "function" ? "Set" : null;
      promiseStr = typeof Promise !== "function" ? "Promise" : null;
      objStr = typeof Object.assign !== "function" ? "Object.assign" : null;
      if (mapStr || setStr || promiseStr || objStr) {
        throw new Error("relay-runtime requires ".concat([mapStr, setStr, promiseStr, objStr].filter(Boolean).join(", and "), " to exist. ") + "Use a polyfill to provide these for older browsers.");
      }
    }
    var mapStr;
    var setStr;
    var promiseStr;
    var objStr;
    module.exports = {
      Environment: RelayModernEnvironment,
      Network: RelayNetwork,
      Observable: RelayObservable,
      QueryResponseCache: RelayQueryResponseCache,
      RecordSource: RelayRecordSource,
      Record: RelayModernRecord,
      ReplaySubject: RelayReplaySubject,
      Store: RelayModernStore,
      areEqualSelectors: RelayModernSelector.areEqualSelectors,
      createFragmentSpecResolver,
      createNormalizationSelector: RelayModernSelector.createNormalizationSelector,
      createOperationDescriptor: RelayModernOperationDescriptor.createOperationDescriptor,
      createReaderSelector: RelayModernSelector.createReaderSelector,
      createRequestDescriptor: RelayModernOperationDescriptor.createRequestDescriptor,
      getArgumentValues: RelayStoreUtils.getArgumentValues,
      getDataIDsFromFragment: RelayModernSelector.getDataIDsFromFragment,
      getDataIDsFromObject: RelayModernSelector.getDataIDsFromObject,
      getNode: GraphQLTag.getNode,
      getFragment: GraphQLTag.getFragment,
      getInlineDataFragment: GraphQLTag.getInlineDataFragment,
      getModuleComponentKey: RelayStoreUtils.getModuleComponentKey,
      getModuleOperationKey: RelayStoreUtils.getModuleOperationKey,
      getPaginationFragment: GraphQLTag.getPaginationFragment,
      getPluralSelector: RelayModernSelector.getPluralSelector,
      getRefetchableFragment: GraphQLTag.getRefetchableFragment,
      getRequest: GraphQLTag.getRequest,
      getRequestIdentifier,
      getSelector: RelayModernSelector.getSelector,
      getSelectorsFromObject: RelayModernSelector.getSelectorsFromObject,
      getSingularSelector: RelayModernSelector.getSingularSelector,
      getStorageKey: RelayStoreUtils.getStorageKey,
      getVariablesFromFragment: RelayModernSelector.getVariablesFromFragment,
      getVariablesFromObject: RelayModernSelector.getVariablesFromObject,
      getVariablesFromPluralFragment: RelayModernSelector.getVariablesFromPluralFragment,
      getVariablesFromSingularFragment: RelayModernSelector.getVariablesFromSingularFragment,
      handlePotentialSnapshotErrors,
      graphql: GraphQLTag.graphql,
      isErrorResult,
      isValueResult,
      isFragment: GraphQLTag.isFragment,
      isInlineDataFragment: GraphQLTag.isInlineDataFragment,
      isSuspenseSentinel,
      suspenseSentinel,
      isRequest: GraphQLTag.isRequest,
      readInlineData,
      MutationTypes: RelayDeclarativeMutationConfig.MutationTypes,
      RangeOperations: RelayDeclarativeMutationConfig.RangeOperations,
      DefaultHandlerProvider: RelayDefaultHandlerProvider,
      ConnectionHandler,
      MutationHandlers,
      VIEWER_ID: ViewerPattern.VIEWER_ID,
      VIEWER_TYPE: ViewerPattern.VIEWER_TYPE,
      applyOptimisticMutation,
      commitLocalUpdate,
      commitMutation,
      fetchQuery,
      fetchQuery_DEPRECATED,
      isRelayModernEnvironment,
      requestSubscription,
      ConnectionInterface,
      PreloadableQueryRegistry,
      RelayProfiler,
      createPayloadFor3DField,
      RelayConcreteNode,
      RelayError,
      RelayFeatureFlags,
      DEFAULT_HANDLE_KEY: RelayDefaultHandleKey.DEFAULT_HANDLE_KEY,
      FRAGMENTS_KEY: RelayStoreUtils.FRAGMENTS_KEY,
      FRAGMENT_OWNER_KEY: RelayStoreUtils.FRAGMENT_OWNER_KEY,
      ID_KEY: RelayStoreUtils.ID_KEY,
      REF_KEY: RelayStoreUtils.REF_KEY,
      REFS_KEY: RelayStoreUtils.REFS_KEY,
      ROOT_ID: RelayStoreUtils.ROOT_ID,
      ROOT_TYPE: RelayStoreUtils.ROOT_TYPE,
      TYPENAME_KEY: RelayStoreUtils.TYPENAME_KEY,
      deepFreeze,
      generateClientID,
      generateUniqueClientID,
      getRelayHandleKey,
      isClientID,
      isPromise,
      isScalarAndEqual,
      recycleNodesInto,
      stableCopy,
      hasCycle,
      getFragmentIdentifier,
      getRefetchMetadata,
      getPaginationMetadata,
      getPaginationVariables,
      getPendingOperationsForFragment,
      getValueAtPath,
      __internal: {
        ResolverFragments,
        OperationTracker: RelayOperationTracker,
        createRelayContext,
        getOperationVariables: RelayConcreteVariables.getOperationVariables,
        getLocalVariables: RelayConcreteVariables.getLocalVariables,
        fetchQuery: fetchQueryInternal.fetchQuery,
        fetchQueryDeduped: fetchQueryInternal.fetchQueryDeduped,
        getPromiseForActiveRequest: fetchQueryInternal.getPromiseForActiveRequest,
        getObservableForActiveRequest: fetchQueryInternal.getObservableForActiveRequest,
        normalizeResponse,
        withProvidedVariables
      }
    };
  }
});

// node_modules/relay-runtime/index.js
var require_relay_runtime = __commonJS({
  "node_modules/relay-runtime/index.js"(exports, module) {
    module.exports = require_lib();
  }
});

export {
  require_browser,
  require_warning,
  require_interopRequireDefault,
  require_defineProperty,
  require_objectSpread2,
  require_toConsumableArray,
  require_areEqual,
  require_createForOfIteratorHelper,
  require_objectWithoutPropertiesLoose,
  require_inheritsLoose,
  require_relay_runtime
};
/*! Bundled license information:

fbjs/lib/areEqual.js:
  (**
   * Checks if two values are equal. Values may be primitives, arrays, or objects.
   * Returns true if both arguments have the same keys and values.
   *
   * @see http://underscorejs.org
   * @copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-2R7SA2UJ.js.map
